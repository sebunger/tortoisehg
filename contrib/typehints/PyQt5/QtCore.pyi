# The PEP 484 type hints stub file for the QtCore module.
#
# Generated by SIP 4.19.19
#
# Copyright (c) 2019 Riverbank Computing Limited <info@riverbankcomputing.com>
# 
# This file is part of PyQt5.
# 
# This file may be used under the terms of the GNU General Public License
# version 3.0 as published by the Free Software Foundation and appearing in
# the file LICENSE included in the packaging of this file.  Please review the
# following information to ensure the GNU General Public License version 3.0
# requirements will be met: http://www.gnu.org/copyleft/gpl.html.
# 
# If you do not wish to use this file under the terms of the GPL version 3.0
# then you may purchase a commercial license.  For more information contact
# info@riverbankcomputing.com.
# 
# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


import typing
import sip

from typing import overload

from PyQt5.QtWidgets import QWidget

# Support for QDate, QDateTime and QTime.
import datetime

# Support for new-style signals and slots.
class pyqtSignal:
    def __init__(self, *types, name: str = ...) -> None: ...

    # pyqtBoundSignal:
    def connect(self, reciever: PYQT_SLOT, type: int = ...) -> None: ...
    def disconnect(self, reciever: PYQT_SLOT) -> None: ...
    def emit(self, *args) -> None: ...
    def __getitem__(self, *types) -> pyqtBoundSignal

pyqtBoundSignal = pyqtSignal

# Convenient type aliases.
PYQT_SIGNAL = typing.Union[pyqtSignal, pyqtBoundSignal]
PYQT_SLOT = typing.Union[typing.Callable[...], pyqtBoundSignal]


QtMsgType = int
#class QtMsgType(int): ...
QtDebugMsg = ... # type: int
QtWarningMsg = ... # type: int
QtCriticalMsg = ... # type: int
QtFatalMsg = ... # type: int
QtSystemMsg = ... # type: int
QtInfoMsg = ... # type: int


QCborKnownTags = int
#class QCborKnownTags(int): ...
DateTimeString = ... # type: int
UnixTime_t = ... # type: int
PositiveBignum = ... # type: int
NegativeBignum = ... # type: int
Decimal = ... # type: int
Bigfloat = ... # type: int
COSE_Encrypt0 = ... # type: int
COSE_Mac0 = ... # type: int
COSE_Sign1 = ... # type: int
ExpectedBase64url = ... # type: int
ExpectedBase64 = ... # type: int
ExpectedBase16 = ... # type: int
EncodedCbor = ... # type: int
Url = ... # type: int
Base64url = ... # type: int
Base64 = ... # type: int
RegularExpression = ... # type: int
MimeMessage = ... # type: int
Uuid = ... # type: int
COSE_Encrypt = ... # type: int
COSE_Mac = ... # type: int
COSE_Sign = ... # type: int
Signature = ... # type: int


QCborSimpleType = int
#class QCborSimpleType(int): ...
False_ = ... # type: int
True_ = ... # type: int
Null = ... # type: int
Undefined = ... # type: int


class Qt(sip.simplewrapper):

    ChecksumType: typing.Type[int]
    #class ChecksumType(int): ...
    ChecksumIso3309 = ... # type: int
    ChecksumItuV41 = ... # type: int

    EnterKeyType: typing.Type[int]
    #class EnterKeyType(int): ...
    EnterKeyDefault = ... # type: int
    EnterKeyReturn = ... # type: int
    EnterKeyDone = ... # type: int
    EnterKeyGo = ... # type: int
    EnterKeySend = ... # type: int
    EnterKeySearch = ... # type: int
    EnterKeyNext = ... # type: int
    EnterKeyPrevious = ... # type: int

    ItemSelectionOperation: typing.Type[int]
    #class ItemSelectionOperation(int): ...
    ReplaceSelection = ... # type: int
    AddToSelection = ... # type: int

    TabFocusBehavior: typing.Type[int]
    #class TabFocusBehavior(int): ...
    NoTabFocus = ... # type: int
    TabFocusTextControls = ... # type: int
    TabFocusListControls = ... # type: int
    TabFocusAllControls = ... # type: int

    MouseEventFlag: typing.Type[int]
    #class MouseEventFlag(int): ...
    MouseEventCreatedDoubleClick = ... # type: int

    MouseEventSource: typing.Type[int]
    #class MouseEventSource(int): ...
    MouseEventNotSynthesized = ... # type: int
    MouseEventSynthesizedBySystem = ... # type: int
    MouseEventSynthesizedByQt = ... # type: int
    MouseEventSynthesizedByApplication = ... # type: int

    ScrollPhase: typing.Type[int]
    #class ScrollPhase(int): ...
    ScrollBegin = ... # type: int
    ScrollUpdate = ... # type: int
    ScrollEnd = ... # type: int
    NoScrollPhase = ... # type: int
    ScrollMomentum = ... # type: int

    NativeGestureType: typing.Type[int]
    #class NativeGestureType(int): ...
    BeginNativeGesture = ... # type: int
    EndNativeGesture = ... # type: int
    PanNativeGesture = ... # type: int
    ZoomNativeGesture = ... # type: int
    SmartZoomNativeGesture = ... # type: int
    RotateNativeGesture = ... # type: int
    SwipeNativeGesture = ... # type: int

    Edge: typing.Type[int]
    #class Edge(int): ...
    TopEdge = ... # type: int
    LeftEdge = ... # type: int
    RightEdge = ... # type: int
    BottomEdge = ... # type: int

    ApplicationState: typing.Type[int]
    #class ApplicationState(int): ...
    ApplicationSuspended = ... # type: int
    ApplicationHidden = ... # type: int
    ApplicationInactive = ... # type: int
    ApplicationActive = ... # type: int

    HitTestAccuracy: typing.Type[int]
    #class HitTestAccuracy(int): ...
    ExactHit = ... # type: int
    FuzzyHit = ... # type: int

    WhiteSpaceMode: typing.Type[int]
    #class WhiteSpaceMode(int): ...
    WhiteSpaceNormal = ... # type: int
    WhiteSpacePre = ... # type: int
    WhiteSpaceNoWrap = ... # type: int
    WhiteSpaceModeUndefined = ... # type: int

    FindChildOption: typing.Type[int]
    #class FindChildOption(int): ...
    FindDirectChildrenOnly = ... # type: int
    FindChildrenRecursively = ... # type: int

    ScreenOrientation: typing.Type[int]
    #class ScreenOrientation(int): ...
    PrimaryOrientation = ... # type: int
    PortraitOrientation = ... # type: int
    LandscapeOrientation = ... # type: int
    InvertedPortraitOrientation = ... # type: int
    InvertedLandscapeOrientation = ... # type: int

    CursorMoveStyle: typing.Type[int]
    #class CursorMoveStyle(int): ...
    LogicalMoveStyle = ... # type: int
    VisualMoveStyle = ... # type: int

    NavigationMode: typing.Type[int]
    #class NavigationMode(int): ...
    NavigationModeNone = ... # type: int
    NavigationModeKeypadTabOrder = ... # type: int
    NavigationModeKeypadDirectional = ... # type: int
    NavigationModeCursorAuto = ... # type: int
    NavigationModeCursorForceVisible = ... # type: int

    GestureFlag: typing.Type[int]
    #class GestureFlag(int): ...
    DontStartGestureOnChildren = ... # type: int
    ReceivePartialGestures = ... # type: int
    IgnoredGesturesPropagateToParent = ... # type: int

    GestureType: typing.Type[int]
    #class GestureType(int): ...
    TapGesture = ... # type: int
    TapAndHoldGesture = ... # type: int
    PanGesture = ... # type: int
    PinchGesture = ... # type: int
    SwipeGesture = ... # type: int
    CustomGesture = ... # type: int

    GestureState: typing.Type[int]
    #class GestureState(int): ...
    GestureStarted = ... # type: int
    GestureUpdated = ... # type: int
    GestureFinished = ... # type: int
    GestureCanceled = ... # type: int

    TouchPointState: typing.Type[int]
    #class TouchPointState(int): ...
    TouchPointPressed = ... # type: int
    TouchPointMoved = ... # type: int
    TouchPointStationary = ... # type: int
    TouchPointReleased = ... # type: int

    CoordinateSystem: typing.Type[int]
    #class CoordinateSystem(int): ...
    DeviceCoordinates = ... # type: int
    LogicalCoordinates = ... # type: int

    AnchorPoint: typing.Type[int]
    #class AnchorPoint(int): ...
    AnchorLeft = ... # type: int
    AnchorHorizontalCenter = ... # type: int
    AnchorRight = ... # type: int
    AnchorTop = ... # type: int
    AnchorVerticalCenter = ... # type: int
    AnchorBottom = ... # type: int

    InputMethodHint: typing.Type[int]
    #class InputMethodHint(int): ...
    ImhNone = ... # type: int
    ImhHiddenText = ... # type: int
    ImhNoAutoUppercase = ... # type: int
    ImhPreferNumbers = ... # type: int
    ImhPreferUppercase = ... # type: int
    ImhPreferLowercase = ... # type: int
    ImhNoPredictiveText = ... # type: int
    ImhDigitsOnly = ... # type: int
    ImhFormattedNumbersOnly = ... # type: int
    ImhUppercaseOnly = ... # type: int
    ImhLowercaseOnly = ... # type: int
    ImhDialableCharactersOnly = ... # type: int
    ImhEmailCharactersOnly = ... # type: int
    ImhUrlCharactersOnly = ... # type: int
    ImhExclusiveInputMask = ... # type: int
    ImhSensitiveData = ... # type: int
    ImhDate = ... # type: int
    ImhTime = ... # type: int
    ImhPreferLatin = ... # type: int
    ImhLatinOnly = ... # type: int
    ImhMultiLine = ... # type: int
    ImhNoEditMenu = ... # type: int
    ImhNoTextHandles = ... # type: int

    TileRule: typing.Type[int]
    #class TileRule(int): ...
    StretchTile = ... # type: int
    RepeatTile = ... # type: int
    RoundTile = ... # type: int

    WindowFrameSection: typing.Type[int]
    #class WindowFrameSection(int): ...
    NoSection = ... # type: int
    LeftSection = ... # type: int
    TopLeftSection = ... # type: int
    TopSection = ... # type: int
    TopRightSection = ... # type: int
    RightSection = ... # type: int
    BottomRightSection = ... # type: int
    BottomSection = ... # type: int
    BottomLeftSection = ... # type: int
    TitleBarArea = ... # type: int

    SizeHint: typing.Type[int]
    #class SizeHint(int): ...
    MinimumSize = ... # type: int
    PreferredSize = ... # type: int
    MaximumSize = ... # type: int
    MinimumDescent = ... # type: int

    SizeMode: typing.Type[int]
    #class SizeMode(int): ...
    AbsoluteSize = ... # type: int
    RelativeSize = ... # type: int

    EventPriority: typing.Type[int]
    #class EventPriority(int): ...
    HighEventPriority = ... # type: int
    NormalEventPriority = ... # type: int
    LowEventPriority = ... # type: int

    Axis: typing.Type[int]
    #class Axis(int): ...
    XAxis = ... # type: int
    YAxis = ... # type: int
    ZAxis = ... # type: int

    MaskMode: typing.Type[int]
    #class MaskMode(int): ...
    MaskInColor = ... # type: int
    MaskOutColor = ... # type: int

    TextInteractionFlag: typing.Type[int]
    #class TextInteractionFlag(int): ...
    NoTextInteraction = ... # type: int
    TextSelectableByMouse = ... # type: int
    TextSelectableByKeyboard = ... # type: int
    LinksAccessibleByMouse = ... # type: int
    LinksAccessibleByKeyboard = ... # type: int
    TextEditable = ... # type: int
    TextEditorInteraction = ... # type: int
    TextBrowserInteraction = ... # type: int

    ItemSelectionMode: typing.Type[int]
    #class ItemSelectionMode(int): ...
    ContainsItemShape = ... # type: int
    IntersectsItemShape = ... # type: int
    ContainsItemBoundingRect = ... # type: int
    IntersectsItemBoundingRect = ... # type: int

    ApplicationAttribute: typing.Type[int]
    #class ApplicationAttribute(int): ...
    AA_ImmediateWidgetCreation = ... # type: int
    AA_MSWindowsUseDirect3DByDefault = ... # type: int
    AA_DontShowIconsInMenus = ... # type: int
    AA_NativeWindows = ... # type: int
    AA_DontCreateNativeWidgetSiblings = ... # type: int
    AA_MacPluginApplication = ... # type: int
    AA_DontUseNativeMenuBar = ... # type: int
    AA_MacDontSwapCtrlAndMeta = ... # type: int
    AA_X11InitThreads = ... # type: int
    AA_Use96Dpi = ... # type: int
    AA_SynthesizeTouchForUnhandledMouseEvents = ... # type: int
    AA_SynthesizeMouseForUnhandledTouchEvents = ... # type: int
    AA_UseHighDpiPixmaps = ... # type: int
    AA_ForceRasterWidgets = ... # type: int
    AA_UseDesktopOpenGL = ... # type: int
    AA_UseOpenGLES = ... # type: int
    AA_UseSoftwareOpenGL = ... # type: int
    AA_ShareOpenGLContexts = ... # type: int
    AA_SetPalette = ... # type: int
    AA_EnableHighDpiScaling = ... # type: int
    AA_DisableHighDpiScaling = ... # type: int
    AA_PluginApplication = ... # type: int
    AA_UseStyleSheetPropagationInWidgetStyles = ... # type: int
    AA_DontUseNativeDialogs = ... # type: int
    AA_SynthesizeMouseForUnhandledTabletEvents = ... # type: int
    AA_CompressHighFrequencyEvents = ... # type: int
    AA_DontCheckOpenGLContextThreadAffinity = ... # type: int
    AA_DisableShaderDiskCache = ... # type: int
    AA_DontShowShortcutsInContextMenus = ... # type: int
    AA_CompressTabletEvents = ... # type: int
    AA_DisableWindowContextHelpButton = ... # type: int

    WindowModality: typing.Type[int]
    #class WindowModality(int): ...
    NonModal = ... # type: int
    WindowModal = ... # type: int
    ApplicationModal = ... # type: int

    MatchFlag: typing.Type[int]
    #class MatchFlag(int): ...
    MatchExactly = ... # type: int
    MatchFixedString = ... # type: int
    MatchContains = ... # type: int
    MatchStartsWith = ... # type: int
    MatchEndsWith = ... # type: int
    MatchRegExp = ... # type: int
    MatchWildcard = ... # type: int
    MatchCaseSensitive = ... # type: int
    MatchWrap = ... # type: int
    MatchRecursive = ... # type: int

    ItemFlag: typing.Type[int]
    #class ItemFlag(int): ...
    NoItemFlags = ... # type: int
    ItemIsSelectable = ... # type: int
    ItemIsEditable = ... # type: int
    ItemIsDragEnabled = ... # type: int
    ItemIsDropEnabled = ... # type: int
    ItemIsUserCheckable = ... # type: int
    ItemIsEnabled = ... # type: int
    ItemIsTristate = ... # type: int
    ItemNeverHasChildren = ... # type: int
    ItemIsUserTristate = ... # type: int
    ItemIsAutoTristate = ... # type: int

    ItemDataRole: typing.Type[int]
    #class ItemDataRole(int): ...
    DisplayRole = ... # type: int
    DecorationRole = ... # type: int
    EditRole = ... # type: int
    ToolTipRole = ... # type: int
    StatusTipRole = ... # type: int
    WhatsThisRole = ... # type: int
    FontRole = ... # type: int
    TextAlignmentRole = ... # type: int
    BackgroundRole = ... # type: int
    BackgroundColorRole = ... # type: int
    ForegroundRole = ... # type: int
    TextColorRole = ... # type: int
    CheckStateRole = ... # type: int
    AccessibleTextRole = ... # type: int
    AccessibleDescriptionRole = ... # type: int
    SizeHintRole = ... # type: int
    InitialSortOrderRole = ... # type: int
    UserRole = ... # type: int

    CheckState: typing.Type[int]
    #class CheckState(int): ...
    Unchecked = ... # type: int
    PartiallyChecked = ... # type: int
    Checked = ... # type: int

    DropAction: typing.Type[int]
    #class DropAction(int): ...
    CopyAction = ... # type: int
    MoveAction = ... # type: int
    LinkAction = ... # type: int
    ActionMask = ... # type: int
    TargetMoveAction = ... # type: int
    IgnoreAction = ... # type: int

    LayoutDirection: typing.Type[int]
    #class LayoutDirection(int): ...
    LeftToRight = ... # type: int
    RightToLeft = ... # type: int
    LayoutDirectionAuto = ... # type: int

    ToolButtonStyle: typing.Type[int]
    #class ToolButtonStyle(int): ...
    ToolButtonIconOnly = ... # type: int
    ToolButtonTextOnly = ... # type: int
    ToolButtonTextBesideIcon = ... # type: int
    ToolButtonTextUnderIcon = ... # type: int
    ToolButtonFollowStyle = ... # type: int

    InputMethodQuery: typing.Type[int]
    #class InputMethodQuery(int): ...
    ImMicroFocus = ... # type: int
    ImFont = ... # type: int
    ImCursorPosition = ... # type: int
    ImSurroundingText = ... # type: int
    ImCurrentSelection = ... # type: int
    ImMaximumTextLength = ... # type: int
    ImAnchorPosition = ... # type: int
    ImEnabled = ... # type: int
    ImCursorRectangle = ... # type: int
    ImHints = ... # type: int
    ImPreferredLanguage = ... # type: int
    ImPlatformData = ... # type: int
    ImQueryInput = ... # type: int
    ImQueryAll = ... # type: int
    ImAbsolutePosition = ... # type: int
    ImTextBeforeCursor = ... # type: int
    ImTextAfterCursor = ... # type: int
    ImEnterKeyType = ... # type: int
    ImAnchorRectangle = ... # type: int
    ImInputItemClipRectangle = ... # type: int

    ContextMenuPolicy: typing.Type[int]
    #class ContextMenuPolicy(int): ...
    NoContextMenu = ... # type: int
    PreventContextMenu = ... # type: int
    DefaultContextMenu = ... # type: int
    ActionsContextMenu = ... # type: int
    CustomContextMenu = ... # type: int

    FocusReason: typing.Type[int]
    #class FocusReason(int): ...
    MouseFocusReason = ... # type: int
    TabFocusReason = ... # type: int
    BacktabFocusReason = ... # type: int
    ActiveWindowFocusReason = ... # type: int
    PopupFocusReason = ... # type: int
    ShortcutFocusReason = ... # type: int
    MenuBarFocusReason = ... # type: int
    OtherFocusReason = ... # type: int
    NoFocusReason = ... # type: int

    TransformationMode: typing.Type[int]
    #class TransformationMode(int): ...
    FastTransformation = ... # type: int
    SmoothTransformation = ... # type: int

    ClipOperation: typing.Type[int]
    #class ClipOperation(int): ...
    NoClip = ... # type: int
    ReplaceClip = ... # type: int
    IntersectClip = ... # type: int

    FillRule: typing.Type[int]
    #class FillRule(int): ...
    OddEvenFill = ... # type: int
    WindingFill = ... # type: int

    ShortcutContext: typing.Type[int]
    #class ShortcutContext(int): ...
    WidgetShortcut = ... # type: int
    WindowShortcut = ... # type: int
    ApplicationShortcut = ... # type: int
    WidgetWithChildrenShortcut = ... # type: int

    ConnectionType: typing.Type[int]
    #class ConnectionType(int): ...
    AutoConnection = ... # type: int
    DirectConnection = ... # type: int
    QueuedConnection = ... # type: int
    BlockingQueuedConnection = ... # type: int
    UniqueConnection = ... # type: int

    Corner: typing.Type[int]
    #class Corner(int): ...
    TopLeftCorner = ... # type: int
    TopRightCorner = ... # type: int
    BottomLeftCorner = ... # type: int
    BottomRightCorner = ... # type: int

    CaseSensitivity: typing.Type[int]
    #class CaseSensitivity(int): ...
    CaseInsensitive = ... # type: int
    CaseSensitive = ... # type: int

    ScrollBarPolicy: typing.Type[int]
    #class ScrollBarPolicy(int): ...
    ScrollBarAsNeeded = ... # type: int
    ScrollBarAlwaysOff = ... # type: int
    ScrollBarAlwaysOn = ... # type: int

    DayOfWeek: typing.Type[int]
    #class DayOfWeek(int): ...
    Monday = ... # type: int
    Tuesday = ... # type: int
    Wednesday = ... # type: int
    Thursday = ... # type: int
    Friday = ... # type: int
    Saturday = ... # type: int
    Sunday = ... # type: int

    TimeSpec: typing.Type[int]
    #class TimeSpec(int): ...
    LocalTime = ... # type: int
    UTC = ... # type: int
    OffsetFromUTC = ... # type: int
    TimeZone = ... # type: int

    DateFormat: typing.Type[int]
    #class DateFormat(int): ...
    TextDate = ... # type: int
    ISODate = ... # type: int
    ISODateWithMs = ... # type: int
    LocalDate = ... # type: int
    SystemLocaleDate = ... # type: int
    LocaleDate = ... # type: int
    SystemLocaleShortDate = ... # type: int
    SystemLocaleLongDate = ... # type: int
    DefaultLocaleShortDate = ... # type: int
    DefaultLocaleLongDate = ... # type: int
    RFC2822Date = ... # type: int

    ToolBarArea: typing.Type[int]
    #class ToolBarArea(int): ...
    LeftToolBarArea = ... # type: int
    RightToolBarArea = ... # type: int
    TopToolBarArea = ... # type: int
    BottomToolBarArea = ... # type: int
    ToolBarArea_Mask = ... # type: int
    AllToolBarAreas = ... # type: int
    NoToolBarArea = ... # type: int

    TimerType: typing.Type[int]
    #class TimerType(int): ...
    PreciseTimer = ... # type: int
    CoarseTimer = ... # type: int
    VeryCoarseTimer = ... # type: int

    DockWidgetArea: typing.Type[int]
    #class DockWidgetArea(int): ...
    LeftDockWidgetArea = ... # type: int
    RightDockWidgetArea = ... # type: int
    TopDockWidgetArea = ... # type: int
    BottomDockWidgetArea = ... # type: int
    DockWidgetArea_Mask = ... # type: int
    AllDockWidgetAreas = ... # type: int
    NoDockWidgetArea = ... # type: int

    AspectRatioMode: typing.Type[int]
    #class AspectRatioMode(int): ...
    IgnoreAspectRatio = ... # type: int
    KeepAspectRatio = ... # type: int
    KeepAspectRatioByExpanding = ... # type: int

    TextFormat: typing.Type[int]
    #class TextFormat(int): ...
    PlainText = ... # type: int
    RichText = ... # type: int
    AutoText = ... # type: int

    CursorShape: typing.Type[int]
    #class CursorShape(int): ...
    ArrowCursor = ... # type: int
    UpArrowCursor = ... # type: int
    CrossCursor = ... # type: int
    WaitCursor = ... # type: int
    IBeamCursor = ... # type: int
    SizeVerCursor = ... # type: int
    SizeHorCursor = ... # type: int
    SizeBDiagCursor = ... # type: int
    SizeFDiagCursor = ... # type: int
    SizeAllCursor = ... # type: int
    BlankCursor = ... # type: int
    SplitVCursor = ... # type: int
    SplitHCursor = ... # type: int
    PointingHandCursor = ... # type: int
    ForbiddenCursor = ... # type: int
    OpenHandCursor = ... # type: int
    ClosedHandCursor = ... # type: int
    WhatsThisCursor = ... # type: int
    BusyCursor = ... # type: int
    LastCursor = ... # type: int
    BitmapCursor = ... # type: int
    CustomCursor = ... # type: int
    DragCopyCursor = ... # type: int
    DragMoveCursor = ... # type: int
    DragLinkCursor = ... # type: int

    UIEffect: typing.Type[int]
    #class UIEffect(int): ...
    UI_General = ... # type: int
    UI_AnimateMenu = ... # type: int
    UI_FadeMenu = ... # type: int
    UI_AnimateCombo = ... # type: int
    UI_AnimateTooltip = ... # type: int
    UI_FadeTooltip = ... # type: int
    UI_AnimateToolBox = ... # type: int

    BrushStyle: typing.Type[int]
    #class BrushStyle(int): ...
    NoBrush = ... # type: int
    SolidPattern = ... # type: int
    Dense1Pattern = ... # type: int
    Dense2Pattern = ... # type: int
    Dense3Pattern = ... # type: int
    Dense4Pattern = ... # type: int
    Dense5Pattern = ... # type: int
    Dense6Pattern = ... # type: int
    Dense7Pattern = ... # type: int
    HorPattern = ... # type: int
    VerPattern = ... # type: int
    CrossPattern = ... # type: int
    BDiagPattern = ... # type: int
    FDiagPattern = ... # type: int
    DiagCrossPattern = ... # type: int
    LinearGradientPattern = ... # type: int
    RadialGradientPattern = ... # type: int
    ConicalGradientPattern = ... # type: int
    TexturePattern = ... # type: int

    PenJoinStyle: typing.Type[int]
    #class PenJoinStyle(int): ...
    MiterJoin = ... # type: int
    BevelJoin = ... # type: int
    RoundJoin = ... # type: int
    MPenJoinStyle = ... # type: int
    SvgMiterJoin = ... # type: int

    PenCapStyle: typing.Type[int]
    #class PenCapStyle(int): ...
    FlatCap = ... # type: int
    SquareCap = ... # type: int
    RoundCap = ... # type: int
    MPenCapStyle = ... # type: int

    PenStyle: typing.Type[int]
    #class PenStyle(int): ...
    NoPen = ... # type: int
    SolidLine = ... # type: int
    DashLine = ... # type: int
    DotLine = ... # type: int
    DashDotLine = ... # type: int
    DashDotDotLine = ... # type: int
    CustomDashLine = ... # type: int
    MPenStyle = ... # type: int

    ArrowType: typing.Type[int]
    #class ArrowType(int): ...
    NoArrow = ... # type: int
    UpArrow = ... # type: int
    DownArrow = ... # type: int
    LeftArrow = ... # type: int
    RightArrow = ... # type: int

    Key: typing.Type[int]
    #class Key(int): ...
    Key_Escape = ... # type: int
    Key_Tab = ... # type: int
    Key_Backtab = ... # type: int
    Key_Backspace = ... # type: int
    Key_Return = ... # type: int
    Key_Enter = ... # type: int
    Key_Insert = ... # type: int
    Key_Delete = ... # type: int
    Key_Pause = ... # type: int
    Key_Print = ... # type: int
    Key_SysReq = ... # type: int
    Key_Clear = ... # type: int
    Key_Home = ... # type: int
    Key_End = ... # type: int
    Key_Left = ... # type: int
    Key_Up = ... # type: int
    Key_Right = ... # type: int
    Key_Down = ... # type: int
    Key_PageUp = ... # type: int
    Key_PageDown = ... # type: int
    Key_Shift = ... # type: int
    Key_Control = ... # type: int
    Key_Meta = ... # type: int
    Key_Alt = ... # type: int
    Key_CapsLock = ... # type: int
    Key_NumLock = ... # type: int
    Key_ScrollLock = ... # type: int
    Key_F1 = ... # type: int
    Key_F2 = ... # type: int
    Key_F3 = ... # type: int
    Key_F4 = ... # type: int
    Key_F5 = ... # type: int
    Key_F6 = ... # type: int
    Key_F7 = ... # type: int
    Key_F8 = ... # type: int
    Key_F9 = ... # type: int
    Key_F10 = ... # type: int
    Key_F11 = ... # type: int
    Key_F12 = ... # type: int
    Key_F13 = ... # type: int
    Key_F14 = ... # type: int
    Key_F15 = ... # type: int
    Key_F16 = ... # type: int
    Key_F17 = ... # type: int
    Key_F18 = ... # type: int
    Key_F19 = ... # type: int
    Key_F20 = ... # type: int
    Key_F21 = ... # type: int
    Key_F22 = ... # type: int
    Key_F23 = ... # type: int
    Key_F24 = ... # type: int
    Key_F25 = ... # type: int
    Key_F26 = ... # type: int
    Key_F27 = ... # type: int
    Key_F28 = ... # type: int
    Key_F29 = ... # type: int
    Key_F30 = ... # type: int
    Key_F31 = ... # type: int
    Key_F32 = ... # type: int
    Key_F33 = ... # type: int
    Key_F34 = ... # type: int
    Key_F35 = ... # type: int
    Key_Super_L = ... # type: int
    Key_Super_R = ... # type: int
    Key_Menu = ... # type: int
    Key_Hyper_L = ... # type: int
    Key_Hyper_R = ... # type: int
    Key_Help = ... # type: int
    Key_Direction_L = ... # type: int
    Key_Direction_R = ... # type: int
    Key_Space = ... # type: int
    Key_Any = ... # type: int
    Key_Exclam = ... # type: int
    Key_QuoteDbl = ... # type: int
    Key_NumberSign = ... # type: int
    Key_Dollar = ... # type: int
    Key_Percent = ... # type: int
    Key_Ampersand = ... # type: int
    Key_Apostrophe = ... # type: int
    Key_ParenLeft = ... # type: int
    Key_ParenRight = ... # type: int
    Key_Asterisk = ... # type: int
    Key_Plus = ... # type: int
    Key_Comma = ... # type: int
    Key_Minus = ... # type: int
    Key_Period = ... # type: int
    Key_Slash = ... # type: int
    Key_0 = ... # type: int
    Key_1 = ... # type: int
    Key_2 = ... # type: int
    Key_3 = ... # type: int
    Key_4 = ... # type: int
    Key_5 = ... # type: int
    Key_6 = ... # type: int
    Key_7 = ... # type: int
    Key_8 = ... # type: int
    Key_9 = ... # type: int
    Key_Colon = ... # type: int
    Key_Semicolon = ... # type: int
    Key_Less = ... # type: int
    Key_Equal = ... # type: int
    Key_Greater = ... # type: int
    Key_Question = ... # type: int
    Key_At = ... # type: int
    Key_A = ... # type: int
    Key_B = ... # type: int
    Key_C = ... # type: int
    Key_D = ... # type: int
    Key_E = ... # type: int
    Key_F = ... # type: int
    Key_G = ... # type: int
    Key_H = ... # type: int
    Key_I = ... # type: int
    Key_J = ... # type: int
    Key_K = ... # type: int
    Key_L = ... # type: int
    Key_M = ... # type: int
    Key_N = ... # type: int
    Key_O = ... # type: int
    Key_P = ... # type: int
    Key_Q = ... # type: int
    Key_R = ... # type: int
    Key_S = ... # type: int
    Key_T = ... # type: int
    Key_U = ... # type: int
    Key_V = ... # type: int
    Key_W = ... # type: int
    Key_X = ... # type: int
    Key_Y = ... # type: int
    Key_Z = ... # type: int
    Key_BracketLeft = ... # type: int
    Key_Backslash = ... # type: int
    Key_BracketRight = ... # type: int
    Key_AsciiCircum = ... # type: int
    Key_Underscore = ... # type: int
    Key_QuoteLeft = ... # type: int
    Key_BraceLeft = ... # type: int
    Key_Bar = ... # type: int
    Key_BraceRight = ... # type: int
    Key_AsciiTilde = ... # type: int
    Key_nobreakspace = ... # type: int
    Key_exclamdown = ... # type: int
    Key_cent = ... # type: int
    Key_sterling = ... # type: int
    Key_currency = ... # type: int
    Key_yen = ... # type: int
    Key_brokenbar = ... # type: int
    Key_section = ... # type: int
    Key_diaeresis = ... # type: int
    Key_copyright = ... # type: int
    Key_ordfeminine = ... # type: int
    Key_guillemotleft = ... # type: int
    Key_notsign = ... # type: int
    Key_hyphen = ... # type: int
    Key_registered = ... # type: int
    Key_macron = ... # type: int
    Key_degree = ... # type: int
    Key_plusminus = ... # type: int
    Key_twosuperior = ... # type: int
    Key_threesuperior = ... # type: int
    Key_acute = ... # type: int
    Key_mu = ... # type: int
    Key_paragraph = ... # type: int
    Key_periodcentered = ... # type: int
    Key_cedilla = ... # type: int
    Key_onesuperior = ... # type: int
    Key_masculine = ... # type: int
    Key_guillemotright = ... # type: int
    Key_onequarter = ... # type: int
    Key_onehalf = ... # type: int
    Key_threequarters = ... # type: int
    Key_questiondown = ... # type: int
    Key_Agrave = ... # type: int
    Key_Aacute = ... # type: int
    Key_Acircumflex = ... # type: int
    Key_Atilde = ... # type: int
    Key_Adiaeresis = ... # type: int
    Key_Aring = ... # type: int
    Key_AE = ... # type: int
    Key_Ccedilla = ... # type: int
    Key_Egrave = ... # type: int
    Key_Eacute = ... # type: int
    Key_Ecircumflex = ... # type: int
    Key_Ediaeresis = ... # type: int
    Key_Igrave = ... # type: int
    Key_Iacute = ... # type: int
    Key_Icircumflex = ... # type: int
    Key_Idiaeresis = ... # type: int
    Key_ETH = ... # type: int
    Key_Ntilde = ... # type: int
    Key_Ograve = ... # type: int
    Key_Oacute = ... # type: int
    Key_Ocircumflex = ... # type: int
    Key_Otilde = ... # type: int
    Key_Odiaeresis = ... # type: int
    Key_multiply = ... # type: int
    Key_Ooblique = ... # type: int
    Key_Ugrave = ... # type: int
    Key_Uacute = ... # type: int
    Key_Ucircumflex = ... # type: int
    Key_Udiaeresis = ... # type: int
    Key_Yacute = ... # type: int
    Key_THORN = ... # type: int
    Key_ssharp = ... # type: int
    Key_division = ... # type: int
    Key_ydiaeresis = ... # type: int
    Key_AltGr = ... # type: int
    Key_Multi_key = ... # type: int
    Key_Codeinput = ... # type: int
    Key_SingleCandidate = ... # type: int
    Key_MultipleCandidate = ... # type: int
    Key_PreviousCandidate = ... # type: int
    Key_Mode_switch = ... # type: int
    Key_Kanji = ... # type: int
    Key_Muhenkan = ... # type: int
    Key_Henkan = ... # type: int
    Key_Romaji = ... # type: int
    Key_Hiragana = ... # type: int
    Key_Katakana = ... # type: int
    Key_Hiragana_Katakana = ... # type: int
    Key_Zenkaku = ... # type: int
    Key_Hankaku = ... # type: int
    Key_Zenkaku_Hankaku = ... # type: int
    Key_Touroku = ... # type: int
    Key_Massyo = ... # type: int
    Key_Kana_Lock = ... # type: int
    Key_Kana_Shift = ... # type: int
    Key_Eisu_Shift = ... # type: int
    Key_Eisu_toggle = ... # type: int
    Key_Hangul = ... # type: int
    Key_Hangul_Start = ... # type: int
    Key_Hangul_End = ... # type: int
    Key_Hangul_Hanja = ... # type: int
    Key_Hangul_Jamo = ... # type: int
    Key_Hangul_Romaja = ... # type: int
    Key_Hangul_Jeonja = ... # type: int
    Key_Hangul_Banja = ... # type: int
    Key_Hangul_PreHanja = ... # type: int
    Key_Hangul_PostHanja = ... # type: int
    Key_Hangul_Special = ... # type: int
    Key_Dead_Grave = ... # type: int
    Key_Dead_Acute = ... # type: int
    Key_Dead_Circumflex = ... # type: int
    Key_Dead_Tilde = ... # type: int
    Key_Dead_Macron = ... # type: int
    Key_Dead_Breve = ... # type: int
    Key_Dead_Abovedot = ... # type: int
    Key_Dead_Diaeresis = ... # type: int
    Key_Dead_Abovering = ... # type: int
    Key_Dead_Doubleacute = ... # type: int
    Key_Dead_Caron = ... # type: int
    Key_Dead_Cedilla = ... # type: int
    Key_Dead_Ogonek = ... # type: int
    Key_Dead_Iota = ... # type: int
    Key_Dead_Voiced_Sound = ... # type: int
    Key_Dead_Semivoiced_Sound = ... # type: int
    Key_Dead_Belowdot = ... # type: int
    Key_Dead_Hook = ... # type: int
    Key_Dead_Horn = ... # type: int
    Key_Back = ... # type: int
    Key_Forward = ... # type: int
    Key_Stop = ... # type: int
    Key_Refresh = ... # type: int
    Key_VolumeDown = ... # type: int
    Key_VolumeMute = ... # type: int
    Key_VolumeUp = ... # type: int
    Key_BassBoost = ... # type: int
    Key_BassUp = ... # type: int
    Key_BassDown = ... # type: int
    Key_TrebleUp = ... # type: int
    Key_TrebleDown = ... # type: int
    Key_MediaPlay = ... # type: int
    Key_MediaStop = ... # type: int
    Key_MediaPrevious = ... # type: int
    Key_MediaNext = ... # type: int
    Key_MediaRecord = ... # type: int
    Key_HomePage = ... # type: int
    Key_Favorites = ... # type: int
    Key_Search = ... # type: int
    Key_Standby = ... # type: int
    Key_OpenUrl = ... # type: int
    Key_LaunchMail = ... # type: int
    Key_LaunchMedia = ... # type: int
    Key_Launch0 = ... # type: int
    Key_Launch1 = ... # type: int
    Key_Launch2 = ... # type: int
    Key_Launch3 = ... # type: int
    Key_Launch4 = ... # type: int
    Key_Launch5 = ... # type: int
    Key_Launch6 = ... # type: int
    Key_Launch7 = ... # type: int
    Key_Launch8 = ... # type: int
    Key_Launch9 = ... # type: int
    Key_LaunchA = ... # type: int
    Key_LaunchB = ... # type: int
    Key_LaunchC = ... # type: int
    Key_LaunchD = ... # type: int
    Key_LaunchE = ... # type: int
    Key_LaunchF = ... # type: int
    Key_MediaLast = ... # type: int
    Key_Select = ... # type: int
    Key_Yes = ... # type: int
    Key_No = ... # type: int
    Key_Context1 = ... # type: int
    Key_Context2 = ... # type: int
    Key_Context3 = ... # type: int
    Key_Context4 = ... # type: int
    Key_Call = ... # type: int
    Key_Hangup = ... # type: int
    Key_Flip = ... # type: int
    Key_unknown = ... # type: int
    Key_Execute = ... # type: int
    Key_Printer = ... # type: int
    Key_Play = ... # type: int
    Key_Sleep = ... # type: int
    Key_Zoom = ... # type: int
    Key_Cancel = ... # type: int
    Key_MonBrightnessUp = ... # type: int
    Key_MonBrightnessDown = ... # type: int
    Key_KeyboardLightOnOff = ... # type: int
    Key_KeyboardBrightnessUp = ... # type: int
    Key_KeyboardBrightnessDown = ... # type: int
    Key_PowerOff = ... # type: int
    Key_WakeUp = ... # type: int
    Key_Eject = ... # type: int
    Key_ScreenSaver = ... # type: int
    Key_WWW = ... # type: int
    Key_Memo = ... # type: int
    Key_LightBulb = ... # type: int
    Key_Shop = ... # type: int
    Key_History = ... # type: int
    Key_AddFavorite = ... # type: int
    Key_HotLinks = ... # type: int
    Key_BrightnessAdjust = ... # type: int
    Key_Finance = ... # type: int
    Key_Community = ... # type: int
    Key_AudioRewind = ... # type: int
    Key_BackForward = ... # type: int
    Key_ApplicationLeft = ... # type: int
    Key_ApplicationRight = ... # type: int
    Key_Book = ... # type: int
    Key_CD = ... # type: int
    Key_Calculator = ... # type: int
    Key_ToDoList = ... # type: int
    Key_ClearGrab = ... # type: int
    Key_Close = ... # type: int
    Key_Copy = ... # type: int
    Key_Cut = ... # type: int
    Key_Display = ... # type: int
    Key_DOS = ... # type: int
    Key_Documents = ... # type: int
    Key_Excel = ... # type: int
    Key_Explorer = ... # type: int
    Key_Game = ... # type: int
    Key_Go = ... # type: int
    Key_iTouch = ... # type: int
    Key_LogOff = ... # type: int
    Key_Market = ... # type: int
    Key_Meeting = ... # type: int
    Key_MenuKB = ... # type: int
    Key_MenuPB = ... # type: int
    Key_MySites = ... # type: int
    Key_News = ... # type: int
    Key_OfficeHome = ... # type: int
    Key_Option = ... # type: int
    Key_Paste = ... # type: int
    Key_Phone = ... # type: int
    Key_Calendar = ... # type: int
    Key_Reply = ... # type: int
    Key_Reload = ... # type: int
    Key_RotateWindows = ... # type: int
    Key_RotationPB = ... # type: int
    Key_RotationKB = ... # type: int
    Key_Save = ... # type: int
    Key_Send = ... # type: int
    Key_Spell = ... # type: int
    Key_SplitScreen = ... # type: int
    Key_Support = ... # type: int
    Key_TaskPane = ... # type: int
    Key_Terminal = ... # type: int
    Key_Tools = ... # type: int
    Key_Travel = ... # type: int
    Key_Video = ... # type: int
    Key_Word = ... # type: int
    Key_Xfer = ... # type: int
    Key_ZoomIn = ... # type: int
    Key_ZoomOut = ... # type: int
    Key_Away = ... # type: int
    Key_Messenger = ... # type: int
    Key_WebCam = ... # type: int
    Key_MailForward = ... # type: int
    Key_Pictures = ... # type: int
    Key_Music = ... # type: int
    Key_Battery = ... # type: int
    Key_Bluetooth = ... # type: int
    Key_WLAN = ... # type: int
    Key_UWB = ... # type: int
    Key_AudioForward = ... # type: int
    Key_AudioRepeat = ... # type: int
    Key_AudioRandomPlay = ... # type: int
    Key_Subtitle = ... # type: int
    Key_AudioCycleTrack = ... # type: int
    Key_Time = ... # type: int
    Key_Hibernate = ... # type: int
    Key_View = ... # type: int
    Key_TopMenu = ... # type: int
    Key_PowerDown = ... # type: int
    Key_Suspend = ... # type: int
    Key_ContrastAdjust = ... # type: int
    Key_MediaPause = ... # type: int
    Key_MediaTogglePlayPause = ... # type: int
    Key_LaunchG = ... # type: int
    Key_LaunchH = ... # type: int
    Key_ToggleCallHangup = ... # type: int
    Key_VoiceDial = ... # type: int
    Key_LastNumberRedial = ... # type: int
    Key_Camera = ... # type: int
    Key_CameraFocus = ... # type: int
    Key_TouchpadToggle = ... # type: int
    Key_TouchpadOn = ... # type: int
    Key_TouchpadOff = ... # type: int
    Key_MicMute = ... # type: int
    Key_Red = ... # type: int
    Key_Green = ... # type: int
    Key_Yellow = ... # type: int
    Key_Blue = ... # type: int
    Key_ChannelUp = ... # type: int
    Key_ChannelDown = ... # type: int
    Key_Guide = ... # type: int
    Key_Info = ... # type: int
    Key_Settings = ... # type: int
    Key_Exit = ... # type: int
    Key_MicVolumeUp = ... # type: int
    Key_MicVolumeDown = ... # type: int
    Key_New = ... # type: int
    Key_Open = ... # type: int
    Key_Find = ... # type: int
    Key_Undo = ... # type: int
    Key_Redo = ... # type: int
    Key_Dead_Stroke = ... # type: int
    Key_Dead_Abovecomma = ... # type: int
    Key_Dead_Abovereversedcomma = ... # type: int
    Key_Dead_Doublegrave = ... # type: int
    Key_Dead_Belowring = ... # type: int
    Key_Dead_Belowmacron = ... # type: int
    Key_Dead_Belowcircumflex = ... # type: int
    Key_Dead_Belowtilde = ... # type: int
    Key_Dead_Belowbreve = ... # type: int
    Key_Dead_Belowdiaeresis = ... # type: int
    Key_Dead_Invertedbreve = ... # type: int
    Key_Dead_Belowcomma = ... # type: int
    Key_Dead_Currency = ... # type: int
    Key_Dead_a = ... # type: int
    Key_Dead_A = ... # type: int
    Key_Dead_e = ... # type: int
    Key_Dead_E = ... # type: int
    Key_Dead_i = ... # type: int
    Key_Dead_I = ... # type: int
    Key_Dead_o = ... # type: int
    Key_Dead_O = ... # type: int
    Key_Dead_u = ... # type: int
    Key_Dead_U = ... # type: int
    Key_Dead_Small_Schwa = ... # type: int
    Key_Dead_Capital_Schwa = ... # type: int
    Key_Dead_Greek = ... # type: int
    Key_Dead_Lowline = ... # type: int
    Key_Dead_Aboveverticalline = ... # type: int
    Key_Dead_Belowverticalline = ... # type: int
    Key_Dead_Longsolidusoverlay = ... # type: int

    BGMode: typing.Type[int]
    #class BGMode(int): ...
    TransparentMode = ... # type: int
    OpaqueMode = ... # type: int

    ImageConversionFlag: typing.Type[int]
    #class ImageConversionFlag(int): ...
    AutoColor = ... # type: int
    ColorOnly = ... # type: int
    MonoOnly = ... # type: int
    ThresholdAlphaDither = ... # type: int
    OrderedAlphaDither = ... # type: int
    DiffuseAlphaDither = ... # type: int
    DiffuseDither = ... # type: int
    OrderedDither = ... # type: int
    ThresholdDither = ... # type: int
    AutoDither = ... # type: int
    PreferDither = ... # type: int
    AvoidDither = ... # type: int
    NoOpaqueDetection = ... # type: int
    NoFormatConversion = ... # type: int

    WidgetAttribute: typing.Type[int]
    #class WidgetAttribute(int): ...
    WA_Disabled = ... # type: int
    WA_UnderMouse = ... # type: int
    WA_MouseTracking = ... # type: int
    WA_OpaquePaintEvent = ... # type: int
    WA_StaticContents = ... # type: int
    WA_LaidOut = ... # type: int
    WA_PaintOnScreen = ... # type: int
    WA_NoSystemBackground = ... # type: int
    WA_UpdatesDisabled = ... # type: int
    WA_Mapped = ... # type: int
    WA_MacNoClickThrough = ... # type: int
    WA_InputMethodEnabled = ... # type: int
    WA_WState_Visible = ... # type: int
    WA_WState_Hidden = ... # type: int
    WA_ForceDisabled = ... # type: int
    WA_KeyCompression = ... # type: int
    WA_PendingMoveEvent = ... # type: int
    WA_PendingResizeEvent = ... # type: int
    WA_SetPalette = ... # type: int
    WA_SetFont = ... # type: int
    WA_SetCursor = ... # type: int
    WA_NoChildEventsFromChildren = ... # type: int
    WA_WindowModified = ... # type: int
    WA_Resized = ... # type: int
    WA_Moved = ... # type: int
    WA_PendingUpdate = ... # type: int
    WA_InvalidSize = ... # type: int
    WA_MacMetalStyle = ... # type: int
    WA_CustomWhatsThis = ... # type: int
    WA_LayoutOnEntireRect = ... # type: int
    WA_OutsideWSRange = ... # type: int
    WA_GrabbedShortcut = ... # type: int
    WA_TransparentForMouseEvents = ... # type: int
    WA_PaintUnclipped = ... # type: int
    WA_SetWindowIcon = ... # type: int
    WA_NoMouseReplay = ... # type: int
    WA_DeleteOnClose = ... # type: int
    WA_RightToLeft = ... # type: int
    WA_SetLayoutDirection = ... # type: int
    WA_NoChildEventsForParent = ... # type: int
    WA_ForceUpdatesDisabled = ... # type: int
    WA_WState_Created = ... # type: int
    WA_WState_CompressKeys = ... # type: int
    WA_WState_InPaintEvent = ... # type: int
    WA_WState_Reparented = ... # type: int
    WA_WState_ConfigPending = ... # type: int
    WA_WState_Polished = ... # type: int
    WA_WState_OwnSizePolicy = ... # type: int
    WA_WState_ExplicitShowHide = ... # type: int
    WA_MouseNoMask = ... # type: int
    WA_GroupLeader = ... # type: int
    WA_NoMousePropagation = ... # type: int
    WA_Hover = ... # type: int
    WA_InputMethodTransparent = ... # type: int
    WA_QuitOnClose = ... # type: int
    WA_KeyboardFocusChange = ... # type: int
    WA_AcceptDrops = ... # type: int
    WA_WindowPropagation = ... # type: int
    WA_NoX11EventCompression = ... # type: int
    WA_TintedBackground = ... # type: int
    WA_X11OpenGLOverlay = ... # type: int
    WA_AttributeCount = ... # type: int
    WA_AlwaysShowToolTips = ... # type: int
    WA_MacOpaqueSizeGrip = ... # type: int
    WA_SetStyle = ... # type: int
    WA_MacBrushedMetal = ... # type: int
    WA_SetLocale = ... # type: int
    WA_MacShowFocusRect = ... # type: int
    WA_MacNormalSize = ... # type: int
    WA_MacSmallSize = ... # type: int
    WA_MacMiniSize = ... # type: int
    WA_LayoutUsesWidgetRect = ... # type: int
    WA_StyledBackground = ... # type: int
    WA_MSWindowsUseDirect3D = ... # type: int
    WA_MacAlwaysShowToolWindow = ... # type: int
    WA_StyleSheet = ... # type: int
    WA_ShowWithoutActivating = ... # type: int
    WA_NativeWindow = ... # type: int
    WA_DontCreateNativeAncestors = ... # type: int
    WA_MacVariableSize = ... # type: int
    WA_DontShowOnScreen = ... # type: int
    WA_X11NetWmWindowTypeDesktop = ... # type: int
    WA_X11NetWmWindowTypeDock = ... # type: int
    WA_X11NetWmWindowTypeToolBar = ... # type: int
    WA_X11NetWmWindowTypeMenu = ... # type: int
    WA_X11NetWmWindowTypeUtility = ... # type: int
    WA_X11NetWmWindowTypeSplash = ... # type: int
    WA_X11NetWmWindowTypeDialog = ... # type: int
    WA_X11NetWmWindowTypeDropDownMenu = ... # type: int
    WA_X11NetWmWindowTypePopupMenu = ... # type: int
    WA_X11NetWmWindowTypeToolTip = ... # type: int
    WA_X11NetWmWindowTypeNotification = ... # type: int
    WA_X11NetWmWindowTypeCombo = ... # type: int
    WA_X11NetWmWindowTypeDND = ... # type: int
    WA_MacFrameworkScaled = ... # type: int
    WA_TranslucentBackground = ... # type: int
    WA_AcceptTouchEvents = ... # type: int
    WA_TouchPadAcceptSingleTouchEvents = ... # type: int
    WA_X11DoNotAcceptFocus = ... # type: int
    WA_MacNoShadow = ... # type: int
    WA_AlwaysStackOnTop = ... # type: int
    WA_TabletTracking = ... # type: int
    WA_ContentsMarginsRespectsSafeArea = ... # type: int
    WA_StyleSheetTarget = ... # type: int

    WindowState: typing.Type[int]
    #class WindowState(int): ...
    WindowNoState = ... # type: int
    WindowMinimized = ... # type: int
    WindowMaximized = ... # type: int
    WindowFullScreen = ... # type: int
    WindowActive = ... # type: int

    WindowType: typing.Type[int]
    #class WindowType(int): ...
    Widget = ... # type: int
    Window = ... # type: int
    Dialog = ... # type: int
    Sheet = ... # type: int
    Drawer = ... # type: int
    Popup = ... # type: int
    Tool = ... # type: int
    ToolTip = ... # type: int
    SplashScreen = ... # type: int
    Desktop = ... # type: int
    SubWindow = ... # type: int
    WindowType_Mask = ... # type: int
    MSWindowsFixedSizeDialogHint = ... # type: int
    MSWindowsOwnDC = ... # type: int
    X11BypassWindowManagerHint = ... # type: int
    FramelessWindowHint = ... # type: int
    CustomizeWindowHint = ... # type: int
    WindowTitleHint = ... # type: int
    WindowSystemMenuHint = ... # type: int
    WindowMinimizeButtonHint = ... # type: int
    WindowMaximizeButtonHint = ... # type: int
    WindowMinMaxButtonsHint = ... # type: int
    WindowContextHelpButtonHint = ... # type: int
    WindowShadeButtonHint = ... # type: int
    WindowStaysOnTopHint = ... # type: int
    WindowStaysOnBottomHint = ... # type: int
    WindowCloseButtonHint = ... # type: int
    MacWindowToolBarButtonHint = ... # type: int
    BypassGraphicsProxyWidget = ... # type: int
    WindowTransparentForInput = ... # type: int
    WindowOverridesSystemGestures = ... # type: int
    WindowDoesNotAcceptFocus = ... # type: int
    NoDropShadowWindowHint = ... # type: int
    WindowFullscreenButtonHint = ... # type: int
    ForeignWindow = ... # type: int
    BypassWindowManagerHint = ... # type: int
    CoverWindow = ... # type: int
    MaximizeUsingFullscreenGeometryHint = ... # type: int

    TextElideMode: typing.Type[int]
    #class TextElideMode(int): ...
    ElideLeft = ... # type: int
    ElideRight = ... # type: int
    ElideMiddle = ... # type: int
    ElideNone = ... # type: int

    TextFlag: typing.Type[int]
    #class TextFlag(int): ...
    TextSingleLine = ... # type: int
    TextDontClip = ... # type: int
    TextExpandTabs = ... # type: int
    TextShowMnemonic = ... # type: int
    TextWordWrap = ... # type: int
    TextWrapAnywhere = ... # type: int
    TextDontPrint = ... # type: int
    TextIncludeTrailingSpaces = ... # type: int
    TextHideMnemonic = ... # type: int
    TextJustificationForced = ... # type: int

    AlignmentFlag: typing.Type[int]
    #class AlignmentFlag(int): ...
    AlignLeft = ... # type: int
    AlignLeading = ... # type: int
    AlignRight = ... # type: int
    AlignTrailing = ... # type: int
    AlignHCenter = ... # type: int
    AlignJustify = ... # type: int
    AlignAbsolute = ... # type: int
    AlignHorizontal_Mask = ... # type: int
    AlignTop = ... # type: int
    AlignBottom = ... # type: int
    AlignVCenter = ... # type: int
    AlignVertical_Mask = ... # type: int
    AlignCenter = ... # type: int
    AlignBaseline = ... # type: int

    SortOrder: typing.Type[int]
    #class SortOrder(int): ...
    AscendingOrder = ... # type: int
    DescendingOrder = ... # type: int

    FocusPolicy: typing.Type[int]
    #class FocusPolicy(int): ...
    NoFocus = ... # type: int
    TabFocus = ... # type: int
    ClickFocus = ... # type: int
    StrongFocus = ... # type: int
    WheelFocus = ... # type: int

    Orientation: typing.Type[int]
    #class Orientation(int): ...
    Horizontal = ... # type: int
    Vertical = ... # type: int

    MouseButton: typing.Type[int]
    #class MouseButton(int): ...
    NoButton = ... # type: int
    AllButtons = ... # type: int
    LeftButton = ... # type: int
    RightButton = ... # type: int
    MidButton = ... # type: int
    MiddleButton = ... # type: int
    XButton1 = ... # type: int
    XButton2 = ... # type: int
    BackButton = ... # type: int
    ExtraButton1 = ... # type: int
    ForwardButton = ... # type: int
    ExtraButton2 = ... # type: int
    TaskButton = ... # type: int
    ExtraButton3 = ... # type: int
    ExtraButton4 = ... # type: int
    ExtraButton5 = ... # type: int
    ExtraButton6 = ... # type: int
    ExtraButton7 = ... # type: int
    ExtraButton8 = ... # type: int
    ExtraButton9 = ... # type: int
    ExtraButton10 = ... # type: int
    ExtraButton11 = ... # type: int
    ExtraButton12 = ... # type: int
    ExtraButton13 = ... # type: int
    ExtraButton14 = ... # type: int
    ExtraButton15 = ... # type: int
    ExtraButton16 = ... # type: int
    ExtraButton17 = ... # type: int
    ExtraButton18 = ... # type: int
    ExtraButton19 = ... # type: int
    ExtraButton20 = ... # type: int
    ExtraButton21 = ... # type: int
    ExtraButton22 = ... # type: int
    ExtraButton23 = ... # type: int
    ExtraButton24 = ... # type: int

    Modifier: typing.Type[int]
    #class Modifier(int): ...
    META = ... # type: int
    SHIFT = ... # type: int
    CTRL = ... # type: int
    ALT = ... # type: int
    MODIFIER_MASK = ... # type: int
    UNICODE_ACCEL = ... # type: int

    KeyboardModifier: typing.Type[int]
    #class KeyboardModifier(int): ...
    NoModifier = ... # type: int
    ShiftModifier = ... # type: int
    ControlModifier = ... # type: int
    AltModifier = ... # type: int
    MetaModifier = ... # type: int
    KeypadModifier = ... # type: int
    GroupSwitchModifier = ... # type: int
    KeyboardModifierMask = ... # type: int

    GlobalColor: typing.Type[int]
    #class GlobalColor(int): ...
    color0 = ... # type: int
    color1 = ... # type: int
    black = ... # type: int
    white = ... # type: int
    darkGray = ... # type: int
    gray = ... # type: int
    lightGray = ... # type: int
    red = ... # type: int
    green = ... # type: int
    blue = ... # type: int
    cyan = ... # type: int
    magenta = ... # type: int
    yellow = ... # type: int
    darkRed = ... # type: int
    darkGreen = ... # type: int
    darkBlue = ... # type: int
    darkCyan = ... # type: int
    darkMagenta = ... # type: int
    darkYellow = ... # type: int
    transparent = ... # type: int

    KeyboardModifiers: typing.Type[int]
    #class KeyboardModifiers(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.KeyboardModifiers, Qt.KeyboardModifier]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.KeyboardModifiers) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.KeyboardModifiers: ...
        #def __int__(self) -> int: ...

    MouseButtons: typing.Type[int]
    #class MouseButtons(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.MouseButtons, Qt.MouseButton]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.MouseButtons) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.MouseButtons: ...
        #def __int__(self) -> int: ...

    Orientations: typing.Type[int]
    #class Orientations(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.Orientations, Qt.Orientation]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.Orientations) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.Orientations: ...
        #def __int__(self) -> int: ...

    Alignment: typing.Type[int]
    #class Alignment(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.Alignment, Qt.AlignmentFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.Alignment) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.Alignment: ...
        #def __int__(self) -> int: ...

    WindowFlags: typing.Type[int]
    #class WindowFlags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.WindowFlags, Qt.WindowType]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.WindowFlags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.WindowFlags: ...
        #def __int__(self) -> int: ...

    WindowStates: typing.Type[int]
    #class WindowStates(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.WindowStates, Qt.WindowState]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.WindowStates) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.WindowStates: ...
        #def __int__(self) -> int: ...

    ImageConversionFlags: typing.Type[int]
    #class ImageConversionFlags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.ImageConversionFlags, Qt.ImageConversionFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.ImageConversionFlags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.ImageConversionFlags: ...
        #def __int__(self) -> int: ...

    DockWidgetAreas: typing.Type[int]
    #class DockWidgetAreas(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.DockWidgetAreas, Qt.DockWidgetArea]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.DockWidgetAreas) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.DockWidgetAreas: ...
        #def __int__(self) -> int: ...

    ToolBarAreas: typing.Type[int]
    #class ToolBarAreas(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.ToolBarAreas, Qt.ToolBarArea]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.ToolBarAreas) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.ToolBarAreas: ...
        #def __int__(self) -> int: ...

    InputMethodQueries: typing.Type[int]
    #class InputMethodQueries(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.InputMethodQueries, Qt.InputMethodQuery]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.InputMethodQueries) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.InputMethodQueries: ...
        #def __int__(self) -> int: ...

    DropActions: typing.Type[int]
    #class DropActions(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.DropActions, Qt.DropAction]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.DropActions) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.DropActions: ...
        #def __int__(self) -> int: ...

    ItemFlags: typing.Type[int]
    #class ItemFlags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.ItemFlags, Qt.ItemFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.ItemFlags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.ItemFlags: ...
        #def __int__(self) -> int: ...

    MatchFlags: typing.Type[int]
    #class MatchFlags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.MatchFlags, Qt.MatchFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.MatchFlags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.MatchFlags: ...
        #def __int__(self) -> int: ...

    TextInteractionFlags: typing.Type[int]
    #class TextInteractionFlags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.TextInteractionFlags, Qt.TextInteractionFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.TextInteractionFlags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.TextInteractionFlags: ...
        #def __int__(self) -> int: ...

    InputMethodHints: typing.Type[int]
    #class InputMethodHints(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.InputMethodHints, Qt.InputMethodHint]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.InputMethodHints) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.InputMethodHints: ...
        #def __int__(self) -> int: ...

    TouchPointStates: typing.Type[int]
    #class TouchPointStates(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.TouchPointStates, Qt.TouchPointState]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.TouchPointStates) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.TouchPointStates: ...
        #def __int__(self) -> int: ...

    GestureFlags: typing.Type[int]
    #class GestureFlags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.GestureFlags, Qt.GestureFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.GestureFlags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.GestureFlags: ...
        #def __int__(self) -> int: ...

    ScreenOrientations: typing.Type[int]
    #class ScreenOrientations(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.ScreenOrientations, Qt.ScreenOrientation]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.ScreenOrientations) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.ScreenOrientations: ...
        #def __int__(self) -> int: ...

    FindChildOptions: typing.Type[int]
    #class FindChildOptions(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.FindChildOptions, Qt.FindChildOption]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.FindChildOptions) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.FindChildOptions: ...
        #def __int__(self) -> int: ...

    ApplicationStates: typing.Type[int]
    #class ApplicationStates(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.ApplicationStates, Qt.ApplicationState]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.ApplicationStates) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.ApplicationStates: ...
        #def __int__(self) -> int: ...

    Edges: typing.Type[int]
    #class Edges(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.Edges, Qt.Edge]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.Edges) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.Edges: ...
        #def __int__(self) -> int: ...

    MouseEventFlags: typing.Type[int]
    #class MouseEventFlags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[Qt.MouseEventFlags, Qt.MouseEventFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: Qt.MouseEventFlags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> Qt.MouseEventFlags: ...
        #def __int__(self) -> int: ...


class QObject(sip.wrapper):

    destroyed: PYQT_SIGNAL
    objectNameChanged: PYQT_SIGNAL

    staticMetaObject = ... # type: QMetaObject

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def disconnect(self) -> None: ...
    def isSignalConnected(self, signal: QMetaMethod) -> bool: ...
    def senderSignalIndex(self) -> int: ...
    def disconnectNotify(self, signal: QMetaMethod) -> None: ...
    def connectNotify(self, signal: QMetaMethod) -> None: ...
    def customEvent(self, a0: QEvent) -> None: ...
    def childEvent(self, a0: QChildEvent) -> None: ...
    def timerEvent(self, a0: QTimerEvent) -> None: ...
    def receivers(self, signal: PYQT_SIGNAL) -> int: ...
    def sender(self) -> QObject: ...
    def deleteLater(self) -> None: ...
    def inherits(self, classname: str) -> bool: ...
    def parent(self) -> QObject: ...
    #def objectNameChanged(self, objectName: str) -> None: ...
    #def destroyed(self, object: typing.Optional[QObject] = ...) -> None: ...
    def property(self, name: str) -> typing.Any: ...
    def setProperty(self, name: str, value: typing.Any) -> bool: ...
    def dynamicPropertyNames(self) -> typing.List[QByteArray]: ...
    def dumpObjectTree(self) -> None: ...
    def dumpObjectInfo(self) -> None: ...
    def removeEventFilter(self, a0: QObject) -> None: ...
    def installEventFilter(self, a0: QObject) -> None: ...
    def setParent(self, a0: typing.Optional[QObject]) -> None: ...
    def children(self) -> typing.List[QObject]: ...
    def killTimer(self, id: int) -> None: ...
    def startTimer(self, interval: int, timerType: int = ...) -> int: ...
    def moveToThread(self, thread: QThread) -> None: ...
    def thread(self) -> QThread: ...
    def blockSignals(self, b: bool) -> bool: ...
    def signalsBlocked(self) -> bool: ...
    def isWindowType(self) -> bool: ...
    def isWidgetType(self) -> bool: ...
    def setObjectName(self, name: str) -> None: ...
    def objectName(self) -> str: ...
    @overload
    def findChildren(self, type: type, name: str = ..., options: typing.Union[int, int] = ...) -> typing.List[QObject]: ...
    @overload
    def findChildren(self, types: typing.Tuple, name: str = ..., options: typing.Union[int, int] = ...) -> typing.List[QObject]: ...
    @overload
    def findChildren(self, type: type, regExp: QRegExp, options: typing.Union[int, int] = ...) -> typing.List[QObject]: ...
    @overload
    def findChildren(self, types: typing.Tuple, regExp: QRegExp, options: typing.Union[int, int] = ...) -> typing.List[QObject]: ...
    @overload
    def findChildren(self, type: type, re: QRegularExpression, options: typing.Union[int, int] = ...) -> typing.List[QObject]: ...
    @overload
    def findChildren(self, types: typing.Tuple, re: QRegularExpression, options: typing.Union[int, int] = ...) -> typing.List[QObject]: ...
    @overload
    def findChild(self, type: type, name: str = ..., options: typing.Union[int, int] = ...) -> QObject: ...
    @overload
    def findChild(self, types: typing.Tuple, name: str = ..., options: typing.Union[int, int] = ...) -> QObject: ...
    def tr(self, sourceText: str, disambiguation: typing.Optional[str] = ..., n: int = ...) -> str: ...
    def eventFilter(self, a0: QObject, a1: QEvent) -> bool: ...
    def event(self, a0: QEvent) -> bool: ...
    def __getattr__(self, name: str) -> typing.Any: ...
    def pyqtConfigure(self, a0: typing.Any) -> None: ...
    def metaObject(self) -> QMetaObject: ...


class QAbstractAnimation(QObject):

    currentLoopChanged: PYQT_SIGNAL
    directionChanged: PYQT_SIGNAL
    finished: PYQT_SIGNAL
    stateChanged: PYQT_SIGNAL

    DeletionPolicy: typing.Type[int]
    #class DeletionPolicy(int): ...
    KeepWhenStopped = ... # type: int
    DeleteWhenStopped = ... # type: int

    State: typing.Type[int]
    #class State(int): ...
    Stopped = ... # type: int
    Paused = ... # type: int
    Running = ... # type: int

    Direction: typing.Type[int]
    #class Direction(int): ...
    Forward = ... # type: int
    Backward = ... # type: int

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def updateDirection(self, direction: int) -> None: ...
    def updateState(self, newState: int, oldState: int) -> None: ...
    def updateCurrentTime(self, currentTime: int) -> None: ...
    def event(self, event: QEvent) -> bool: ...
    def setCurrentTime(self, msecs: int) -> None: ...
    def stop(self) -> None: ...
    def setPaused(self, a0: bool) -> None: ...
    def resume(self) -> None: ...
    def pause(self) -> None: ...
    def start(self, policy: int = ...) -> None: ...
    #def directionChanged(self, a0: int) -> None: ...
    #def currentLoopChanged(self, currentLoop: int) -> None: ...
    #def stateChanged(self, newState: int, oldState: int) -> None: ...
    #def finished(self) -> None: ...
    def totalDuration(self) -> int: ...
    def duration(self) -> int: ...
    def currentLoop(self) -> int: ...
    def setLoopCount(self, loopCount: int) -> None: ...
    def loopCount(self) -> int: ...
    def currentLoopTime(self) -> int: ...
    def currentTime(self) -> int: ...
    def setDirection(self, direction: int) -> None: ...
    def direction(self) -> int: ...
    def group(self) -> QAnimationGroup: ...
    def state(self) -> int: ...


class QAbstractEventDispatcher(QObject):

    aboutToBlock: PYQT_SIGNAL
    awake: PYQT_SIGNAL

    class TimerInfo:

        interval = ... # type: int
        timerId = ... # type: int
        timerType = ... # type: int

        @overload
        def __init__(self, id: int, i: int, t: int) -> None: ...
        @overload
        def __init__(self, a0: QAbstractEventDispatcher.TimerInfo) -> None: ...

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    #def awake(self) -> None: ...
    #def aboutToBlock(self) -> None: ...
    def filterNativeEvent(self, eventType: typing.Union[QByteArray, bytes, bytearray], message: sip.voidptr) -> typing.Tuple[bool, int]: ...
    def removeNativeEventFilter(self, filterObj: QAbstractNativeEventFilter) -> None: ...
    def installNativeEventFilter(self, filterObj: QAbstractNativeEventFilter) -> None: ...
    def remainingTime(self, timerId: int) -> int: ...
    def closingDown(self) -> None: ...
    def startingUp(self) -> None: ...
    def flush(self) -> None: ...
    def interrupt(self) -> None: ...
    def wakeUp(self) -> None: ...
    def registeredTimers(self, object: QObject) -> typing.List[QAbstractEventDispatcher.TimerInfo]: ...
    def unregisterTimers(self, object: QObject) -> bool: ...
    def unregisterTimer(self, timerId: int) -> bool: ...
    @overload
    def registerTimer(self, interval: int, timerType: int, object: QObject) -> int: ...
    @overload
    def registerTimer(self, timerId: int, interval: int, timerType: int, object: QObject) -> None: ...
    def unregisterSocketNotifier(self, notifier: QSocketNotifier) -> None: ...
    def registerSocketNotifier(self, notifier: QSocketNotifier) -> None: ...
    def hasPendingEvents(self) -> bool: ...
    def processEvents(self, flags: typing.Union[int, int]) -> bool: ...
    @staticmethod
    def instance(thread: typing.Optional[QThread] = ...) -> QAbstractEventDispatcher: ...


class QModelIndex(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QModelIndex) -> None: ...
    @overload
    def __init__(self, a0: QPersistentModelIndex) -> None: ...

    def __hash__(self) -> int: ...
    def siblingAtRow(self, row: int) -> QModelIndex: ...
    def siblingAtColumn(self, column: int) -> QModelIndex: ...
    def sibling(self, arow: int, acolumn: int) -> QModelIndex: ...
    def parent(self) -> QModelIndex: ...
    def isValid(self) -> bool: ...
    def model(self) -> QAbstractItemModel: ...
    def internalId(self) -> int: ...
    def internalPointer(self) -> typing.Any: ...
    def flags(self) -> int: ...
    def data(self, role: int = ...) -> typing.Any: ...
    def column(self) -> int: ...
    def row(self) -> int: ...
    def child(self, arow: int, acolumn: int) -> QModelIndex: ...


class QPersistentModelIndex(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, index: QModelIndex) -> None: ...
    @overload
    def __init__(self, other: QPersistentModelIndex) -> None: ...

    def __hash__(self) -> int: ...
    def swap(self, other: QPersistentModelIndex) -> None: ...
    def isValid(self) -> bool: ...
    def model(self) -> QAbstractItemModel: ...
    def child(self, row: int, column: int) -> QModelIndex: ...
    def sibling(self, row: int, column: int) -> QModelIndex: ...
    def parent(self) -> QModelIndex: ...
    def flags(self) -> int: ...
    def data(self, role: int = ...) -> typing.Any: ...
    def column(self) -> int: ...
    def row(self) -> int: ...


class QAbstractItemModel(QObject):

    columnsAboutToBeInserted: PYQT_SIGNAL
    columnsAboutToBeMoved: PYQT_SIGNAL
    columnsAboutToBeRemoved: PYQT_SIGNAL
    columnsInserted: PYQT_SIGNAL
    columnsMoved: PYQT_SIGNAL
    columnsRemoved: PYQT_SIGNAL
    dataChanged: PYQT_SIGNAL
    headerDataChanged: PYQT_SIGNAL
    layoutAboutToBeChanged: PYQT_SIGNAL
    layoutChanged: PYQT_SIGNAL
    modelAboutToBeReset: PYQT_SIGNAL
    modelReset: PYQT_SIGNAL
    rowsAboutToBeInserted: PYQT_SIGNAL
    rowsAboutToBeMoved: PYQT_SIGNAL
    rowsAboutToBeRemoved: PYQT_SIGNAL
    rowsInserted: PYQT_SIGNAL
    rowsMoved: PYQT_SIGNAL
    rowsRemoved: PYQT_SIGNAL

    CheckIndexOption: typing.Type[int]
    #class CheckIndexOption(int): ...
    NoOption = ... # type: int
    IndexIsValid = ... # type: int
    DoNotUseParent = ... # type: int
    ParentIsInvalid = ... # type: int

    LayoutChangeHint: typing.Type[int]
    #class LayoutChangeHint(int): ...
    NoLayoutChangeHint = ... # type: int
    VerticalSortHint = ... # type: int
    HorizontalSortHint = ... # type: int

    CheckIndexOptions: typing.Type[int]
    #class CheckIndexOptions(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QAbstractItemModel.CheckIndexOptions, QAbstractItemModel.CheckIndexOption]) -> None: ...
        #@overload
        #def __init__(self, a0: QAbstractItemModel.CheckIndexOptions) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QAbstractItemModel.CheckIndexOptions: ...
        #def __int__(self) -> int: ...

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def checkIndex(self, index: QModelIndex, options: typing.Union[int, int] = ...) -> bool: ...
    def moveColumn(self, sourceParent: QModelIndex, sourceColumn: int, destinationParent: QModelIndex, destinationChild: int) -> bool: ...
    def moveRow(self, sourceParent: QModelIndex, sourceRow: int, destinationParent: QModelIndex, destinationChild: int) -> bool: ...
    def moveColumns(self, sourceParent: QModelIndex, sourceColumn: int, count: int, destinationParent: QModelIndex, destinationChild: int) -> bool: ...
    def moveRows(self, sourceParent: QModelIndex, sourceRow: int, count: int, destinationParent: QModelIndex, destinationChild: int) -> bool: ...
    def canDropMimeData(self, data: QMimeData, action: int, row: int, column: int, parent: QModelIndex) -> bool: ...
    def resetInternalData(self) -> None: ...
    def endResetModel(self) -> None: ...
    def beginResetModel(self) -> None: ...
    def endMoveColumns(self) -> None: ...
    def beginMoveColumns(self, sourceParent: QModelIndex, sourceFirst: int, sourceLast: int, destinationParent: QModelIndex, destinationColumn: int) -> bool: ...
    def endMoveRows(self) -> None: ...
    def beginMoveRows(self, sourceParent: QModelIndex, sourceFirst: int, sourceLast: int, destinationParent: QModelIndex, destinationRow: int) -> bool: ...
    #def columnsMoved(self, parent: QModelIndex, start: int, end: int, destination: QModelIndex, column: int) -> None: ...
    #def columnsAboutToBeMoved(self, sourceParent: QModelIndex, sourceStart: int, sourceEnd: int, destinationParent: QModelIndex, destinationColumn: int) -> None: ...
    #def rowsMoved(self, parent: QModelIndex, start: int, end: int, destination: QModelIndex, row: int) -> None: ...
    #def rowsAboutToBeMoved(self, sourceParent: QModelIndex, sourceStart: int, sourceEnd: int, destinationParent: QModelIndex, destinationRow: int) -> None: ...
    def createIndex(self, row: int, column: int, object: typing.Any = ...) -> QModelIndex: ...
    def roleNames(self) -> typing.Dict[int, QByteArray]: ...
    def supportedDragActions(self) -> int: ...
    def removeColumn(self, column: int, parent: QModelIndex = ...) -> bool: ...
    def removeRow(self, row: int, parent: QModelIndex = ...) -> bool: ...
    def insertColumn(self, column: int, parent: QModelIndex = ...) -> bool: ...
    def insertRow(self, row: int, parent: QModelIndex = ...) -> bool: ...
    def changePersistentIndexList(self, from_: typing.Iterable[QModelIndex], to: typing.Iterable[QModelIndex]) -> None: ...
    def changePersistentIndex(self, from_: QModelIndex, to: QModelIndex) -> None: ...
    def persistentIndexList(self) -> typing.List[QModelIndex]: ...
    def endRemoveColumns(self) -> None: ...
    def beginRemoveColumns(self, parent: QModelIndex, first: int, last: int) -> None: ...
    def endInsertColumns(self) -> None: ...
    def beginInsertColumns(self, parent: QModelIndex, first: int, last: int) -> None: ...
    def endRemoveRows(self) -> None: ...
    def beginRemoveRows(self, parent: QModelIndex, first: int, last: int) -> None: ...
    def endInsertRows(self) -> None: ...
    def beginInsertRows(self, parent: QModelIndex, first: int, last: int) -> None: ...
    def decodeData(self, row: int, column: int, parent: QModelIndex, stream: QDataStream) -> bool: ...
    def encodeData(self, indexes: typing.Iterable[QModelIndex], stream: QDataStream) -> None: ...
    def revert(self) -> None: ...
    def submit(self) -> bool: ...
    #def modelReset(self) -> None: ...
    #def modelAboutToBeReset(self) -> None: ...
    #def columnsRemoved(self, parent: QModelIndex, first: int, last: int) -> None: ...
    #def columnsAboutToBeRemoved(self, parent: QModelIndex, first: int, last: int) -> None: ...
    #def columnsInserted(self, parent: QModelIndex, first: int, last: int) -> None: ...
    #def columnsAboutToBeInserted(self, parent: QModelIndex, first: int, last: int) -> None: ...
    #def rowsRemoved(self, parent: QModelIndex, first: int, last: int) -> None: ...
    #def rowsAboutToBeRemoved(self, parent: QModelIndex, first: int, last: int) -> None: ...
    #def rowsInserted(self, parent: QModelIndex, first: int, last: int) -> None: ...
    #def rowsAboutToBeInserted(self, parent: QModelIndex, first: int, last: int) -> None: ...
    #def layoutChanged(self, parents: typing.Iterable[QPersistentModelIndex] = ..., hint: int = ...) -> None: ...
    #def layoutAboutToBeChanged(self, parents: typing.Iterable[QPersistentModelIndex] = ..., hint: int = ...) -> None: ...
    #def headerDataChanged(self, orientation: int, first: int, last: int) -> None: ...
    #def dataChanged(self, topLeft: QModelIndex, bottomRight: QModelIndex, roles: typing.Iterable[int] = ...) -> None: ...
    def span(self, index: QModelIndex) -> QSize: ...
    def match(self, start: QModelIndex, role: int, value: typing.Any, hits: int = ..., flags: typing.Union[int, int] = ...) -> typing.List[QModelIndex]: ...
    def buddy(self, index: QModelIndex) -> QModelIndex: ...
    def sort(self, column: int, order: int = ...) -> None: ...
    def flags(self, index: QModelIndex) -> int: ...
    def canFetchMore(self, parent: QModelIndex) -> bool: ...
    def fetchMore(self, parent: QModelIndex) -> None: ...
    def removeColumns(self, column: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def removeRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def insertColumns(self, column: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def insertRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def supportedDropActions(self) -> int: ...
    def dropMimeData(self, data: QMimeData, action: int, row: int, column: int, parent: QModelIndex) -> bool: ...
    def mimeData(self, indexes: typing.Iterable[QModelIndex]) -> QMimeData: ...
    def mimeTypes(self) -> typing.List[str]: ...
    def setItemData(self, index: QModelIndex, roles: typing.Dict[int, typing.Any]) -> bool: ...
    def itemData(self, index: QModelIndex) -> typing.Dict[int, typing.Any]: ...
    def setHeaderData(self, section: int, orientation: int, value: typing.Any, role: int = ...) -> bool: ...
    def headerData(self, section: int, orientation: int, role: int = ...) -> typing.Any: ...
    def setData(self, index: QModelIndex, value: typing.Any, role: int = ...) -> bool: ...
    def data(self, index: QModelIndex, role: int = ...) -> typing.Any: ...
    def hasChildren(self, parent: QModelIndex = ...) -> bool: ...
    def columnCount(self, parent: QModelIndex = ...) -> int: ...
    def rowCount(self, parent: QModelIndex = ...) -> int: ...
    def sibling(self, row: int, column: int, idx: QModelIndex) -> QModelIndex: ...
    @overload
    def parent(self, child: QModelIndex) -> QModelIndex: ...
    @overload
    def parent(self) -> QObject: ...
    def index(self, row: int, column: int, parent: QModelIndex = ...) -> QModelIndex: ...
    def hasIndex(self, row: int, column: int, parent: QModelIndex = ...) -> bool: ...


class QAbstractTableModel(QAbstractItemModel):

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def sibling(self, row: int, column: int, idx: QModelIndex) -> QModelIndex: ...
    def parent(self) -> QObject: ...
    def flags(self, index: QModelIndex) -> int: ...
    def dropMimeData(self, data: QMimeData, action: int, row: int, column: int, parent: QModelIndex) -> bool: ...
    def index(self, row: int, column: int, parent: QModelIndex = ...) -> QModelIndex: ...


class QAbstractListModel(QAbstractItemModel):

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def sibling(self, row: int, column: int, idx: QModelIndex) -> QModelIndex: ...
    def parent(self) -> QObject: ...
    def flags(self, index: QModelIndex) -> int: ...
    def dropMimeData(self, data: QMimeData, action: int, row: int, column: int, parent: QModelIndex) -> bool: ...
    def index(self, row: int, column: int = ..., parent: QModelIndex = ...) -> QModelIndex: ...


class QAbstractNativeEventFilter(sip.simplewrapper):

    def __init__(self) -> None: ...

    def nativeEventFilter(self, eventType: typing.Union[QByteArray, bytes, bytearray], message: sip.voidptr) -> typing.Tuple[bool, int]: ...


class QAbstractProxyModel(QAbstractItemModel):

    sourceModelChanged: PYQT_SIGNAL

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def supportedDragActions(self) -> int: ...
    def dropMimeData(self, data: QMimeData, action: int, row: int, column: int, parent: QModelIndex) -> bool: ...
    def canDropMimeData(self, data: QMimeData, action: int, row: int, column: int, parent: QModelIndex) -> bool: ...
    #def sourceModelChanged(self) -> None: ...
    def resetInternalData(self) -> None: ...
    def sibling(self, row: int, column: int, idx: QModelIndex) -> QModelIndex: ...
    def supportedDropActions(self) -> int: ...
    def mimeTypes(self) -> typing.List[str]: ...
    def mimeData(self, indexes: typing.Iterable[QModelIndex]) -> QMimeData: ...
    def hasChildren(self, parent: QModelIndex = ...) -> bool: ...
    def span(self, index: QModelIndex) -> QSize: ...
    def sort(self, column: int, order: int = ...) -> None: ...
    def fetchMore(self, parent: QModelIndex) -> None: ...
    def canFetchMore(self, parent: QModelIndex) -> bool: ...
    def buddy(self, index: QModelIndex) -> QModelIndex: ...
    def setItemData(self, index: QModelIndex, roles: typing.Dict[int, typing.Any]) -> bool: ...
    def flags(self, index: QModelIndex) -> int: ...
    def itemData(self, index: QModelIndex) -> typing.Dict[int, typing.Any]: ...
    def setHeaderData(self, section: int, orientation: int, value: typing.Any, role: int = ...) -> bool: ...
    def headerData(self, section: int, orientation: int, role: int = ...) -> typing.Any: ...
    def setData(self, index: QModelIndex, value: typing.Any, role: int = ...) -> bool: ...
    def data(self, proxyIndex: QModelIndex, role: int = ...) -> typing.Any: ...
    def revert(self) -> None: ...
    def submit(self) -> bool: ...
    def mapSelectionFromSource(self, selection: QItemSelection) -> QItemSelection: ...
    def mapSelectionToSource(self, selection: QItemSelection) -> QItemSelection: ...
    def mapFromSource(self, sourceIndex: QModelIndex) -> QModelIndex: ...
    def mapToSource(self, proxyIndex: QModelIndex) -> QModelIndex: ...
    def sourceModel(self) -> QAbstractItemModel: ...
    def setSourceModel(self, sourceModel: QAbstractItemModel) -> None: ...


class QAbstractState(QObject):

    activeChanged: PYQT_SIGNAL
    entered: PYQT_SIGNAL
    exited: PYQT_SIGNAL

    def __init__(self, parent: typing.Optional[QState] = ..., **props) -> None: ...

    def event(self, e: QEvent) -> bool: ...
    def onExit(self, event: QEvent) -> None: ...
    def onEntry(self, event: QEvent) -> None: ...
    #def exited(self) -> None: ...
    #def entered(self) -> None: ...
    #def activeChanged(self, active: bool) -> None: ...
    def active(self) -> bool: ...
    def machine(self) -> QStateMachine: ...
    def parentState(self) -> QState: ...


class QAbstractTransition(QObject):

    targetStateChanged: PYQT_SIGNAL
    targetStatesChanged: PYQT_SIGNAL
    triggered: PYQT_SIGNAL

    TransitionType: typing.Type[int]
    #class TransitionType(int): ...
    ExternalTransition = ... # type: int
    InternalTransition = ... # type: int

    def __init__(self, sourceState: typing.Optional[QState] = ..., **props) -> None: ...

    def setTransitionType(self, type: int) -> None: ...
    def transitionType(self) -> int: ...
    def event(self, e: QEvent) -> bool: ...
    def onTransition(self, event: QEvent) -> None: ...
    def eventTest(self, event: QEvent) -> bool: ...
    #def targetStatesChanged(self) -> None: ...
    #def targetStateChanged(self) -> None: ...
    #def triggered(self) -> None: ...
    def animations(self) -> typing.List[QAbstractAnimation]: ...
    def removeAnimation(self, animation: QAbstractAnimation) -> None: ...
    def addAnimation(self, animation: QAbstractAnimation) -> None: ...
    def machine(self) -> QStateMachine: ...
    def setTargetStates(self, targets: typing.Iterable[QAbstractState]) -> None: ...
    def targetStates(self) -> typing.List[QAbstractState]: ...
    def setTargetState(self, target: QAbstractState) -> None: ...
    def targetState(self) -> QAbstractState: ...
    def sourceState(self) -> QState: ...


class QAnimationGroup(QAbstractAnimation):

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def event(self, event: QEvent) -> bool: ...
    def clear(self) -> None: ...
    def takeAnimation(self, index: int) -> QAbstractAnimation: ...
    def removeAnimation(self, animation: QAbstractAnimation) -> None: ...
    def insertAnimation(self, index: int, animation: QAbstractAnimation) -> None: ...
    def addAnimation(self, animation: QAbstractAnimation) -> None: ...
    def indexOfAnimation(self, animation: QAbstractAnimation) -> int: ...
    def animationCount(self) -> int: ...
    def animationAt(self, index: int) -> QAbstractAnimation: ...


class QBasicTimer(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QBasicTimer) -> None: ...

    def stop(self) -> None: ...
    @overload
    def start(self, msec: int, timerType: int, obj: QObject) -> None: ...
    @overload
    def start(self, msec: int, obj: QObject) -> None: ...
    def timerId(self) -> int: ...
    def isActive(self) -> bool: ...


class QBitArray(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, size: int, value: bool = ...) -> None: ...
    @overload
    def __init__(self, other: QBitArray) -> None: ...

    @staticmethod
    def fromBits(data: str, len: int) -> QBitArray: ...
    def bits(self) -> bytes: ...
    def swap(self, other: QBitArray) -> None: ...
    def __hash__(self) -> int: ...
    def at(self, i: int) -> bool: ...
    def __getitem__(self, i: int) -> bool: ...
    def toggleBit(self, i: int) -> bool: ...
    def clearBit(self, i: int) -> None: ...
    @overload
    def setBit(self, i: int) -> None: ...
    @overload
    def setBit(self, i: int, val: bool) -> None: ...
    def testBit(self, i: int) -> bool: ...
    def truncate(self, pos: int) -> None: ...
    @overload
    def fill(self, val: bool, first: int, last: int) -> None: ...
    @overload
    def fill(self, value: bool, size: int = ...) -> bool: ...
    def __invert__(self) -> QBitArray: ...
    def clear(self) -> None: ...
    def isDetached(self) -> bool: ...
    def detach(self) -> None: ...
    def resize(self, size: int) -> None: ...
    def isNull(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def __len__(self) -> int: ...
    @overload
    def count(self) -> int: ...
    @overload
    def count(self, on: bool) -> int: ...
    def size(self) -> int: ...


class QIODevice(QObject):

    aboutToClose: PYQT_SIGNAL
    bytesWritten: PYQT_SIGNAL
    channelBytesWritten: PYQT_SIGNAL
    channelReadyRead: PYQT_SIGNAL
    readChannelFinished: PYQT_SIGNAL
    readyRead: PYQT_SIGNAL

    OpenModeFlag: typing.Type[int]
    #class OpenModeFlag(int): ...
    NotOpen = ... # type: int
    ReadOnly = ... # type: int
    WriteOnly = ... # type: int
    ReadWrite = ... # type: int
    Append = ... # type: int
    Truncate = ... # type: int
    Text = ... # type: int
    Unbuffered = ... # type: int
    NewOnly = ... # type: int
    ExistingOnly = ... # type: int

    OpenMode: typing.Type[int]
    #class OpenMode(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QIODevice.OpenMode, QIODevice.OpenModeFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: QIODevice.OpenMode) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QIODevice.OpenMode: ...
        #def __int__(self) -> int: ...

    @overload
    def __init__(self, **props) -> None: ...
    @overload
    def __init__(self, parent: QObject, **props) -> None: ...

    def skip(self, maxSize: int) -> int: ...
    #def channelBytesWritten(self, channel: int, bytes: int) -> None: ...
    #def channelReadyRead(self, channel: int) -> None: ...
    def isTransactionStarted(self) -> bool: ...
    def rollbackTransaction(self) -> None: ...
    def commitTransaction(self) -> None: ...
    def startTransaction(self) -> None: ...
    def setCurrentWriteChannel(self, channel: int) -> None: ...
    def currentWriteChannel(self) -> int: ...
    def setCurrentReadChannel(self, channel: int) -> None: ...
    def currentReadChannel(self) -> int: ...
    def writeChannelCount(self) -> int: ...
    def readChannelCount(self) -> int: ...
    def setErrorString(self, errorString: str) -> None: ...
    def setOpenMode(self, openMode: typing.Union[int, int]) -> None: ...
    def writeData(self, data: bytes) -> int: ...
    def readLineData(self, maxlen: int) -> bytes: ...
    def readData(self, maxlen: int) -> bytes: ...
    #def readChannelFinished(self) -> None: ...
    #def aboutToClose(self) -> None: ...
    #def bytesWritten(self, bytes: int) -> None: ...
    #def readyRead(self) -> None: ...
    def errorString(self) -> str: ...
    def getChar(self) -> typing.Tuple[bool, str]: ...
    def putChar(self, c: str) -> bool: ...
    def ungetChar(self, c: str) -> None: ...
    def waitForBytesWritten(self, msecs: int) -> bool: ...
    def waitForReadyRead(self, msecs: int) -> bool: ...
    def write(self, data: typing.Union[QByteArray, bytes, bytearray]) -> int: ...
    def peek(self, maxlen: int) -> QByteArray: ...
    def canReadLine(self) -> bool: ...
    def readLine(self, maxlen: int = ...) -> bytes: ...
    def readAll(self) -> QByteArray: ...
    def read(self, maxlen: int) -> bytes: ...
    def bytesToWrite(self) -> int: ...
    def bytesAvailable(self) -> int: ...
    def reset(self) -> bool: ...
    def atEnd(self) -> bool: ...
    def seek(self, pos: int) -> bool: ...
    def size(self) -> int: ...
    def pos(self) -> int: ...
    def close(self) -> None: ...
    def open(self, mode: typing.Union[int, int]) -> bool: ...
    def isSequential(self) -> bool: ...
    def isWritable(self) -> bool: ...
    def isReadable(self) -> bool: ...
    def isOpen(self) -> bool: ...
    def isTextModeEnabled(self) -> bool: ...
    def setTextModeEnabled(self, enabled: bool) -> None: ...
    def openMode(self) -> int: ...


class QBuffer(QIODevice):

    @overload
    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, byteArray: QByteArray, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def disconnectNotify(self, a0: QMetaMethod) -> None: ...
    def connectNotify(self, a0: QMetaMethod) -> None: ...
    def writeData(self, data: bytes) -> int: ...
    def readData(self, maxlen: int) -> bytes: ...
    def canReadLine(self) -> bool: ...
    def atEnd(self) -> bool: ...
    def seek(self, off: int) -> bool: ...
    def pos(self) -> int: ...
    def size(self) -> int: ...
    def close(self) -> None: ...
    def open(self, openMode: typing.Union[int, int]) -> bool: ...
    @overload
    def setData(self, data: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    @overload
    def setData(self, adata: bytes) -> None: ...
    def setBuffer(self, a: QByteArray) -> None: ...
    def data(self) -> QByteArray: ...
    def buffer(self) -> QByteArray: ...


class QByteArray(sip.simplewrapper):

    Base64Option: typing.Type[int]
    #class Base64Option(int): ...
    Base64Encoding = ... # type: int
    Base64UrlEncoding = ... # type: int
    KeepTrailingEquals = ... # type: int
    OmitTrailingEquals = ... # type: int

    Base64Options: typing.Type[int]
    #class Base64Options(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QByteArray.Base64Options, QByteArray.Base64Option]) -> None: ...
        #@overload
        #def __init__(self, a0: QByteArray.Base64Options) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QByteArray.Base64Options: ...
        #def __int__(self) -> int: ...

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, size: int, c: str) -> None: ...
    @overload
    def __init__(self, a: typing.Union[QByteArray, bytes, bytearray]) -> None: ...

    def isLower(self) -> bool: ...
    def isUpper(self) -> bool: ...
    def compare(self, a: typing.Union[QByteArray, bytes, bytearray], cs: int = ...) -> int: ...
    def chopped(self, len: int) -> QByteArray: ...
    def swap(self, other: QByteArray) -> None: ...
    def repeated(self, times: int) -> QByteArray: ...
    @staticmethod
    def fromPercentEncoding(input: typing.Union[QByteArray, bytes, bytearray], percent: str = ...) -> QByteArray: ...
    def toPercentEncoding(self, exclude: typing.Union[QByteArray, bytes, bytearray] = ..., include: typing.Union[QByteArray, bytes, bytearray] = ..., percent: str = ...) -> QByteArray: ...
    @overload
    def toHex(self) -> QByteArray: ...
    @overload
    def toHex(self, separator: str) -> QByteArray: ...
    def contains(self, a: typing.Union[QByteArray, bytes, bytearray]) -> bool: ...
    def push_front(self, a: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    def push_back(self, a: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    def squeeze(self) -> None: ...
    def reserve(self, size: int) -> None: ...
    def capacity(self) -> int: ...
    def data(self) -> bytes: ...
    def isEmpty(self) -> bool: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __hash__(self) -> int: ...
    def __contains__(self, a: typing.Union[QByteArray, bytes, bytearray]) -> int: ...
    @overload
    def __getitem__(self, i: int) -> str: ...
    @overload
    def __getitem__(self, slice: slice) -> QByteArray: ...
    def at(self, i: int) -> str: ...
    def size(self) -> int: ...
    def isNull(self) -> bool: ...
    def length(self) -> int: ...
    def __len__(self) -> int: ...
    @staticmethod
    def fromHex(hexEncoded: typing.Union[QByteArray, bytes, bytearray]) -> QByteArray: ...
    @staticmethod
    def fromRawData(a0: bytes) -> QByteArray: ...
    @overload
    @staticmethod
    def fromBase64(base64: typing.Union[QByteArray, bytes, bytearray]) -> QByteArray: ...
    @overload
    @staticmethod
    def fromBase64(base64: typing.Union[QByteArray, bytes, bytearray], options: typing.Union[int, int]) -> QByteArray: ...
    @overload
    @staticmethod
    def number(n: float, format: str = ..., precision: int = ...) -> QByteArray: ...
    @overload
    @staticmethod
    def number(n: int, base: int = ...) -> QByteArray: ...
    @overload
    def setNum(self, n: float, format: str = ..., precision: int = ...) -> QByteArray: ...
    @overload
    def setNum(self, n: int, base: int = ...) -> QByteArray: ...
    @overload
    def toBase64(self) -> QByteArray: ...
    @overload
    def toBase64(self, options: typing.Union[int, int]) -> QByteArray: ...
    def toDouble(self) -> typing.Tuple[float, bool]: ...
    def toFloat(self) -> typing.Tuple[float, bool]: ...
    def toULongLong(self, base: int = ...) -> typing.Tuple[int, bool]: ...
    def toLongLong(self, base: int = ...) -> typing.Tuple[int, bool]: ...
    def toULong(self, base: int = ...) -> typing.Tuple[int, bool]: ...
    def toLong(self, base: int = ...) -> typing.Tuple[int, bool]: ...
    def toUInt(self, base: int = ...) -> typing.Tuple[int, bool]: ...
    def toInt(self, base: int = ...) -> typing.Tuple[int, bool]: ...
    def toUShort(self, base: int = ...) -> typing.Tuple[int, bool]: ...
    def toShort(self, base: int = ...) -> typing.Tuple[int, bool]: ...
    def split(self, sep: str) -> typing.List[QByteArray]: ...
    @overload
    def replace(self, index: int, len: int, s: typing.Union[QByteArray, bytes, bytearray]) -> QByteArray: ...
    @overload
    def replace(self, before: typing.Union[QByteArray, bytes, bytearray], after: typing.Union[QByteArray, bytes, bytearray]) -> QByteArray: ...
    @overload
    def replace(self, before: str, after: typing.Union[QByteArray, bytes, bytearray]) -> QByteArray: ...
    def remove(self, index: int, len: int) -> QByteArray: ...
    @overload
    def insert(self, i: int, a: typing.Union[QByteArray, bytes, bytearray]) -> QByteArray: ...
    @overload
    def insert(self, i: int, s: str) -> QByteArray: ...
    @overload
    def insert(self, i: int, count: int, c: str) -> QByteArray: ...
    @overload
    def append(self, a: typing.Union[QByteArray, bytes, bytearray]) -> QByteArray: ...
    @overload
    def append(self, s: str) -> QByteArray: ...
    @overload
    def append(self, count: int, c: str) -> QByteArray: ...
    @overload
    def prepend(self, a: typing.Union[QByteArray, bytes, bytearray]) -> QByteArray: ...
    @overload
    def prepend(self, count: int, c: str) -> QByteArray: ...
    def rightJustified(self, width: int, fill: str = ..., truncate: bool = ...) -> QByteArray: ...
    def leftJustified(self, width: int, fill: str = ..., truncate: bool = ...) -> QByteArray: ...
    def simplified(self) -> QByteArray: ...
    def trimmed(self) -> QByteArray: ...
    def toUpper(self) -> QByteArray: ...
    def toLower(self) -> QByteArray: ...
    def chop(self, n: int) -> None: ...
    def truncate(self, pos: int) -> None: ...
    def endsWith(self, a: typing.Union[QByteArray, bytes, bytearray]) -> bool: ...
    def startsWith(self, a: typing.Union[QByteArray, bytes, bytearray]) -> bool: ...
    def mid(self, pos: int, length: int = ...) -> QByteArray: ...
    def right(self, len: int) -> QByteArray: ...
    def left(self, len: int) -> QByteArray: ...
    @overload
    def count(self, a: typing.Union[QByteArray, bytes, bytearray]) -> int: ...
    @overload
    def count(self) -> int: ...
    @overload
    def lastIndexOf(self, ba: typing.Union[QByteArray, bytes, bytearray], from_: int = ...) -> int: ...
    @overload
    def lastIndexOf(self, str: str, from_: int = ...) -> int: ...
    @overload
    def indexOf(self, ba: typing.Union[QByteArray, bytes, bytearray], from_: int = ...) -> int: ...
    @overload
    def indexOf(self, str: str, from_: int = ...) -> int: ...
    def clear(self) -> None: ...
    def fill(self, ch: str, size: int = ...) -> QByteArray: ...
    def resize(self, size: int) -> None: ...


class QByteArrayMatcher(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pattern: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    @overload
    def __init__(self, other: QByteArrayMatcher) -> None: ...

    def pattern(self) -> QByteArray: ...
    def indexIn(self, ba: typing.Union[QByteArray, bytes, bytearray], from_: int = ...) -> int: ...
    def setPattern(self, pattern: typing.Union[QByteArray, bytes, bytearray]) -> None: ...


class QCborError(sip.simplewrapper):

    Code: typing.Type[int]
    #class Code(int): ...
    UnknownError = ... # type: int
    AdvancePastEnd = ... # type: int
    InputOutputError = ... # type: int
    GarbageAtEnd = ... # type: int
    EndOfFile = ... # type: int
    UnexpectedBreak = ... # type: int
    UnknownType = ... # type: int
    IllegalType = ... # type: int
    IllegalNumber = ... # type: int
    IllegalSimpleType = ... # type: int
    InvalidUtf8String = ... # type: int
    DataTooLarge = ... # type: int
    NestingTooDeep = ... # type: int
    UnsupportedType = ... # type: int
    NoError = ... # type: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QCborError) -> None: ...

    def toString(self) -> str: ...
    def code(self) -> int: ...


class QCborStreamWriter(sip.simplewrapper):

    @overload
    def __init__(self, device: QIODevice) -> None: ...
    @overload
    def __init__(self, data: typing.Union[QByteArray, bytes, bytearray]) -> None: ...

    def endMap(self) -> bool: ...
    @overload
    def startMap(self) -> None: ...
    @overload
    def startMap(self, count: int) -> None: ...
    def endArray(self) -> bool: ...
    @overload
    def startArray(self) -> None: ...
    @overload
    def startArray(self, count: int) -> None: ...
    def appendUndefined(self) -> None: ...
    def appendNull(self) -> None: ...
    @overload
    def append(self, st: int) -> None: ...
    @overload
    def append(self, tag: int) -> None: ...
    @overload
    def append(self, str: str) -> None: ...
    @overload
    def append(self, ba: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    @overload
    def append(self, b: bool) -> None: ...
    @overload
    def append(self, d: float) -> None: ...
    @overload
    def append(self, a0: int) -> None: ...
    def device(self) -> QIODevice: ...
    def setDevice(self, device: QIODevice) -> None: ...


class QCborStreamReader(sip.simplewrapper):

    StringResultCode: typing.Type[int]
    #class StringResultCode(int): ...
    EndOfString = ... # type: int
    Ok = ... # type: int
    Error = ... # type: int

    Type: typing.Type[int]
    #class Type(int): ...
    UnsignedInteger = ... # type: int
    NegativeInteger = ... # type: int
    ByteString = ... # type: int
    ByteArray = ... # type: int
    TextString = ... # type: int
    String = ... # type: int
    Array = ... # type: int
    Map = ... # type: int
    Tag = ... # type: int
    SimpleType = ... # type: int
    HalfFloat = ... # type: int
    Float16 = ... # type: int
    Float = ... # type: int
    Double = ... # type: int
    Invalid = ... # type: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, data: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    @overload
    def __init__(self, device: QIODevice) -> None: ...

    def toInteger(self) -> int: ...
    def toDouble(self) -> float: ...
    def toSimpleType(self) -> int: ...
    def toUnsignedInteger(self) -> int: ...
    def toBool(self) -> bool: ...
    def readByteArray(self) -> typing.Tuple[QByteArray, int]: ...
    def readString(self) -> typing.Tuple[str, int]: ...
    def leaveContainer(self) -> bool: ...
    def enterContainer(self) -> bool: ...
    def isContainer(self) -> bool: ...
    def __len__(self) -> int: ...
    def length(self) -> int: ...
    def isLengthKnown(self) -> bool: ...
    def isUndefined(self) -> bool: ...
    def isNull(self) -> bool: ...
    def isBool(self) -> bool: ...
    def isTrue(self) -> bool: ...
    def isFalse(self) -> bool: ...
    def isInvalid(self) -> bool: ...
    def isDouble(self) -> bool: ...
    def isFloat(self) -> bool: ...
    def isFloat16(self) -> bool: ...
    @overload
    def isSimpleType(self) -> bool: ...
    @overload
    def isSimpleType(self, st: int) -> bool: ...
    def isTag(self) -> bool: ...
    def isMap(self) -> bool: ...
    def isArray(self) -> bool: ...
    def isString(self) -> bool: ...
    def isByteArray(self) -> bool: ...
    def isInteger(self) -> bool: ...
    def isNegativeInteger(self) -> bool: ...
    def isUnsignedInteger(self) -> bool: ...
    def type(self) -> int: ...
    def next(self, maxRecursion: int = ...) -> bool: ...
    def hasNext(self) -> bool: ...
    def parentContainerType(self) -> int: ...
    def containerDepth(self) -> int: ...
    def isValid(self) -> bool: ...
    def currentOffset(self) -> int: ...
    def lastError(self) -> QCborError: ...
    def reset(self) -> None: ...
    def clear(self) -> None: ...
    def reparse(self) -> None: ...
    def addData(self, data: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    def device(self) -> QIODevice: ...
    def setDevice(self, device: QIODevice) -> None: ...


class QCollatorSortKey(sip.simplewrapper):

    def __init__(self, other: QCollatorSortKey) -> None: ...

    def compare(self, key: QCollatorSortKey) -> int: ...
    def swap(self, other: QCollatorSortKey) -> None: ...


class QCollator(sip.simplewrapper):

    @overload
    def __init__(self, locale: QLocale = ...) -> None: ...
    @overload
    def __init__(self, a0: QCollator) -> None: ...

    def sortKey(self, string: str) -> QCollatorSortKey: ...
    def compare(self, s1: str, s2: str) -> int: ...
    def ignorePunctuation(self) -> bool: ...
    def setIgnorePunctuation(self, on: bool) -> None: ...
    def numericMode(self) -> bool: ...
    def setNumericMode(self, on: bool) -> None: ...
    def setCaseSensitivity(self, cs: int) -> None: ...
    def caseSensitivity(self) -> int: ...
    def locale(self) -> QLocale: ...
    def setLocale(self, locale: QLocale) -> None: ...
    def swap(self, other: QCollator) -> None: ...


class QCommandLineOption(sip.simplewrapper):

    Flag: typing.Type[int]
    #class Flag(int): ...
    HiddenFromHelp = ... # type: int
    ShortOptionStyle = ... # type: int

    Flags: typing.Type[int]
    #class Flags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QCommandLineOption.Flags, QCommandLineOption.Flag]) -> None: ...
        #@overload
        #def __init__(self, a0: QCommandLineOption.Flags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QCommandLineOption.Flags: ...
        #def __int__(self) -> int: ...

    @overload
    def __init__(self, name: str) -> None: ...
    @overload
    def __init__(self, names: typing.Iterable[str]) -> None: ...
    @overload
    def __init__(self, name: str, description: str, valueName: str = ..., defaultValue: str = ...) -> None: ...
    @overload
    def __init__(self, names: typing.Iterable[str], description: str, valueName: str = ..., defaultValue: str = ...) -> None: ...
    @overload
    def __init__(self, other: QCommandLineOption) -> None: ...

    def setFlags(self, aflags: typing.Union[int, int]) -> None: ...
    def flags(self) -> int: ...
    def isHidden(self) -> bool: ...
    def setHidden(self, hidden: bool) -> None: ...
    def defaultValues(self) -> typing.List[str]: ...
    def setDefaultValues(self, defaultValues: typing.Iterable[str]) -> None: ...
    def setDefaultValue(self, defaultValue: str) -> None: ...
    def description(self) -> str: ...
    def setDescription(self, description: str) -> None: ...
    def valueName(self) -> str: ...
    def setValueName(self, name: str) -> None: ...
    def names(self) -> typing.List[str]: ...
    def swap(self, other: QCommandLineOption) -> None: ...


class QCommandLineParser(sip.simplewrapper):

    OptionsAfterPositionalArgumentsMode: typing.Type[int]
    #class OptionsAfterPositionalArgumentsMode(int): ...
    ParseAsOptions = ... # type: int
    ParseAsPositionalArguments = ... # type: int

    SingleDashWordOptionMode: typing.Type[int]
    #class SingleDashWordOptionMode(int): ...
    ParseAsCompactedShortOptions = ... # type: int
    ParseAsLongOptions = ... # type: int

    def __init__(self) -> None: ...

    def setOptionsAfterPositionalArgumentsMode(self, mode: int) -> None: ...
    def showVersion(self) -> None: ...
    def addOptions(self, options: typing.Iterable[QCommandLineOption]) -> bool: ...
    def helpText(self) -> str: ...
    def showHelp(self, exitCode: int = ...) -> None: ...
    def unknownOptionNames(self) -> typing.List[str]: ...
    def optionNames(self) -> typing.List[str]: ...
    def positionalArguments(self) -> typing.List[str]: ...
    @overload
    def values(self, name: str) -> typing.List[str]: ...
    @overload
    def values(self, option: QCommandLineOption) -> typing.List[str]: ...
    @overload
    def value(self, name: str) -> str: ...
    @overload
    def value(self, option: QCommandLineOption) -> str: ...
    @overload
    def isSet(self, name: str) -> bool: ...
    @overload
    def isSet(self, option: QCommandLineOption) -> bool: ...
    def errorText(self) -> str: ...
    def parse(self, arguments: typing.Iterable[str]) -> bool: ...
    @overload
    def process(self, arguments: typing.Iterable[str]) -> None: ...
    @overload
    def process(self, app: QCoreApplication) -> None: ...
    def clearPositionalArguments(self) -> None: ...
    def addPositionalArgument(self, name: str, description: str, syntax: str = ...) -> None: ...
    def applicationDescription(self) -> str: ...
    def setApplicationDescription(self, description: str) -> None: ...
    def addHelpOption(self) -> QCommandLineOption: ...
    def addVersionOption(self) -> QCommandLineOption: ...
    def addOption(self, commandLineOption: QCommandLineOption) -> bool: ...
    def setSingleDashWordOptionMode(self, parsingMode: int) -> None: ...


class QCoreApplication(QObject):

    aboutToQuit: PYQT_SIGNAL

    def __init__(self, argv: typing.List[str], **props) -> None: ...

    def __exit__(self, type: typing.Any, value: typing.Any, traceback: typing.Any) -> None: ...
    def __enter__(self) -> typing.Any: ...
    @staticmethod
    def isSetuidAllowed() -> bool: ...
    @staticmethod
    def setSetuidAllowed(allow: bool) -> None: ...
    def removeNativeEventFilter(self, filterObj: QAbstractNativeEventFilter) -> None: ...
    def installNativeEventFilter(self, filterObj: QAbstractNativeEventFilter) -> None: ...
    @staticmethod
    def setQuitLockEnabled(enabled: bool) -> None: ...
    @staticmethod
    def isQuitLockEnabled() -> bool: ...
    @staticmethod
    def setEventDispatcher(eventDispatcher: QAbstractEventDispatcher) -> None: ...
    @staticmethod
    def eventDispatcher() -> QAbstractEventDispatcher: ...
    @staticmethod
    def applicationPid() -> int: ...
    @staticmethod
    def applicationVersion() -> str: ...
    @staticmethod
    def setApplicationVersion(version: str) -> None: ...
    def event(self, a0: QEvent) -> bool: ...
    #def aboutToQuit(self) -> None: ...
    @staticmethod
    def quit() -> None: ...
    @staticmethod
    def testAttribute(attribute: int) -> bool: ...
    @staticmethod
    def setAttribute(attribute: int, on: bool = ...) -> None: ...
    @staticmethod
    def flush() -> None: ...
    @staticmethod
    def translate(context: str, sourceText: str, disambiguation: typing.Optional[str] = ..., n: int = ...) -> str: ...
    @staticmethod
    def removeTranslator(messageFile: QTranslator) -> bool: ...
    @staticmethod
    def installTranslator(messageFile: QTranslator) -> bool: ...
    @staticmethod
    def removeLibraryPath(a0: str) -> None: ...
    @staticmethod
    def addLibraryPath(a0: str) -> None: ...
    @staticmethod
    def libraryPaths() -> typing.List[str]: ...
    @staticmethod
    def setLibraryPaths(a0: typing.Iterable[str]) -> None: ...
    @staticmethod
    def applicationFilePath() -> str: ...
    @staticmethod
    def applicationDirPath() -> str: ...
    @staticmethod
    def closingDown() -> bool: ...
    @staticmethod
    def startingUp() -> bool: ...
    def notify(self, a0: QObject, a1: QEvent) -> bool: ...
    @staticmethod
    def hasPendingEvents() -> bool: ...
    @staticmethod
    def removePostedEvents(receiver: QObject, eventType: int = ...) -> None: ...
    @staticmethod
    def sendPostedEvents(receiver: typing.Optional[QObject] = ..., eventType: int = ...) -> None: ...
    @staticmethod
    def postEvent(receiver: QObject, event: QEvent, priority: int = ...) -> None: ...
    @staticmethod
    def sendEvent(receiver: QObject, event: QEvent) -> bool: ...
    @staticmethod
    def exit(returnCode: int = ...) -> None: ...
    @overload
    @staticmethod
    def processEvents(flags: typing.Union[int, int] = ...) -> None: ...
    @overload
    @staticmethod
    def processEvents(flags: typing.Union[int, int], maxtime: int) -> None: ...
    @staticmethod
    def exec() -> int: ...
    @staticmethod
    def exec_() -> int: ...
    @staticmethod
    def instance() -> QCoreApplication: ...
    @staticmethod
    def arguments() -> typing.List[str]: ...
    @staticmethod
    def applicationName() -> str: ...
    @staticmethod
    def setApplicationName(application: str) -> None: ...
    @staticmethod
    def organizationName() -> str: ...
    @staticmethod
    def setOrganizationName(orgName: str) -> None: ...
    @staticmethod
    def organizationDomain() -> str: ...
    @staticmethod
    def setOrganizationDomain(orgDomain: str) -> None: ...


class QEvent(sip.wrapper):

    Type: typing.Type[int]
    #class Type(int): ...
    None_ = ... # type: int
    Timer = ... # type: int
    MouseButtonPress = ... # type: int
    MouseButtonRelease = ... # type: int
    MouseButtonDblClick = ... # type: int
    MouseMove = ... # type: int
    KeyPress = ... # type: int
    KeyRelease = ... # type: int
    FocusIn = ... # type: int
    FocusOut = ... # type: int
    Enter = ... # type: int
    Leave = ... # type: int
    Paint = ... # type: int
    Move = ... # type: int
    Resize = ... # type: int
    Show = ... # type: int
    Hide = ... # type: int
    Close = ... # type: int
    ParentChange = ... # type: int
    ParentAboutToChange = ... # type: int
    ThreadChange = ... # type: int
    WindowActivate = ... # type: int
    WindowDeactivate = ... # type: int
    ShowToParent = ... # type: int
    HideToParent = ... # type: int
    Wheel = ... # type: int
    WindowTitleChange = ... # type: int
    WindowIconChange = ... # type: int
    ApplicationWindowIconChange = ... # type: int
    ApplicationFontChange = ... # type: int
    ApplicationLayoutDirectionChange = ... # type: int
    ApplicationPaletteChange = ... # type: int
    PaletteChange = ... # type: int
    Clipboard = ... # type: int
    MetaCall = ... # type: int
    SockAct = ... # type: int
    WinEventAct = ... # type: int
    DeferredDelete = ... # type: int
    DragEnter = ... # type: int
    DragMove = ... # type: int
    DragLeave = ... # type: int
    Drop = ... # type: int
    ChildAdded = ... # type: int
    ChildPolished = ... # type: int
    ChildRemoved = ... # type: int
    PolishRequest = ... # type: int
    Polish = ... # type: int
    LayoutRequest = ... # type: int
    UpdateRequest = ... # type: int
    UpdateLater = ... # type: int
    ContextMenu = ... # type: int
    InputMethod = ... # type: int
    TabletMove = ... # type: int
    LocaleChange = ... # type: int
    LanguageChange = ... # type: int
    LayoutDirectionChange = ... # type: int
    TabletPress = ... # type: int
    TabletRelease = ... # type: int
    OkRequest = ... # type: int
    IconDrag = ... # type: int
    FontChange = ... # type: int
    EnabledChange = ... # type: int
    ActivationChange = ... # type: int
    StyleChange = ... # type: int
    IconTextChange = ... # type: int
    ModifiedChange = ... # type: int
    MouseTrackingChange = ... # type: int
    WindowBlocked = ... # type: int
    WindowUnblocked = ... # type: int
    WindowStateChange = ... # type: int
    ToolTip = ... # type: int
    WhatsThis = ... # type: int
    StatusTip = ... # type: int
    ActionChanged = ... # type: int
    ActionAdded = ... # type: int
    ActionRemoved = ... # type: int
    FileOpen = ... # type: int
    Shortcut = ... # type: int
    ShortcutOverride = ... # type: int
    WhatsThisClicked = ... # type: int
    ToolBarChange = ... # type: int
    ApplicationActivate = ... # type: int
    ApplicationActivated = ... # type: int
    ApplicationDeactivate = ... # type: int
    ApplicationDeactivated = ... # type: int
    QueryWhatsThis = ... # type: int
    EnterWhatsThisMode = ... # type: int
    LeaveWhatsThisMode = ... # type: int
    ZOrderChange = ... # type: int
    HoverEnter = ... # type: int
    HoverLeave = ... # type: int
    HoverMove = ... # type: int
    GraphicsSceneMouseMove = ... # type: int
    GraphicsSceneMousePress = ... # type: int
    GraphicsSceneMouseRelease = ... # type: int
    GraphicsSceneMouseDoubleClick = ... # type: int
    GraphicsSceneContextMenu = ... # type: int
    GraphicsSceneHoverEnter = ... # type: int
    GraphicsSceneHoverMove = ... # type: int
    GraphicsSceneHoverLeave = ... # type: int
    GraphicsSceneHelp = ... # type: int
    GraphicsSceneDragEnter = ... # type: int
    GraphicsSceneDragMove = ... # type: int
    GraphicsSceneDragLeave = ... # type: int
    GraphicsSceneDrop = ... # type: int
    GraphicsSceneWheel = ... # type: int
    GraphicsSceneResize = ... # type: int
    GraphicsSceneMove = ... # type: int
    KeyboardLayoutChange = ... # type: int
    DynamicPropertyChange = ... # type: int
    TabletEnterProximity = ... # type: int
    TabletLeaveProximity = ... # type: int
    NonClientAreaMouseMove = ... # type: int
    NonClientAreaMouseButtonPress = ... # type: int
    NonClientAreaMouseButtonRelease = ... # type: int
    NonClientAreaMouseButtonDblClick = ... # type: int
    MacSizeChange = ... # type: int
    ContentsRectChange = ... # type: int
    CursorChange = ... # type: int
    ToolTipChange = ... # type: int
    GrabMouse = ... # type: int
    UngrabMouse = ... # type: int
    GrabKeyboard = ... # type: int
    UngrabKeyboard = ... # type: int
    StateMachineSignal = ... # type: int
    StateMachineWrapped = ... # type: int
    TouchBegin = ... # type: int
    TouchUpdate = ... # type: int
    TouchEnd = ... # type: int
    RequestSoftwareInputPanel = ... # type: int
    CloseSoftwareInputPanel = ... # type: int
    WinIdChange = ... # type: int
    Gesture = ... # type: int
    GestureOverride = ... # type: int
    FocusAboutToChange = ... # type: int
    ScrollPrepare = ... # type: int
    Scroll = ... # type: int
    Expose = ... # type: int
    InputMethodQuery = ... # type: int
    OrientationChange = ... # type: int
    TouchCancel = ... # type: int
    PlatformPanel = ... # type: int
    ApplicationStateChange = ... # type: int
    ReadOnlyChange = ... # type: int
    PlatformSurface = ... # type: int
    TabletTrackingChange = ... # type: int
    User = ... # type: int
    MaxUser = ... # type: int

    @overload
    def __init__(self, type: int) -> None: ...
    @overload
    def __init__(self, other: QEvent) -> None: ...

    @staticmethod
    def registerEventType(hint: int = ...) -> int: ...
    def ignore(self) -> None: ...
    def accept(self) -> None: ...
    def isAccepted(self) -> bool: ...
    def setAccepted(self, accepted: bool) -> None: ...
    def spontaneous(self) -> bool: ...
    def type(self) -> int: ...


class QTimerEvent(QEvent):

    @overload
    def __init__(self, timerId: int) -> None: ...
    @overload
    def __init__(self, a0: QTimerEvent) -> None: ...

    def timerId(self) -> int: ...


class QChildEvent(QEvent):

    @overload
    def __init__(self, type: int, child: QObject) -> None: ...
    @overload
    def __init__(self, a0: QChildEvent) -> None: ...

    def removed(self) -> bool: ...
    def polished(self) -> bool: ...
    def added(self) -> bool: ...
    def child(self) -> QObject: ...


class QDynamicPropertyChangeEvent(QEvent):

    @overload
    def __init__(self, name: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    @overload
    def __init__(self, a0: QDynamicPropertyChangeEvent) -> None: ...

    def propertyName(self) -> QByteArray: ...


class QCryptographicHash(sip.simplewrapper):

    Algorithm: typing.Type[int]
    #class Algorithm(int): ...
    Md4 = ... # type: int
    Md5 = ... # type: int
    Sha1 = ... # type: int
    Sha224 = ... # type: int
    Sha256 = ... # type: int
    Sha384 = ... # type: int
    Sha512 = ... # type: int
    Sha3_224 = ... # type: int
    Sha3_256 = ... # type: int
    Sha3_384 = ... # type: int
    Sha3_512 = ... # type: int
    Keccak_224 = ... # type: int
    Keccak_256 = ... # type: int
    Keccak_384 = ... # type: int
    Keccak_512 = ... # type: int

    def __init__(self, method: int) -> None: ...

    @staticmethod
    def hashLength(method: int) -> int: ...
    @staticmethod
    def hash(data: typing.Union[QByteArray, bytes, bytearray], method: int) -> QByteArray: ...
    def result(self) -> QByteArray: ...
    @overload
    def addData(self, data: bytes) -> None: ...
    @overload
    def addData(self, data: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    @overload
    def addData(self, device: QIODevice) -> bool: ...
    def reset(self) -> None: ...


class QDataStream(sip.simplewrapper):

    FloatingPointPrecision: typing.Type[int]
    #class FloatingPointPrecision(int): ...
    SinglePrecision = ... # type: int
    DoublePrecision = ... # type: int

    Status: typing.Type[int]
    #class Status(int): ...
    Ok = ... # type: int
    ReadPastEnd = ... # type: int
    ReadCorruptData = ... # type: int
    WriteFailed = ... # type: int

    ByteOrder: typing.Type[int]
    #class ByteOrder(int): ...
    BigEndian = ... # type: int
    LittleEndian = ... # type: int

    Version: typing.Type[int]
    #class Version(int): ...
    Qt_1_0 = ... # type: int
    Qt_2_0 = ... # type: int
    Qt_2_1 = ... # type: int
    Qt_3_0 = ... # type: int
    Qt_3_1 = ... # type: int
    Qt_3_3 = ... # type: int
    Qt_4_0 = ... # type: int
    Qt_4_1 = ... # type: int
    Qt_4_2 = ... # type: int
    Qt_4_3 = ... # type: int
    Qt_4_4 = ... # type: int
    Qt_4_5 = ... # type: int
    Qt_4_6 = ... # type: int
    Qt_4_7 = ... # type: int
    Qt_4_8 = ... # type: int
    Qt_4_9 = ... # type: int
    Qt_5_0 = ... # type: int
    Qt_5_1 = ... # type: int
    Qt_5_2 = ... # type: int
    Qt_5_3 = ... # type: int
    Qt_5_4 = ... # type: int
    Qt_5_5 = ... # type: int
    Qt_5_6 = ... # type: int
    Qt_5_7 = ... # type: int
    Qt_5_8 = ... # type: int
    Qt_5_9 = ... # type: int
    Qt_5_10 = ... # type: int
    Qt_5_11 = ... # type: int
    Qt_5_12 = ... # type: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QIODevice) -> None: ...
    @overload
    def __init__(self, a0: QByteArray, flags: typing.Union[int, int]) -> None: ...
    @overload
    def __init__(self, a0: QByteArray) -> None: ...

    def abortTransaction(self) -> None: ...
    def rollbackTransaction(self) -> None: ...
    def commitTransaction(self) -> bool: ...
    def startTransaction(self) -> None: ...
    def setFloatingPointPrecision(self, precision: int) -> None: ...
    def floatingPointPrecision(self) -> int: ...
    def writeRawData(self, a0: bytes) -> int: ...
    def writeBytes(self, a0: bytes) -> QDataStream: ...
    def readRawData(self, len: int) -> bytes: ...
    def readBytes(self) -> bytes: ...
    def writeQVariantHash(self, qvarhash: typing.Dict[str, typing.Any]) -> None: ...
    def readQVariantHash(self) -> typing.Dict[str, typing.Any]: ...
    def writeQVariantMap(self, qvarmap: typing.Dict[str, typing.Any]) -> None: ...
    def readQVariantMap(self) -> typing.Dict[str, typing.Any]: ...
    def writeQVariantList(self, qvarlst: typing.Iterable[typing.Any]) -> None: ...
    def readQVariantList(self) -> typing.List[typing.Any]: ...
    def writeQVariant(self, qvar: typing.Any) -> None: ...
    def readQVariant(self) -> typing.Any: ...
    def writeQStringList(self, qstrlst: typing.Iterable[str]) -> None: ...
    def readQStringList(self) -> typing.List[str]: ...
    def writeQString(self, qstr: str) -> None: ...
    def readQString(self) -> str: ...
    def writeString(self, str: str) -> None: ...
    def writeDouble(self, f: float) -> None: ...
    def writeFloat(self, f: float) -> None: ...
    def writeBool(self, i: bool) -> None: ...
    def writeUInt64(self, i: int) -> None: ...
    def writeInt64(self, i: int) -> None: ...
    def writeUInt32(self, i: int) -> None: ...
    def writeInt32(self, i: int) -> None: ...
    def writeUInt16(self, i: int) -> None: ...
    def writeInt16(self, i: int) -> None: ...
    def writeUInt8(self, i: int) -> None: ...
    def writeInt8(self, i: int) -> None: ...
    def writeInt(self, i: int) -> None: ...
    def readString(self) -> bytes: ...
    def readDouble(self) -> float: ...
    def readFloat(self) -> float: ...
    def readBool(self) -> bool: ...
    def readUInt64(self) -> int: ...
    def readInt64(self) -> int: ...
    def readUInt32(self) -> int: ...
    def readInt32(self) -> int: ...
    def readUInt16(self) -> int: ...
    def readInt16(self) -> int: ...
    def readUInt8(self) -> int: ...
    def readInt8(self) -> int: ...
    def readInt(self) -> int: ...
    def skipRawData(self, len: int) -> int: ...
    def setVersion(self, v: int) -> None: ...
    def version(self) -> int: ...
    def setByteOrder(self, a0: int) -> None: ...
    def byteOrder(self) -> int: ...
    def resetStatus(self) -> None: ...
    def setStatus(self, status: int) -> None: ...
    def status(self) -> int: ...
    def atEnd(self) -> bool: ...
    def setDevice(self, a0: QIODevice) -> None: ...
    def device(self) -> QIODevice: ...


class QDate(sip.simplewrapper):

    MonthNameType: typing.Type[int]
    #class MonthNameType(int): ...
    DateFormat = ... # type: int
    StandaloneFormat = ... # type: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, y: int, m: int, d: int) -> None: ...
    @overload
    def __init__(self, a0: QDate) -> None: ...

    def getDate(self) -> typing.Tuple[int, int, int]: ...
    def setDate(self, year: int, month: int, date: int) -> bool: ...
    def toJulianDay(self) -> int: ...
    @staticmethod
    def fromJulianDay(jd: int) -> QDate: ...
    @staticmethod
    def isLeapYear(year: int) -> bool: ...
    @overload
    @staticmethod
    def fromString(string: str, format: int = ...) -> QDate: ...
    @overload
    @staticmethod
    def fromString(s: str, format: str) -> QDate: ...
    @staticmethod
    def currentDate() -> QDate: ...
    def daysTo(self, a0: typing.Union[QDate, datetime.date]) -> int: ...
    def addYears(self, years: int) -> QDate: ...
    def addMonths(self, months: int) -> QDate: ...
    def addDays(self, days: int) -> QDate: ...
    @overload
    def toString(self, format: int = ...) -> str: ...
    @overload
    def toString(self, format: str) -> str: ...
    @staticmethod
    def longDayName(weekday: int, type: int = ...) -> str: ...
    @staticmethod
    def longMonthName(month: int, type: int = ...) -> str: ...
    @staticmethod
    def shortDayName(weekday: int, type: int = ...) -> str: ...
    @staticmethod
    def shortMonthName(month: int, type: int = ...) -> str: ...
    def weekNumber(self) -> typing.Tuple[int, int]: ...
    def daysInYear(self) -> int: ...
    def daysInMonth(self) -> int: ...
    def dayOfYear(self) -> int: ...
    def dayOfWeek(self) -> int: ...
    def day(self) -> int: ...
    def month(self) -> int: ...
    def year(self) -> int: ...
    @overload
    def isValid(self) -> bool: ...
    #@overload
    #@staticmethod
    #def isValid(y: int, m: int, d: int) -> bool: ...
    def __bool__(self) -> int: ...
    def isNull(self) -> bool: ...
    def toPyDate(self) -> datetime.date: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...


class QTime(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, h: int, m: int, second: int = ..., msec: int = ...) -> None: ...
    @overload
    def __init__(self, a0: QTime) -> None: ...

    def msecsSinceStartOfDay(self) -> int: ...
    @staticmethod
    def fromMSecsSinceStartOfDay(msecs: int) -> QTime: ...
    def elapsed(self) -> int: ...
    def restart(self) -> int: ...
    def start(self) -> None: ...
    @overload
    @staticmethod
    def fromString(string: str, format: int = ...) -> QTime: ...
    @overload
    @staticmethod
    def fromString(s: str, format: str) -> QTime: ...
    @staticmethod
    def currentTime() -> QTime: ...
    def msecsTo(self, a0: typing.Union[QTime, datetime.time]) -> int: ...
    def addMSecs(self, ms: int) -> QTime: ...
    def secsTo(self, a0: typing.Union[QTime, datetime.time]) -> int: ...
    def addSecs(self, secs: int) -> QTime: ...
    def setHMS(self, h: int, m: int, s: int, msec: int = ...) -> bool: ...
    @overload
    def toString(self, format: int = ...) -> str: ...
    @overload
    def toString(self, format: str) -> str: ...
    def msec(self) -> int: ...
    def second(self) -> int: ...
    def minute(self) -> int: ...
    def hour(self) -> int: ...
    @overload
    def isValid(self) -> bool: ...
    #@overload
    #@staticmethod
    #def isValid(h: int, m: int, s: int, msec: int = ...) -> bool: ...
    def __bool__(self) -> int: ...
    def isNull(self) -> bool: ...
    def toPyTime(self) -> datetime.time: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...


class QDateTime(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: typing.Union[QDateTime, datetime.datetime]) -> None: ...
    @overload
    def __init__(self, a0: typing.Union[QDate, datetime.date]) -> None: ...
    @overload
    def __init__(self, date: typing.Union[QDate, datetime.date], time: typing.Union[QTime, datetime.time], timeSpec: int = ...) -> None: ...
    @overload
    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int = ..., msec: int = ..., timeSpec: int = ...) -> None: ...
    @overload
    def __init__(self, date: typing.Union[QDate, datetime.date], time: typing.Union[QTime, datetime.time], spec: int, offsetSeconds: int) -> None: ...
    @overload
    def __init__(self, date: typing.Union[QDate, datetime.date], time: typing.Union[QTime, datetime.time], timeZone: QTimeZone) -> None: ...

    @staticmethod
    def currentSecsSinceEpoch() -> int: ...
    @overload
    @staticmethod
    def fromSecsSinceEpoch(secs: int, spec: int = ..., offsetSeconds: int = ...) -> QDateTime: ...
    @overload
    @staticmethod
    def fromSecsSinceEpoch(secs: int, timeZone: QTimeZone) -> QDateTime: ...
    def setSecsSinceEpoch(self, secs: int) -> None: ...
    def toSecsSinceEpoch(self) -> int: ...
    def toTimeZone(self, toZone: QTimeZone) -> QDateTime: ...
    def toOffsetFromUtc(self, offsetSeconds: int) -> QDateTime: ...
    def setTimeZone(self, toZone: QTimeZone) -> None: ...
    def setOffsetFromUtc(self, offsetSeconds: int) -> None: ...
    def isDaylightTime(self) -> bool: ...
    def timeZoneAbbreviation(self) -> str: ...
    def timeZone(self) -> QTimeZone: ...
    def offsetFromUtc(self) -> int: ...
    def swap(self, other: QDateTime) -> None: ...
    @staticmethod
    def currentMSecsSinceEpoch() -> int: ...
    @overload
    @staticmethod
    def fromMSecsSinceEpoch(msecs: int) -> QDateTime: ...
    @overload
    @staticmethod
    def fromMSecsSinceEpoch(msecs: int, spec: int, offsetSeconds: int = ...) -> QDateTime: ...
    @overload
    @staticmethod
    def fromMSecsSinceEpoch(msecs: int, timeZone: QTimeZone) -> QDateTime: ...
    @staticmethod
    def currentDateTimeUtc() -> QDateTime: ...
    def msecsTo(self, a0: typing.Union[QDateTime, datetime.datetime]) -> int: ...
    def setMSecsSinceEpoch(self, msecs: int) -> None: ...
    def toMSecsSinceEpoch(self) -> int: ...
    @overload
    @staticmethod
    def fromTime_t(secsSince1Jan1970UTC: int) -> QDateTime: ...
    @overload
    @staticmethod
    def fromTime_t(secsSince1Jan1970UTC: int, spec: int, offsetSeconds: int = ...) -> QDateTime: ...
    @overload
    @staticmethod
    def fromTime_t(secsSince1Jan1970UTC: int, timeZone: QTimeZone) -> QDateTime: ...
    @overload
    @staticmethod
    def fromString(string: str, format: int = ...) -> QDateTime: ...
    @overload
    @staticmethod
    def fromString(s: str, format: str) -> QDateTime: ...
    @staticmethod
    def currentDateTime() -> QDateTime: ...
    def secsTo(self, a0: typing.Union[QDateTime, datetime.datetime]) -> int: ...
    def daysTo(self, a0: typing.Union[QDateTime, datetime.datetime]) -> int: ...
    def toUTC(self) -> QDateTime: ...
    def toLocalTime(self) -> QDateTime: ...
    def toTimeSpec(self, spec: int) -> QDateTime: ...
    def addMSecs(self, msecs: int) -> QDateTime: ...
    def addSecs(self, secs: int) -> QDateTime: ...
    def addYears(self, years: int) -> QDateTime: ...
    def addMonths(self, months: int) -> QDateTime: ...
    def addDays(self, days: int) -> QDateTime: ...
    @overload
    def toString(self, format: int = ...) -> str: ...
    @overload
    def toString(self, format: str) -> str: ...
    def setTime_t(self, secsSince1Jan1970UTC: int) -> None: ...
    def setTimeSpec(self, spec: int) -> None: ...
    def setTime(self, time: typing.Union[QTime, datetime.time]) -> None: ...
    def setDate(self, date: typing.Union[QDate, datetime.date]) -> None: ...
    def toTime_t(self) -> int: ...
    def timeSpec(self) -> int: ...
    def time(self) -> QTime: ...
    def date(self) -> QDate: ...
    def isValid(self) -> bool: ...
    def __bool__(self) -> int: ...
    def isNull(self) -> bool: ...
    def toPyDateTime(self) -> datetime.datetime: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...


class QDeadlineTimer(sip.simplewrapper):

    ForeverConstant: typing.Type[int]
    #class ForeverConstant(int): ...
    Forever = ... # type: int

    @overload
    def __init__(self, type: int = ...) -> None: ...
    @overload
    def __init__(self, a0: int, type: int = ...) -> None: ...
    @overload
    def __init__(self, msecs: int, type: int = ...) -> None: ...
    @overload
    def __init__(self, a0: QDeadlineTimer) -> None: ...

    @staticmethod
    def current(type: int = ...) -> QDeadlineTimer: ...
    @staticmethod
    def addNSecs(dt: QDeadlineTimer, nsecs: int) -> QDeadlineTimer: ...
    def setPreciseDeadline(self, secs: int, nsecs: int = ..., type: int = ...) -> None: ...
    def setDeadline(self, msecs: int, type: int = ...) -> None: ...
    def deadlineNSecs(self) -> int: ...
    def deadline(self) -> int: ...
    def setPreciseRemainingTime(self, secs: int, nsecs: int = ..., type: int = ...) -> None: ...
    def setRemainingTime(self, msecs: int, type: int = ...) -> None: ...
    def remainingTimeNSecs(self) -> int: ...
    def remainingTime(self) -> int: ...
    def setTimerType(self, type: int) -> None: ...
    def timerType(self) -> int: ...
    def hasExpired(self) -> bool: ...
    def isForever(self) -> bool: ...
    def swap(self, other: QDeadlineTimer) -> None: ...


class QDir(sip.simplewrapper):

    SortFlag: typing.Type[int]
    #class SortFlag(int): ...
    Name = ... # type: int
    Time = ... # type: int
    Size = ... # type: int
    Unsorted = ... # type: int
    SortByMask = ... # type: int
    DirsFirst = ... # type: int
    Reversed = ... # type: int
    IgnoreCase = ... # type: int
    DirsLast = ... # type: int
    LocaleAware = ... # type: int
    Type = ... # type: int
    NoSort = ... # type: int

    Filter: typing.Type[int]
    #class Filter(int): ...
    Dirs = ... # type: int
    Files = ... # type: int
    Drives = ... # type: int
    NoSymLinks = ... # type: int
    AllEntries = ... # type: int
    TypeMask = ... # type: int
    Readable = ... # type: int
    Writable = ... # type: int
    Executable = ... # type: int
    PermissionMask = ... # type: int
    Modified = ... # type: int
    Hidden = ... # type: int
    System = ... # type: int
    AccessMask = ... # type: int
    AllDirs = ... # type: int
    CaseSensitive = ... # type: int
    NoDotAndDotDot = ... # type: int
    NoFilter = ... # type: int
    NoDot = ... # type: int
    NoDotDot = ... # type: int

    Filters: typing.Type[int]
    #class Filters(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QDir.Filters, QDir.Filter]) -> None: ...
        #@overload
        #def __init__(self, a0: QDir.Filters) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QDir.Filters: ...
        #def __int__(self) -> int: ...

    SortFlags: typing.Type[int]
    #class SortFlags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QDir.SortFlags, QDir.SortFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: QDir.SortFlags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QDir.SortFlags: ...
        #def __int__(self) -> int: ...

    @overload
    def __init__(self, a0: QDir) -> None: ...
    @overload
    def __init__(self, path: str = ...) -> None: ...
    @overload
    def __init__(self, path: str, nameFilter: str, sort: int = ..., filters: int = ...) -> None: ...

    def isEmpty(self, filters: typing.Union[int, int] = ...) -> bool: ...
    @staticmethod
    def listSeparator() -> str: ...
    def swap(self, other: QDir) -> None: ...
    def removeRecursively(self) -> bool: ...
    @staticmethod
    def searchPaths(prefix: str) -> typing.List[str]: ...
    @staticmethod
    def addSearchPath(prefix: str, path: str) -> None: ...
    @staticmethod
    def setSearchPaths(prefix: str, searchPaths: typing.Iterable[str]) -> None: ...
    @staticmethod
    def fromNativeSeparators(pathName: str) -> str: ...
    @staticmethod
    def toNativeSeparators(pathName: str) -> str: ...
    @staticmethod
    def cleanPath(path: str) -> str: ...
    @overload
    @staticmethod
    def match(filters: typing.Iterable[str], fileName: str) -> bool: ...
    @overload
    @staticmethod
    def match(filter: str, fileName: str) -> bool: ...
    @staticmethod
    def tempPath() -> str: ...
    @staticmethod
    def temp() -> QDir: ...
    @staticmethod
    def rootPath() -> str: ...
    @staticmethod
    def root() -> QDir: ...
    @staticmethod
    def homePath() -> str: ...
    @staticmethod
    def home() -> QDir: ...
    @staticmethod
    def currentPath() -> str: ...
    @staticmethod
    def current() -> QDir: ...
    @staticmethod
    def setCurrent(path: str) -> bool: ...
    @staticmethod
    def separator() -> str: ...
    @staticmethod
    def drives() -> typing.List[QFileInfo]: ...
    def refresh(self) -> None: ...
    def rename(self, oldName: str, newName: str) -> bool: ...
    def remove(self, fileName: str) -> bool: ...
    def makeAbsolute(self) -> bool: ...
    def isAbsolute(self) -> bool: ...
    def isRelative(self) -> bool: ...
    @staticmethod
    def isAbsolutePath(path: str) -> bool: ...
    @staticmethod
    def isRelativePath(path: str) -> bool: ...
    def isRoot(self) -> bool: ...
    @overload
    def exists(self) -> bool: ...
    @overload
    def exists(self, name: str) -> bool: ...
    def isReadable(self) -> bool: ...
    def rmpath(self, dirPath: str) -> bool: ...
    def mkpath(self, dirPath: str) -> bool: ...
    def rmdir(self, dirName: str) -> bool: ...
    def mkdir(self, dirName: str) -> bool: ...
    @overload
    def entryInfoList(self, filters: typing.Union[int, int] = ..., sort: typing.Union[int, int] = ...) -> typing.List[QFileInfo]: ...
    @overload
    def entryInfoList(self, nameFilters: typing.Iterable[str], filters: typing.Union[int, int] = ..., sort: typing.Union[int, int] = ...) -> typing.List[QFileInfo]: ...
    @overload
    def entryList(self, filters: typing.Union[int, int] = ..., sort: typing.Union[int, int] = ...) -> typing.List[str]: ...
    @overload
    def entryList(self, nameFilters: typing.Iterable[str], filters: typing.Union[int, int] = ..., sort: typing.Union[int, int] = ...) -> typing.List[str]: ...
    @staticmethod
    def nameFiltersFromString(nameFilter: str) -> typing.List[str]: ...
    def __contains__(self, a0: str) -> int: ...
    @overload
    def __getitem__(self, a0: int) -> str: ...
    @overload
    def __getitem__(self, a0: slice) -> typing.List[str]: ...
    def __len__(self) -> int: ...
    def count(self) -> int: ...
    def setSorting(self, sort: typing.Union[int, int]) -> None: ...
    def sorting(self) -> int: ...
    def setFilter(self, filter: typing.Union[int, int]) -> None: ...
    def filter(self) -> int: ...
    def setNameFilters(self, nameFilters: typing.Iterable[str]) -> None: ...
    def nameFilters(self) -> typing.List[str]: ...
    def cdUp(self) -> bool: ...
    def cd(self, dirName: str) -> bool: ...
    def relativeFilePath(self, fileName: str) -> str: ...
    def absoluteFilePath(self, fileName: str) -> str: ...
    def filePath(self, fileName: str) -> str: ...
    def dirName(self) -> str: ...
    def canonicalPath(self) -> str: ...
    def absolutePath(self) -> str: ...
    def path(self) -> str: ...
    def setPath(self, path: str) -> None: ...


class QDirIterator(sip.simplewrapper):

    IteratorFlag: typing.Type[int]
    #class IteratorFlag(int): ...
    NoIteratorFlags = ... # type: int
    FollowSymlinks = ... # type: int
    Subdirectories = ... # type: int

    IteratorFlags: typing.Type[int]
    #class IteratorFlags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QDirIterator.IteratorFlags, QDirIterator.IteratorFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: QDirIterator.IteratorFlags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QDirIterator.IteratorFlags: ...
        #def __int__(self) -> int: ...

    @overload
    def __init__(self, dir: QDir, flags: int = ...) -> None: ...
    @overload
    def __init__(self, path: str, flags: int = ...) -> None: ...
    @overload
    def __init__(self, path: str, filters: int, flags: int = ...) -> None: ...
    @overload
    def __init__(self, path: str, nameFilters: typing.Iterable[str], filters: int = ..., flags: int = ...) -> None: ...

    def path(self) -> str: ...
    def fileInfo(self) -> QFileInfo: ...
    def filePath(self) -> str: ...
    def fileName(self) -> str: ...
    def hasNext(self) -> bool: ...
    def next(self) -> str: ...


class QEasingCurve(sip.simplewrapper):

    Type: typing.Type[int]
    #class Type(int): ...
    Linear = ... # type: int
    InQuad = ... # type: int
    OutQuad = ... # type: int
    InOutQuad = ... # type: int
    OutInQuad = ... # type: int
    InCubic = ... # type: int
    OutCubic = ... # type: int
    InOutCubic = ... # type: int
    OutInCubic = ... # type: int
    InQuart = ... # type: int
    OutQuart = ... # type: int
    InOutQuart = ... # type: int
    OutInQuart = ... # type: int
    InQuint = ... # type: int
    OutQuint = ... # type: int
    InOutQuint = ... # type: int
    OutInQuint = ... # type: int
    InSine = ... # type: int
    OutSine = ... # type: int
    InOutSine = ... # type: int
    OutInSine = ... # type: int
    InExpo = ... # type: int
    OutExpo = ... # type: int
    InOutExpo = ... # type: int
    OutInExpo = ... # type: int
    InCirc = ... # type: int
    OutCirc = ... # type: int
    InOutCirc = ... # type: int
    OutInCirc = ... # type: int
    InElastic = ... # type: int
    OutElastic = ... # type: int
    InOutElastic = ... # type: int
    OutInElastic = ... # type: int
    InBack = ... # type: int
    OutBack = ... # type: int
    InOutBack = ... # type: int
    OutInBack = ... # type: int
    InBounce = ... # type: int
    OutBounce = ... # type: int
    InOutBounce = ... # type: int
    OutInBounce = ... # type: int
    InCurve = ... # type: int
    OutCurve = ... # type: int
    SineCurve = ... # type: int
    CosineCurve = ... # type: int
    BezierSpline = ... # type: int
    TCBSpline = ... # type: int
    Custom = ... # type: int

    @overload
    def __init__(self, type: int = ...) -> None: ...
    @overload
    def __init__(self, other: typing.Union[QEasingCurve, int]) -> None: ...

    def toCubicSpline(self) -> typing.List[QPointF]: ...
    def addTCBSegment(self, nextPoint: typing.Union[QPointF, QPoint], t: float, c: float, b: float) -> None: ...
    def addCubicBezierSegment(self, c1: typing.Union[QPointF, QPoint], c2: typing.Union[QPointF, QPoint], endPoint: typing.Union[QPointF, QPoint]) -> None: ...
    def swap(self, other: QEasingCurve) -> None: ...
    def valueForProgress(self, progress: float) -> float: ...
    def customType(self) -> typing.Callable[[float], float]: ...
    def setCustomType(self, func: typing.Callable[[float], float]) -> None: ...
    def setType(self, type: int) -> None: ...
    def type(self) -> int: ...
    def setOvershoot(self, overshoot: float) -> None: ...
    def overshoot(self) -> float: ...
    def setPeriod(self, period: float) -> None: ...
    def period(self) -> float: ...
    def setAmplitude(self, amplitude: float) -> None: ...
    def amplitude(self) -> float: ...


class QElapsedTimer(sip.simplewrapper):

    ClockType: typing.Type[int]
    #class ClockType(int): ...
    SystemTime = ... # type: int
    MonotonicClock = ... # type: int
    TickCounter = ... # type: int
    MachAbsoluteTime = ... # type: int
    PerformanceCounter = ... # type: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QElapsedTimer) -> None: ...

    def nsecsElapsed(self) -> int: ...
    def secsTo(self, other: QElapsedTimer) -> int: ...
    def msecsTo(self, other: QElapsedTimer) -> int: ...
    def msecsSinceReference(self) -> int: ...
    def hasExpired(self, timeout: int) -> bool: ...
    def elapsed(self) -> int: ...
    def isValid(self) -> bool: ...
    def invalidate(self) -> None: ...
    def restart(self) -> int: ...
    def start(self) -> None: ...
    @staticmethod
    def isMonotonic() -> bool: ...
    @staticmethod
    def clockType() -> int: ...


class QEventLoop(QObject):

    ProcessEventsFlag: typing.Type[int]
    #class ProcessEventsFlag(int): ...
    AllEvents = ... # type: int
    ExcludeUserInputEvents = ... # type: int
    ExcludeSocketNotifiers = ... # type: int
    WaitForMoreEvents = ... # type: int
    X11ExcludeTimers = ... # type: int

    ProcessEventsFlags: typing.Type[int]
    #class ProcessEventsFlags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QEventLoop.ProcessEventsFlags, QEventLoop.ProcessEventsFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: QEventLoop.ProcessEventsFlags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QEventLoop.ProcessEventsFlags: ...
        #def __int__(self) -> int: ...

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def event(self, event: QEvent) -> bool: ...
    def quit(self) -> None: ...
    def wakeUp(self) -> None: ...
    def isRunning(self) -> bool: ...
    def exit(self, returnCode: int = ...) -> None: ...
    def exec(self, flags: int = ...) -> int: ...
    def exec_(self, flags: int = ...) -> int: ...
    @overload
    def processEvents(self, flags: typing.Union[int, int] = ...) -> bool: ...
    @overload
    def processEvents(self, flags: typing.Union[int, int], maximumTime: int) -> None: ...


class QEventLoopLocker(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, loop: QEventLoop) -> None: ...
    @overload
    def __init__(self, thread: QThread) -> None: ...


class QEventTransition(QAbstractTransition):

    @overload
    def __init__(self, sourceState: typing.Optional[QState] = ..., **props) -> None: ...
    @overload
    def __init__(self, object: QObject, type: int, sourceState: typing.Optional[QState] = ..., **props) -> None: ...

    def event(self, e: QEvent) -> bool: ...
    def onTransition(self, event: QEvent) -> None: ...
    def eventTest(self, event: QEvent) -> bool: ...
    def setEventType(self, type: int) -> None: ...
    def eventType(self) -> int: ...
    def setEventSource(self, object: QObject) -> None: ...
    def eventSource(self) -> QObject: ...


class QFileDevice(QIODevice):

    FileTime: typing.Type[int]
    #class FileTime(int): ...
    FileAccessTime = ... # type: int
    FileBirthTime = ... # type: int
    FileMetadataChangeTime = ... # type: int
    FileModificationTime = ... # type: int

    MemoryMapFlags: typing.Type[int]
    #class MemoryMapFlags(int): ...
    NoOptions = ... # type: int
    MapPrivateOption = ... # type: int

    FileHandleFlag: typing.Type[int]
    #class FileHandleFlag(int): ...
    AutoCloseHandle = ... # type: int
    DontCloseHandle = ... # type: int

    Permission: typing.Type[int]
    #class Permission(int): ...
    ReadOwner = ... # type: int
    WriteOwner = ... # type: int
    ExeOwner = ... # type: int
    ReadUser = ... # type: int
    WriteUser = ... # type: int
    ExeUser = ... # type: int
    ReadGroup = ... # type: int
    WriteGroup = ... # type: int
    ExeGroup = ... # type: int
    ReadOther = ... # type: int
    WriteOther = ... # type: int
    ExeOther = ... # type: int

    FileError: typing.Type[int]
    #class FileError(int): ...
    NoError = ... # type: int
    ReadError = ... # type: int
    WriteError = ... # type: int
    FatalError = ... # type: int
    ResourceError = ... # type: int
    OpenError = ... # type: int
    AbortError = ... # type: int
    TimeOutError = ... # type: int
    UnspecifiedError = ... # type: int
    RemoveError = ... # type: int
    RenameError = ... # type: int
    PositionError = ... # type: int
    ResizeError = ... # type: int
    PermissionsError = ... # type: int
    CopyError = ... # type: int

    Permissions: typing.Type[int]
    #class Permissions(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QFileDevice.Permissions, QFileDevice.Permission]) -> None: ...
        #@overload
        #def __init__(self, a0: QFileDevice.Permissions) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QFileDevice.Permissions: ...
        #def __int__(self) -> int: ...

    FileHandleFlags: typing.Type[int]
    #class FileHandleFlags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QFileDevice.FileHandleFlags, QFileDevice.FileHandleFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: QFileDevice.FileHandleFlags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QFileDevice.FileHandleFlags: ...
        #def __int__(self) -> int: ...

    def setFileTime(self, newDate: typing.Union[QDateTime, datetime.datetime], fileTime: int) -> bool: ...
    def fileTime(self, time: int) -> QDateTime: ...
    def readLineData(self, maxlen: int) -> bytes: ...
    def writeData(self, data: bytes) -> int: ...
    def readData(self, maxlen: int) -> bytes: ...
    def unmap(self, address: sip.voidptr) -> bool: ...
    def map(self, offset: int, size: int, flags: int = ...) -> sip.voidptr: ...
    def setPermissions(self, permissionSpec: typing.Union[int, int]) -> bool: ...
    def permissions(self) -> int: ...
    def resize(self, sz: int) -> bool: ...
    def size(self) -> int: ...
    def flush(self) -> bool: ...
    def atEnd(self) -> bool: ...
    def seek(self, offset: int) -> bool: ...
    def pos(self) -> int: ...
    def fileName(self) -> str: ...
    def handle(self) -> int: ...
    def isSequential(self) -> bool: ...
    def close(self) -> None: ...
    def unsetError(self) -> None: ...
    def error(self) -> int: ...


class QFile(QFileDevice):

    @overload
    def __init__(self, **props) -> None: ...
    @overload
    def __init__(self, name: str, **props) -> None: ...
    @overload
    def __init__(self, parent: QObject, **props) -> None: ...
    @overload
    def __init__(self, name: str, parent: QObject, **props) -> None: ...

    @overload
    def setPermissions(self, permissionSpec: typing.Union[int, int]) -> bool: ...
    #@overload
    #@staticmethod
    #def setPermissions(filename: str, permissionSpec: typing.Union[int, int]) -> bool: ...
    @overload
    def permissions(self) -> int: ...
    #@overload
    #@staticmethod
    #def permissions(filename: str) -> int: ...
    @overload
    def resize(self, sz: int) -> bool: ...
    #@overload
    #@staticmethod
    #def resize(filename: str, sz: int) -> bool: ...
    def size(self) -> int: ...
    @overload
    def open(self, flags: typing.Union[int, int]) -> bool: ...
    @overload
    def open(self, fd: int, ioFlags: typing.Union[int, int], handleFlags: typing.Union[int, int] = ...) -> bool: ...
    @overload
    def copy(self, newName: str) -> bool: ...
    #@overload
    #@staticmethod
    #def copy(fileName: str, newName: str) -> bool: ...
    @overload
    def link(self, newName: str) -> bool: ...
    #@overload
    #@staticmethod
    #def link(oldname: str, newName: str) -> bool: ...
    @overload
    def rename(self, newName: str) -> bool: ...
    #@overload
    #@staticmethod
    #def rename(oldName: str, newName: str) -> bool: ...
    @overload
    def remove(self) -> bool: ...
    #@overload
    #@staticmethod
    #def remove(fileName: str) -> bool: ...
    @overload
    def symLinkTarget(self) -> str: ...
    #@overload
    #@staticmethod
    #def symLinkTarget(fileName: str) -> str: ...
    #@overload
    #def exists(self) -> bool: ...
    @overload
    @staticmethod
    def exists(fileName: str) -> bool: ...
    @overload
    @staticmethod
    def decodeName(localFileName: typing.Union[QByteArray, bytes, bytearray]) -> str: ...
    @overload
    @staticmethod
    def decodeName(localFileName: str) -> str: ...
    @staticmethod
    def encodeName(fileName: str) -> QByteArray: ...
    def setFileName(self, name: str) -> None: ...
    def fileName(self) -> str: ...


class QFileInfo(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, file: str) -> None: ...
    @overload
    def __init__(self, file: QFile) -> None: ...
    @overload
    def __init__(self, dir: QDir, file: str) -> None: ...
    @overload
    def __init__(self, fileinfo: QFileInfo) -> None: ...

    def fileTime(self, time: int) -> QDateTime: ...
    def metadataChangeTime(self) -> QDateTime: ...
    def birthTime(self) -> QDateTime: ...
    def swap(self, other: QFileInfo) -> None: ...
    def isNativePath(self) -> bool: ...
    def isBundle(self) -> bool: ...
    def bundleName(self) -> str: ...
    def symLinkTarget(self) -> str: ...
    def setCaching(self, on: bool) -> None: ...
    def caching(self) -> bool: ...
    def lastRead(self) -> QDateTime: ...
    def lastModified(self) -> QDateTime: ...
    def created(self) -> QDateTime: ...
    def size(self) -> int: ...
    def permissions(self) -> int: ...
    def permission(self, permissions: typing.Union[int, int]) -> bool: ...
    def groupId(self) -> int: ...
    def group(self) -> str: ...
    def ownerId(self) -> int: ...
    def owner(self) -> str: ...
    def isRoot(self) -> bool: ...
    def isSymLink(self) -> bool: ...
    def isDir(self) -> bool: ...
    def isFile(self) -> bool: ...
    def makeAbsolute(self) -> bool: ...
    def isAbsolute(self) -> bool: ...
    def isRelative(self) -> bool: ...
    def isHidden(self) -> bool: ...
    def isExecutable(self) -> bool: ...
    def isWritable(self) -> bool: ...
    def isReadable(self) -> bool: ...
    def absoluteDir(self) -> QDir: ...
    def dir(self) -> QDir: ...
    def canonicalPath(self) -> str: ...
    def absolutePath(self) -> str: ...
    def path(self) -> str: ...
    def completeSuffix(self) -> str: ...
    def suffix(self) -> str: ...
    def completeBaseName(self) -> str: ...
    def baseName(self) -> str: ...
    def fileName(self) -> str: ...
    def canonicalFilePath(self) -> str: ...
    def absoluteFilePath(self) -> str: ...
    def __fspath__(self) -> typing.Any: ...
    def filePath(self) -> str: ...
    def refresh(self) -> None: ...
    @overload
    def exists(self) -> bool: ...
    #@overload
    #@staticmethod
    #def exists(file: str) -> bool: ...
    @overload
    def setFile(self, file: str) -> None: ...
    @overload
    def setFile(self, file: QFile) -> None: ...
    @overload
    def setFile(self, dir: QDir, file: str) -> None: ...


class QFileSelector(QObject):

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def allSelectors(self) -> typing.List[str]: ...
    def setExtraSelectors(self, list: typing.Iterable[str]) -> None: ...
    def extraSelectors(self) -> typing.List[str]: ...
    @overload
    def select(self, filePath: str) -> str: ...
    @overload
    def select(self, filePath: QUrl) -> QUrl: ...


class QFileSystemWatcher(QObject):

    directoryChanged: PYQT_SIGNAL
    fileChanged: PYQT_SIGNAL

    @overload
    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, paths: typing.Iterable[str], parent: typing.Optional[QObject] = ..., **props) -> None: ...

    #def fileChanged(self, path: str) -> None: ...
    #def directoryChanged(self, path: str) -> None: ...
    def removePaths(self, files: typing.Iterable[str]) -> typing.List[str]: ...
    def removePath(self, file: str) -> bool: ...
    def files(self) -> typing.List[str]: ...
    def directories(self) -> typing.List[str]: ...
    def addPaths(self, files: typing.Iterable[str]) -> typing.List[str]: ...
    def addPath(self, file: str) -> bool: ...


class QFinalState(QAbstractState):

    def __init__(self, parent: typing.Optional[QState] = ..., **props) -> None: ...

    def event(self, e: QEvent) -> bool: ...
    def onExit(self, event: QEvent) -> None: ...
    def onEntry(self, event: QEvent) -> None: ...


class QHistoryState(QAbstractState):

    defaultStateChanged: PYQT_SIGNAL
    defaultTransitionChanged: PYQT_SIGNAL
    historyTypeChanged: PYQT_SIGNAL

    HistoryType: typing.Type[int]
    #class HistoryType(int): ...
    ShallowHistory = ... # type: int
    DeepHistory = ... # type: int

    @overload
    def __init__(self, parent: typing.Optional[QState] = ..., **props) -> None: ...
    @overload
    def __init__(self, type: int, parent: typing.Optional[QState] = ..., **props) -> None: ...

    #def defaultTransitionChanged(self) -> None: ...
    def setDefaultTransition(self, transition: QAbstractTransition) -> None: ...
    def defaultTransition(self) -> QAbstractTransition: ...
    #def historyTypeChanged(self) -> None: ...
    #def defaultStateChanged(self) -> None: ...
    def event(self, e: QEvent) -> bool: ...
    def onExit(self, event: QEvent) -> None: ...
    def onEntry(self, event: QEvent) -> None: ...
    def setHistoryType(self, type: int) -> None: ...
    def historyType(self) -> int: ...
    def setDefaultState(self, state: QAbstractState) -> None: ...
    def defaultState(self) -> QAbstractState: ...


class QIdentityProxyModel(QAbstractProxyModel):

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def sibling(self, row: int, column: int, idx: QModelIndex) -> QModelIndex: ...
    def headerData(self, section: int, orientation: int, role: int = ...) -> typing.Any: ...
    def removeRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def removeColumns(self, column: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def insertRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def insertColumns(self, column: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def setSourceModel(self, sourceModel: QAbstractItemModel) -> None: ...
    def match(self, start: QModelIndex, role: int, value: typing.Any, hits: int = ..., flags: typing.Union[int, int] = ...) -> typing.List[QModelIndex]: ...
    def mapSelectionToSource(self, selection: QItemSelection) -> QItemSelection: ...
    def mapSelectionFromSource(self, selection: QItemSelection) -> QItemSelection: ...
    def dropMimeData(self, data: QMimeData, action: int, row: int, column: int, parent: QModelIndex) -> bool: ...
    def rowCount(self, parent: QModelIndex = ...) -> int: ...
    def parent(self, child: QModelIndex) -> QModelIndex: ...
    def mapToSource(self, proxyIndex: QModelIndex) -> QModelIndex: ...
    def mapFromSource(self, sourceIndex: QModelIndex) -> QModelIndex: ...
    def index(self, row: int, column: int, parent: QModelIndex = ...) -> QModelIndex: ...
    def columnCount(self, parent: QModelIndex = ...) -> int: ...


class QItemSelectionRange(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: QItemSelectionRange) -> None: ...
    @overload
    def __init__(self, atopLeft: QModelIndex, abottomRight: QModelIndex) -> None: ...
    @overload
    def __init__(self, index: QModelIndex) -> None: ...

    def swap(self, other: QItemSelectionRange) -> None: ...
    def isEmpty(self) -> bool: ...
    def __hash__(self) -> int: ...
    def intersected(self, other: QItemSelectionRange) -> QItemSelectionRange: ...
    def indexes(self) -> typing.List[QModelIndex]: ...
    def isValid(self) -> bool: ...
    def intersects(self, other: QItemSelectionRange) -> bool: ...
    @overload
    def contains(self, index: QModelIndex) -> bool: ...
    @overload
    def contains(self, row: int, column: int, parentIndex: QModelIndex) -> bool: ...
    def model(self) -> QAbstractItemModel: ...
    def parent(self) -> QModelIndex: ...
    def bottomRight(self) -> QPersistentModelIndex: ...
    def topLeft(self) -> QPersistentModelIndex: ...
    def height(self) -> int: ...
    def width(self) -> int: ...
    def right(self) -> int: ...
    def bottom(self) -> int: ...
    def left(self) -> int: ...
    def top(self) -> int: ...


class QItemSelectionModel(QObject):

    currentChanged: PYQT_SIGNAL
    currentColumnChanged: PYQT_SIGNAL
    currentRowChanged: PYQT_SIGNAL
    modelChanged: PYQT_SIGNAL
    selectionChanged: PYQT_SIGNAL

    SelectionFlag: typing.Type[int]
    #class SelectionFlag(int): ...
    NoUpdate = ... # type: int
    Clear = ... # type: int
    Select = ... # type: int
    Deselect = ... # type: int
    Toggle = ... # type: int
    Current = ... # type: int
    Rows = ... # type: int
    Columns = ... # type: int
    SelectCurrent = ... # type: int
    ToggleCurrent = ... # type: int
    ClearAndSelect = ... # type: int

    SelectionFlags: typing.Type[int]
    #class SelectionFlags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QItemSelectionModel.SelectionFlags, QItemSelectionModel.SelectionFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: QItemSelectionModel.SelectionFlags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QItemSelectionModel.SelectionFlags: ...
        #def __int__(self) -> int: ...

    @overload
    def __init__(self, model: typing.Optional[QAbstractItemModel] = ..., **props) -> None: ...
    @overload
    def __init__(self, model: QAbstractItemModel, parent: QObject, **props) -> None: ...

    #def modelChanged(self, model: QAbstractItemModel) -> None: ...
    def setModel(self, model: QAbstractItemModel) -> None: ...
    def selectedColumns(self, row: int = ...) -> typing.List[QModelIndex]: ...
    def selectedRows(self, column: int = ...) -> typing.List[QModelIndex]: ...
    def hasSelection(self) -> bool: ...
    def emitSelectionChanged(self, newSelection: QItemSelection, oldSelection: QItemSelection) -> None: ...
    #def currentColumnChanged(self, current: QModelIndex, previous: QModelIndex) -> None: ...
    #def currentRowChanged(self, current: QModelIndex, previous: QModelIndex) -> None: ...
    #def currentChanged(self, current: QModelIndex, previous: QModelIndex) -> None: ...
    #def selectionChanged(self, selected: QItemSelection, deselected: QItemSelection) -> None: ...
    def clearCurrentIndex(self) -> None: ...
    def setCurrentIndex(self, index: QModelIndex, command: typing.Union[int, int]) -> None: ...
    @overload
    def select(self, index: QModelIndex, command: typing.Union[int, int]) -> None: ...
    @overload
    def select(self, selection: QItemSelection, command: typing.Union[int, int]) -> None: ...
    def reset(self) -> None: ...
    def clearSelection(self) -> None: ...
    def clear(self) -> None: ...
    def model(self) -> QAbstractItemModel: ...
    def selection(self) -> QItemSelection: ...
    def selectedIndexes(self) -> typing.List[QModelIndex]: ...
    def columnIntersectsSelection(self, column: int, parent: QModelIndex) -> bool: ...
    def rowIntersectsSelection(self, row: int, parent: QModelIndex) -> bool: ...
    def isColumnSelected(self, column: int, parent: QModelIndex) -> bool: ...
    def isRowSelected(self, row: int, parent: QModelIndex) -> bool: ...
    def isSelected(self, index: QModelIndex) -> bool: ...
    def currentIndex(self) -> QModelIndex: ...


class QItemSelection(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, topLeft: QModelIndex, bottomRight: QModelIndex) -> None: ...
    @overload
    def __init__(self, a0: QItemSelection) -> None: ...

    def lastIndexOf(self, value: QItemSelectionRange, from_: int = ...) -> int: ...
    def indexOf(self, value: QItemSelectionRange, from_: int = ...) -> int: ...
    def last(self) -> QItemSelectionRange: ...
    def first(self) -> QItemSelectionRange: ...
    def __len__(self) -> int: ...
    @overload
    def count(self, range: QItemSelectionRange) -> int: ...
    @overload
    def count(self) -> int: ...
    def swap(self, i: int, j: int) -> None: ...
    def move(self, from_: int, to: int) -> None: ...
    def takeLast(self) -> QItemSelectionRange: ...
    def takeFirst(self) -> QItemSelectionRange: ...
    def takeAt(self, i: int) -> QItemSelectionRange: ...
    def removeAll(self, range: QItemSelectionRange) -> int: ...
    def removeAt(self, i: int) -> None: ...
    def replace(self, i: int, range: QItemSelectionRange) -> None: ...
    def insert(self, i: int, range: QItemSelectionRange) -> None: ...
    def prepend(self, range: QItemSelectionRange) -> None: ...
    def append(self, range: QItemSelectionRange) -> None: ...
    def isEmpty(self) -> bool: ...
    def clear(self) -> None: ...
    @overload
    def __getitem__(self, i: int) -> QItemSelectionRange: ...
    @overload
    def __getitem__(self, slice: slice) -> QItemSelection: ...
    @overload
    def __delitem__(self, i: int) -> None: ...
    @overload
    def __delitem__(self, slice: slice) -> None: ...
    @overload
    def __setitem__(self, i: int, range: QItemSelectionRange) -> None: ...
    @overload
    def __setitem__(self, slice: slice, list: QItemSelection) -> None: ...
    @staticmethod
    def split(range: QItemSelectionRange, other: QItemSelectionRange, result: QItemSelection) -> None: ...
    def merge(self, other: QItemSelection, command: typing.Union[int, int]) -> None: ...
    def indexes(self) -> typing.List[QModelIndex]: ...
    def __contains__(self, index: QModelIndex) -> int: ...
    def contains(self, index: QModelIndex) -> bool: ...
    def select(self, topLeft: QModelIndex, bottomRight: QModelIndex) -> None: ...


class QJsonParseError(sip.simplewrapper):

    ParseError: typing.Type[int]
    #class ParseError(int): ...
    NoError = ... # type: int
    UnterminatedObject = ... # type: int
    MissingNameSeparator = ... # type: int
    UnterminatedArray = ... # type: int
    MissingValueSeparator = ... # type: int
    IllegalValue = ... # type: int
    TerminationByNumber = ... # type: int
    IllegalNumber = ... # type: int
    IllegalEscapeSequence = ... # type: int
    IllegalUTF8String = ... # type: int
    UnterminatedString = ... # type: int
    MissingObject = ... # type: int
    DeepNesting = ... # type: int
    DocumentTooLarge = ... # type: int
    GarbageAtEnd = ... # type: int

    error = ... # type: int
    offset = ... # type: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QJsonParseError) -> None: ...

    def errorString(self) -> str: ...


class QJsonDocument(sip.simplewrapper):

    JsonFormat: typing.Type[int]
    #class JsonFormat(int): ...
    Indented = ... # type: int
    Compact = ... # type: int

    DataValidation: typing.Type[int]
    #class DataValidation(int): ...
    Validate = ... # type: int
    BypassValidation = ... # type: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, object: typing.Dict[str, QJsonValue]) -> None: ...
    @overload
    def __init__(self, array: typing.Iterable[typing.Union[QJsonValue, int, typing.Dict[str, QJsonValue], bool, int, float, str]]) -> None: ...
    @overload
    def __init__(self, other: QJsonDocument) -> None: ...

    @overload
    def __getitem__(self, key: str) -> QJsonValue: ...
    @overload
    def __getitem__(self, i: int) -> QJsonValue: ...
    def swap(self, other: QJsonDocument) -> None: ...
    def isNull(self) -> bool: ...
    def setArray(self, array: typing.Iterable[typing.Union[QJsonValue, int, typing.Dict[str, QJsonValue], bool, int, float, str]]) -> None: ...
    def setObject(self, object: typing.Dict[str, QJsonValue]) -> None: ...
    def array(self) -> typing.List[QJsonValue]: ...
    def object(self) -> typing.Dict[str, QJsonValue]: ...
    def isObject(self) -> bool: ...
    def isArray(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    @overload
    def toJson(self) -> QByteArray: ...
    @overload
    def toJson(self, format: int) -> QByteArray: ...
    @staticmethod
    def fromJson(json: typing.Union[QByteArray, bytes, bytearray], error: typing.Optional[QJsonParseError] = ...) -> QJsonDocument: ...
    def toVariant(self) -> typing.Any: ...
    @staticmethod
    def fromVariant(variant: typing.Any) -> QJsonDocument: ...
    def toBinaryData(self) -> QByteArray: ...
    @staticmethod
    def fromBinaryData(data: typing.Union[QByteArray, bytes, bytearray], validation: int = ...) -> QJsonDocument: ...
    def rawData(self) -> typing.Tuple[str, int]: ...
    @staticmethod
    def fromRawData(data: str, size: int, validation: int = ...) -> QJsonDocument: ...


class QJsonValue(sip.simplewrapper):

    Type: typing.Type[int]
    #class Type(int): ...
    Null = ... # type: int
    Bool = ... # type: int
    Double = ... # type: int
    String = ... # type: int
    Array = ... # type: int
    Object = ... # type: int
    Undefined = ... # type: int

    @overload
    def __init__(self, type: int = ...) -> None: ...
    @overload
    def __init__(self, other: typing.Union[QJsonValue, int, typing.Dict[str, QJsonValue], bool, int, float, str]) -> None: ...

    def __hash__(self) -> int: ...
    @overload
    def __getitem__(self, key: str) -> QJsonValue: ...
    @overload
    def __getitem__(self, i: int) -> QJsonValue: ...
    def swap(self, other: QJsonValue) -> None: ...
    @overload
    def toString(self) -> str: ...
    @overload
    def toString(self, defaultValue: str) -> str: ...
    @overload
    def toObject(self) -> typing.Dict[str, QJsonValue]: ...
    @overload
    def toObject(self, defaultValue: typing.Dict[str, QJsonValue]) -> typing.Dict[str, QJsonValue]: ...
    @overload
    def toArray(self) -> typing.List[QJsonValue]: ...
    @overload
    def toArray(self, defaultValue: typing.Iterable[typing.Union[QJsonValue, int, typing.Dict[str, QJsonValue], bool, int, float, str]]) -> typing.List[QJsonValue]: ...
    def toDouble(self, defaultValue: float = ...) -> float: ...
    def toInt(self, defaultValue: int = ...) -> int: ...
    def toBool(self, defaultValue: bool = ...) -> bool: ...
    def isUndefined(self) -> bool: ...
    def isObject(self) -> bool: ...
    def isArray(self) -> bool: ...
    def isString(self) -> bool: ...
    def isDouble(self) -> bool: ...
    def isBool(self) -> bool: ...
    def isNull(self) -> bool: ...
    def type(self) -> int: ...
    def toVariant(self) -> typing.Any: ...
    @staticmethod
    def fromVariant(variant: typing.Any) -> QJsonValue: ...


class QLibrary(QObject):

    LoadHint: typing.Type[int]
    #class LoadHint(int): ...
    ResolveAllSymbolsHint = ... # type: int
    ExportExternalSymbolsHint = ... # type: int
    LoadArchiveMemberHint = ... # type: int
    PreventUnloadHint = ... # type: int
    DeepBindHint = ... # type: int

    LoadHints: typing.Type[int]
    #class LoadHints(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QLibrary.LoadHints, QLibrary.LoadHint]) -> None: ...
        #@overload
        #def __init__(self, a0: QLibrary.LoadHints) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QLibrary.LoadHints: ...
        #def __int__(self) -> int: ...

    @overload
    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, fileName: str, parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, fileName: str, verNum: int, parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, fileName: str, version: str, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def setLoadHints(self, hints: typing.Union[int, int]) -> None: ...
    @overload
    def setFileNameAndVersion(self, fileName: str, verNum: int) -> None: ...
    @overload
    def setFileNameAndVersion(self, fileName: str, version: str) -> None: ...
    def setFileName(self, fileName: str) -> None: ...
    @staticmethod
    def isLibrary(fileName: str) -> bool: ...
    def unload(self) -> bool: ...
    @overload
    def resolve(self, symbol: str) -> sip.voidptr: ...
    #@overload
    #@staticmethod
    #def resolve(fileName: str, symbol: str) -> sip.voidptr: ...
    #@overload
    #@staticmethod
    #def resolve(fileName: str, verNum: int, symbol: str) -> sip.voidptr: ...
    #@overload
    #@staticmethod
    #def resolve(fileName: str, version: str, symbol: str) -> sip.voidptr: ...
    def loadHints(self) -> int: ...
    def load(self) -> bool: ...
    def isLoaded(self) -> bool: ...
    def fileName(self) -> str: ...
    def errorString(self) -> str: ...


class QLibraryInfo(sip.simplewrapper):

    LibraryLocation: typing.Type[int]
    #class LibraryLocation(int): ...
    PrefixPath = ... # type: int
    DocumentationPath = ... # type: int
    HeadersPath = ... # type: int
    LibrariesPath = ... # type: int
    BinariesPath = ... # type: int
    PluginsPath = ... # type: int
    DataPath = ... # type: int
    TranslationsPath = ... # type: int
    SettingsPath = ... # type: int
    ExamplesPath = ... # type: int
    ImportsPath = ... # type: int
    TestsPath = ... # type: int
    LibraryExecutablesPath = ... # type: int
    Qml2ImportsPath = ... # type: int
    ArchDataPath = ... # type: int

    def __init__(self, a0: QLibraryInfo) -> None: ...

    @staticmethod
    def version() -> QVersionNumber: ...
    @staticmethod
    def isDebugBuild() -> bool: ...
    @staticmethod
    def buildDate() -> QDate: ...
    @staticmethod
    def location(a0: int) -> str: ...
    @staticmethod
    def licensedProducts() -> str: ...
    @staticmethod
    def licensee() -> str: ...


class QLine(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pt1_: QPoint, pt2_: QPoint) -> None: ...
    @overload
    def __init__(self, x1pos: int, y1pos: int, x2pos: int, y2pos: int) -> None: ...
    @overload
    def __init__(self, a0: QLine) -> None: ...

    def center(self) -> QPoint: ...
    def setLine(self, aX1: int, aY1: int, aX2: int, aY2: int) -> None: ...
    def setPoints(self, aP1: QPoint, aP2: QPoint) -> None: ...
    def setP2(self, aP2: QPoint) -> None: ...
    def setP1(self, aP1: QPoint) -> None: ...
    @overload
    def translated(self, p: QPoint) -> QLine: ...
    @overload
    def translated(self, adx: int, ady: int) -> QLine: ...
    @overload
    def translate(self, point: QPoint) -> None: ...
    @overload
    def translate(self, adx: int, ady: int) -> None: ...
    def dy(self) -> int: ...
    def dx(self) -> int: ...
    def p2(self) -> QPoint: ...
    def p1(self) -> QPoint: ...
    def y2(self) -> int: ...
    def x2(self) -> int: ...
    def y1(self) -> int: ...
    def x1(self) -> int: ...
    def __bool__(self) -> int: ...
    def isNull(self) -> bool: ...
    def __repr__(self) -> str: ...


class QLineF(sip.simplewrapper):

    IntersectType: typing.Type[int]
    #class IntersectType(int): ...
    NoIntersection = ... # type: int
    BoundedIntersection = ... # type: int
    UnboundedIntersection = ... # type: int

    @overload
    def __init__(self, line: QLine) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, apt1: typing.Union[QPointF, QPoint], apt2: typing.Union[QPointF, QPoint]) -> None: ...
    @overload
    def __init__(self, x1pos: float, y1pos: float, x2pos: float, y2pos: float) -> None: ...
    @overload
    def __init__(self, a0: QLineF) -> None: ...

    def center(self) -> QPointF: ...
    def setLine(self, aX1: float, aY1: float, aX2: float, aY2: float) -> None: ...
    def setPoints(self, aP1: typing.Union[QPointF, QPoint], aP2: typing.Union[QPointF, QPoint]) -> None: ...
    def setP2(self, aP2: typing.Union[QPointF, QPoint]) -> None: ...
    def setP1(self, aP1: typing.Union[QPointF, QPoint]) -> None: ...
    @overload
    def translated(self, p: typing.Union[QPointF, QPoint]) -> QLineF: ...
    @overload
    def translated(self, adx: float, ady: float) -> QLineF: ...
    def angleTo(self, l: QLineF) -> float: ...
    def setAngle(self, angle: float) -> None: ...
    def angle(self) -> float: ...
    @staticmethod
    def fromPolar(length: float, angle: float) -> QLineF: ...
    def toLine(self) -> QLine: ...
    def pointAt(self, t: float) -> QPointF: ...
    def setLength(self, len: float) -> None: ...
    @overload
    def translate(self, point: typing.Union[QPointF, QPoint]) -> None: ...
    @overload
    def translate(self, adx: float, ady: float) -> None: ...
    def normalVector(self) -> QLineF: ...
    def dy(self) -> float: ...
    def dx(self) -> float: ...
    def p2(self) -> QPointF: ...
    def p1(self) -> QPointF: ...
    def y2(self) -> float: ...
    def x2(self) -> float: ...
    def y1(self) -> float: ...
    def x1(self) -> float: ...
    def __repr__(self) -> str: ...
    def intersect(self, l: QLineF, intersectionPoint: typing.Union[QPointF, QPoint]) -> int: ...
    def unitVector(self) -> QLineF: ...
    def length(self) -> float: ...
    def __bool__(self) -> int: ...
    def isNull(self) -> bool: ...


class QLocale(sip.simplewrapper):

    DataSizeFormat: typing.Type[int]
    #class DataSizeFormat(int): ...
    DataSizeIecFormat = ... # type: int
    DataSizeTraditionalFormat = ... # type: int
    DataSizeSIFormat = ... # type: int

    FloatingPointPrecisionOption: typing.Type[int]
    #class FloatingPointPrecisionOption(int): ...
    FloatingPointShortest = ... # type: int

    QuotationStyle: typing.Type[int]
    #class QuotationStyle(int): ...
    StandardQuotation = ... # type: int
    AlternateQuotation = ... # type: int

    CurrencySymbolFormat: typing.Type[int]
    #class CurrencySymbolFormat(int): ...
    CurrencyIsoCode = ... # type: int
    CurrencySymbol = ... # type: int
    CurrencyDisplayName = ... # type: int

    Script: typing.Type[int]
    #class Script(int): ...
    AnyScript = ... # type: int
    ArabicScript = ... # type: int
    CyrillicScript = ... # type: int
    DeseretScript = ... # type: int
    GurmukhiScript = ... # type: int
    SimplifiedHanScript = ... # type: int
    TraditionalHanScript = ... # type: int
    LatinScript = ... # type: int
    MongolianScript = ... # type: int
    TifinaghScript = ... # type: int
    SimplifiedChineseScript = ... # type: int
    TraditionalChineseScript = ... # type: int
    ArmenianScript = ... # type: int
    BengaliScript = ... # type: int
    CherokeeScript = ... # type: int
    DevanagariScript = ... # type: int
    EthiopicScript = ... # type: int
    GeorgianScript = ... # type: int
    GreekScript = ... # type: int
    GujaratiScript = ... # type: int
    HebrewScript = ... # type: int
    JapaneseScript = ... # type: int
    KhmerScript = ... # type: int
    KannadaScript = ... # type: int
    KoreanScript = ... # type: int
    LaoScript = ... # type: int
    MalayalamScript = ... # type: int
    MyanmarScript = ... # type: int
    OriyaScript = ... # type: int
    TamilScript = ... # type: int
    TeluguScript = ... # type: int
    ThaanaScript = ... # type: int
    ThaiScript = ... # type: int
    TibetanScript = ... # type: int
    SinhalaScript = ... # type: int
    SyriacScript = ... # type: int
    YiScript = ... # type: int
    VaiScript = ... # type: int
    AvestanScript = ... # type: int
    BalineseScript = ... # type: int
    BamumScript = ... # type: int
    BatakScript = ... # type: int
    BopomofoScript = ... # type: int
    BrahmiScript = ... # type: int
    BugineseScript = ... # type: int
    BuhidScript = ... # type: int
    CanadianAboriginalScript = ... # type: int
    CarianScript = ... # type: int
    ChakmaScript = ... # type: int
    ChamScript = ... # type: int
    CopticScript = ... # type: int
    CypriotScript = ... # type: int
    EgyptianHieroglyphsScript = ... # type: int
    FraserScript = ... # type: int
    GlagoliticScript = ... # type: int
    GothicScript = ... # type: int
    HanScript = ... # type: int
    HangulScript = ... # type: int
    HanunooScript = ... # type: int
    ImperialAramaicScript = ... # type: int
    InscriptionalPahlaviScript = ... # type: int
    InscriptionalParthianScript = ... # type: int
    JavaneseScript = ... # type: int
    KaithiScript = ... # type: int
    KatakanaScript = ... # type: int
    KayahLiScript = ... # type: int
    KharoshthiScript = ... # type: int
    LannaScript = ... # type: int
    LepchaScript = ... # type: int
    LimbuScript = ... # type: int
    LinearBScript = ... # type: int
    LycianScript = ... # type: int
    LydianScript = ... # type: int
    MandaeanScript = ... # type: int
    MeiteiMayekScript = ... # type: int
    MeroiticScript = ... # type: int
    MeroiticCursiveScript = ... # type: int
    NkoScript = ... # type: int
    NewTaiLueScript = ... # type: int
    OghamScript = ... # type: int
    OlChikiScript = ... # type: int
    OldItalicScript = ... # type: int
    OldPersianScript = ... # type: int
    OldSouthArabianScript = ... # type: int
    OrkhonScript = ... # type: int
    OsmanyaScript = ... # type: int
    PhagsPaScript = ... # type: int
    PhoenicianScript = ... # type: int
    PollardPhoneticScript = ... # type: int
    RejangScript = ... # type: int
    RunicScript = ... # type: int
    SamaritanScript = ... # type: int
    SaurashtraScript = ... # type: int
    SharadaScript = ... # type: int
    ShavianScript = ... # type: int
    SoraSompengScript = ... # type: int
    CuneiformScript = ... # type: int
    SundaneseScript = ... # type: int
    SylotiNagriScript = ... # type: int
    TagalogScript = ... # type: int
    TagbanwaScript = ... # type: int
    TaiLeScript = ... # type: int
    TaiVietScript = ... # type: int
    TakriScript = ... # type: int
    UgariticScript = ... # type: int
    BrailleScript = ... # type: int
    HiraganaScript = ... # type: int
    CaucasianAlbanianScript = ... # type: int
    BassaVahScript = ... # type: int
    DuployanScript = ... # type: int
    ElbasanScript = ... # type: int
    GranthaScript = ... # type: int
    PahawhHmongScript = ... # type: int
    KhojkiScript = ... # type: int
    LinearAScript = ... # type: int
    MahajaniScript = ... # type: int
    ManichaeanScript = ... # type: int
    MendeKikakuiScript = ... # type: int
    ModiScript = ... # type: int
    MroScript = ... # type: int
    OldNorthArabianScript = ... # type: int
    NabataeanScript = ... # type: int
    PalmyreneScript = ... # type: int
    PauCinHauScript = ... # type: int
    OldPermicScript = ... # type: int
    PsalterPahlaviScript = ... # type: int
    SiddhamScript = ... # type: int
    KhudawadiScript = ... # type: int
    TirhutaScript = ... # type: int
    VarangKshitiScript = ... # type: int
    AhomScript = ... # type: int
    AnatolianHieroglyphsScript = ... # type: int
    HatranScript = ... # type: int
    MultaniScript = ... # type: int
    OldHungarianScript = ... # type: int
    SignWritingScript = ... # type: int
    AdlamScript = ... # type: int
    BhaiksukiScript = ... # type: int
    MarchenScript = ... # type: int
    NewaScript = ... # type: int
    OsageScript = ... # type: int
    TangutScript = ... # type: int
    HanWithBopomofoScript = ... # type: int
    JamoScript = ... # type: int

    MeasurementSystem: typing.Type[int]
    #class MeasurementSystem(int): ...
    MetricSystem = ... # type: int
    ImperialSystem = ... # type: int
    ImperialUSSystem = ... # type: int
    ImperialUKSystem = ... # type: int

    FormatType: typing.Type[int]
    #class FormatType(int): ...
    LongFormat = ... # type: int
    ShortFormat = ... # type: int
    NarrowFormat = ... # type: int

    NumberOption: typing.Type[int]
    #class NumberOption(int): ...
    OmitGroupSeparator = ... # type: int
    RejectGroupSeparator = ... # type: int
    DefaultNumberOptions = ... # type: int
    OmitLeadingZeroInExponent = ... # type: int
    RejectLeadingZeroInExponent = ... # type: int
    IncludeTrailingZeroesAfterDot = ... # type: int
    RejectTrailingZeroesAfterDot = ... # type: int

    Country: typing.Type[int]
    #class Country(int): ...
    AnyCountry = ... # type: int
    Afghanistan = ... # type: int
    Albania = ... # type: int
    Algeria = ... # type: int
    AmericanSamoa = ... # type: int
    Andorra = ... # type: int
    Angola = ... # type: int
    Anguilla = ... # type: int
    Antarctica = ... # type: int
    AntiguaAndBarbuda = ... # type: int
    Argentina = ... # type: int
    Armenia = ... # type: int
    Aruba = ... # type: int
    Australia = ... # type: int
    Austria = ... # type: int
    Azerbaijan = ... # type: int
    Bahamas = ... # type: int
    Bahrain = ... # type: int
    Bangladesh = ... # type: int
    Barbados = ... # type: int
    Belarus = ... # type: int
    Belgium = ... # type: int
    Belize = ... # type: int
    Benin = ... # type: int
    Bermuda = ... # type: int
    Bhutan = ... # type: int
    Bolivia = ... # type: int
    BosniaAndHerzegowina = ... # type: int
    Botswana = ... # type: int
    BouvetIsland = ... # type: int
    Brazil = ... # type: int
    BritishIndianOceanTerritory = ... # type: int
    Bulgaria = ... # type: int
    BurkinaFaso = ... # type: int
    Burundi = ... # type: int
    Cambodia = ... # type: int
    Cameroon = ... # type: int
    Canada = ... # type: int
    CapeVerde = ... # type: int
    CaymanIslands = ... # type: int
    CentralAfricanRepublic = ... # type: int
    Chad = ... # type: int
    Chile = ... # type: int
    China = ... # type: int
    ChristmasIsland = ... # type: int
    CocosIslands = ... # type: int
    Colombia = ... # type: int
    Comoros = ... # type: int
    DemocraticRepublicOfCongo = ... # type: int
    PeoplesRepublicOfCongo = ... # type: int
    CookIslands = ... # type: int
    CostaRica = ... # type: int
    IvoryCoast = ... # type: int
    Croatia = ... # type: int
    Cuba = ... # type: int
    Cyprus = ... # type: int
    CzechRepublic = ... # type: int
    Denmark = ... # type: int
    Djibouti = ... # type: int
    Dominica = ... # type: int
    DominicanRepublic = ... # type: int
    EastTimor = ... # type: int
    Ecuador = ... # type: int
    Egypt = ... # type: int
    ElSalvador = ... # type: int
    EquatorialGuinea = ... # type: int
    Eritrea = ... # type: int
    Estonia = ... # type: int
    Ethiopia = ... # type: int
    FalklandIslands = ... # type: int
    FaroeIslands = ... # type: int
    Finland = ... # type: int
    France = ... # type: int
    FrenchGuiana = ... # type: int
    FrenchPolynesia = ... # type: int
    FrenchSouthernTerritories = ... # type: int
    Gabon = ... # type: int
    Gambia = ... # type: int
    Georgia = ... # type: int
    Germany = ... # type: int
    Ghana = ... # type: int
    Gibraltar = ... # type: int
    Greece = ... # type: int
    Greenland = ... # type: int
    Grenada = ... # type: int
    Guadeloupe = ... # type: int
    Guam = ... # type: int
    Guatemala = ... # type: int
    Guinea = ... # type: int
    GuineaBissau = ... # type: int
    Guyana = ... # type: int
    Haiti = ... # type: int
    HeardAndMcDonaldIslands = ... # type: int
    Honduras = ... # type: int
    HongKong = ... # type: int
    Hungary = ... # type: int
    Iceland = ... # type: int
    India = ... # type: int
    Indonesia = ... # type: int
    Iran = ... # type: int
    Iraq = ... # type: int
    Ireland = ... # type: int
    Israel = ... # type: int
    Italy = ... # type: int
    Jamaica = ... # type: int
    Japan = ... # type: int
    Jordan = ... # type: int
    Kazakhstan = ... # type: int
    Kenya = ... # type: int
    Kiribati = ... # type: int
    DemocraticRepublicOfKorea = ... # type: int
    RepublicOfKorea = ... # type: int
    Kuwait = ... # type: int
    Kyrgyzstan = ... # type: int
    Latvia = ... # type: int
    Lebanon = ... # type: int
    Lesotho = ... # type: int
    Liberia = ... # type: int
    Liechtenstein = ... # type: int
    Lithuania = ... # type: int
    Luxembourg = ... # type: int
    Macau = ... # type: int
    Macedonia = ... # type: int
    Madagascar = ... # type: int
    Malawi = ... # type: int
    Malaysia = ... # type: int
    Maldives = ... # type: int
    Mali = ... # type: int
    Malta = ... # type: int
    MarshallIslands = ... # type: int
    Martinique = ... # type: int
    Mauritania = ... # type: int
    Mauritius = ... # type: int
    Mayotte = ... # type: int
    Mexico = ... # type: int
    Micronesia = ... # type: int
    Moldova = ... # type: int
    Monaco = ... # type: int
    Mongolia = ... # type: int
    Montserrat = ... # type: int
    Morocco = ... # type: int
    Mozambique = ... # type: int
    Myanmar = ... # type: int
    Namibia = ... # type: int
    NauruCountry = ... # type: int
    Nepal = ... # type: int
    Netherlands = ... # type: int
    NewCaledonia = ... # type: int
    NewZealand = ... # type: int
    Nicaragua = ... # type: int
    Niger = ... # type: int
    Nigeria = ... # type: int
    Niue = ... # type: int
    NorfolkIsland = ... # type: int
    NorthernMarianaIslands = ... # type: int
    Norway = ... # type: int
    Oman = ... # type: int
    Pakistan = ... # type: int
    Palau = ... # type: int
    Panama = ... # type: int
    PapuaNewGuinea = ... # type: int
    Paraguay = ... # type: int
    Peru = ... # type: int
    Philippines = ... # type: int
    Pitcairn = ... # type: int
    Poland = ... # type: int
    Portugal = ... # type: int
    PuertoRico = ... # type: int
    Qatar = ... # type: int
    Reunion = ... # type: int
    Romania = ... # type: int
    RussianFederation = ... # type: int
    Rwanda = ... # type: int
    SaintKittsAndNevis = ... # type: int
    Samoa = ... # type: int
    SanMarino = ... # type: int
    SaoTomeAndPrincipe = ... # type: int
    SaudiArabia = ... # type: int
    Senegal = ... # type: int
    Seychelles = ... # type: int
    SierraLeone = ... # type: int
    Singapore = ... # type: int
    Slovakia = ... # type: int
    Slovenia = ... # type: int
    SolomonIslands = ... # type: int
    Somalia = ... # type: int
    SouthAfrica = ... # type: int
    SouthGeorgiaAndTheSouthSandwichIslands = ... # type: int
    Spain = ... # type: int
    SriLanka = ... # type: int
    Sudan = ... # type: int
    Suriname = ... # type: int
    SvalbardAndJanMayenIslands = ... # type: int
    Swaziland = ... # type: int
    Sweden = ... # type: int
    Switzerland = ... # type: int
    SyrianArabRepublic = ... # type: int
    Taiwan = ... # type: int
    Tajikistan = ... # type: int
    Tanzania = ... # type: int
    Thailand = ... # type: int
    Togo = ... # type: int
    Tokelau = ... # type: int
    TrinidadAndTobago = ... # type: int
    Tunisia = ... # type: int
    Turkey = ... # type: int
    Turkmenistan = ... # type: int
    TurksAndCaicosIslands = ... # type: int
    Tuvalu = ... # type: int
    Uganda = ... # type: int
    Ukraine = ... # type: int
    UnitedArabEmirates = ... # type: int
    UnitedKingdom = ... # type: int
    UnitedStates = ... # type: int
    UnitedStatesMinorOutlyingIslands = ... # type: int
    Uruguay = ... # type: int
    Uzbekistan = ... # type: int
    Vanuatu = ... # type: int
    VaticanCityState = ... # type: int
    Venezuela = ... # type: int
    BritishVirginIslands = ... # type: int
    WallisAndFutunaIslands = ... # type: int
    WesternSahara = ... # type: int
    Yemen = ... # type: int
    Zambia = ... # type: int
    Zimbabwe = ... # type: int
    Montenegro = ... # type: int
    Serbia = ... # type: int
    SaintBarthelemy = ... # type: int
    SaintMartin = ... # type: int
    LatinAmericaAndTheCaribbean = ... # type: int
    LastCountry = ... # type: int
    Brunei = ... # type: int
    CongoKinshasa = ... # type: int
    CongoBrazzaville = ... # type: int
    Fiji = ... # type: int
    Guernsey = ... # type: int
    NorthKorea = ... # type: int
    SouthKorea = ... # type: int
    Laos = ... # type: int
    Libya = ... # type: int
    CuraSao = ... # type: int
    PalestinianTerritories = ... # type: int
    Russia = ... # type: int
    SaintLucia = ... # type: int
    SaintVincentAndTheGrenadines = ... # type: int
    SaintHelena = ... # type: int
    SaintPierreAndMiquelon = ... # type: int
    Syria = ... # type: int
    Tonga = ... # type: int
    Vietnam = ... # type: int
    UnitedStatesVirginIslands = ... # type: int
    CanaryIslands = ... # type: int
    ClippertonIsland = ... # type: int
    AscensionIsland = ... # type: int
    AlandIslands = ... # type: int
    DiegoGarcia = ... # type: int
    CeutaAndMelilla = ... # type: int
    IsleOfMan = ... # type: int
    Jersey = ... # type: int
    TristanDaCunha = ... # type: int
    SouthSudan = ... # type: int
    Bonaire = ... # type: int
    SintMaarten = ... # type: int
    Kosovo = ... # type: int
    TokelauCountry = ... # type: int
    TuvaluCountry = ... # type: int
    EuropeanUnion = ... # type: int
    OutlyingOceania = ... # type: int
    LatinAmerica = ... # type: int
    World = ... # type: int
    Europe = ... # type: int

    Language: typing.Type[int]
    #class Language(int): ...
    C = ... # type: int
    Abkhazian = ... # type: int
    Afan = ... # type: int
    Afar = ... # type: int
    Afrikaans = ... # type: int
    Albanian = ... # type: int
    Amharic = ... # type: int
    Arabic = ... # type: int
    Armenian = ... # type: int
    Assamese = ... # type: int
    Aymara = ... # type: int
    Azerbaijani = ... # type: int
    Bashkir = ... # type: int
    Basque = ... # type: int
    Bengali = ... # type: int
    Bhutani = ... # type: int
    Bihari = ... # type: int
    Bislama = ... # type: int
    Breton = ... # type: int
    Bulgarian = ... # type: int
    Burmese = ... # type: int
    Byelorussian = ... # type: int
    Cambodian = ... # type: int
    Catalan = ... # type: int
    Chinese = ... # type: int
    Corsican = ... # type: int
    Croatian = ... # type: int
    Czech = ... # type: int
    Danish = ... # type: int
    Dutch = ... # type: int
    English = ... # type: int
    Esperanto = ... # type: int
    Estonian = ... # type: int
    Faroese = ... # type: int
    Finnish = ... # type: int
    French = ... # type: int
    Frisian = ... # type: int
    Gaelic = ... # type: int
    Galician = ... # type: int
    Georgian = ... # type: int
    German = ... # type: int
    Greek = ... # type: int
    Greenlandic = ... # type: int
    Guarani = ... # type: int
    Gujarati = ... # type: int
    Hausa = ... # type: int
    Hebrew = ... # type: int
    Hindi = ... # type: int
    Hungarian = ... # type: int
    Icelandic = ... # type: int
    Indonesian = ... # type: int
    Interlingua = ... # type: int
    Interlingue = ... # type: int
    Inuktitut = ... # type: int
    Inupiak = ... # type: int
    Irish = ... # type: int
    Italian = ... # type: int
    Japanese = ... # type: int
    Javanese = ... # type: int
    Kannada = ... # type: int
    Kashmiri = ... # type: int
    Kazakh = ... # type: int
    Kinyarwanda = ... # type: int
    Kirghiz = ... # type: int
    Korean = ... # type: int
    Kurdish = ... # type: int
    Kurundi = ... # type: int
    Latin = ... # type: int
    Latvian = ... # type: int
    Lingala = ... # type: int
    Lithuanian = ... # type: int
    Macedonian = ... # type: int
    Malagasy = ... # type: int
    Malay = ... # type: int
    Malayalam = ... # type: int
    Maltese = ... # type: int
    Maori = ... # type: int
    Marathi = ... # type: int
    Moldavian = ... # type: int
    Mongolian = ... # type: int
    NauruLanguage = ... # type: int
    Nepali = ... # type: int
    Norwegian = ... # type: int
    Occitan = ... # type: int
    Oriya = ... # type: int
    Pashto = ... # type: int
    Persian = ... # type: int
    Polish = ... # type: int
    Portuguese = ... # type: int
    Punjabi = ... # type: int
    Quechua = ... # type: int
    RhaetoRomance = ... # type: int
    Romanian = ... # type: int
    Russian = ... # type: int
    Samoan = ... # type: int
    Sanskrit = ... # type: int
    Serbian = ... # type: int
    SerboCroatian = ... # type: int
    Shona = ... # type: int
    Sindhi = ... # type: int
    Slovak = ... # type: int
    Slovenian = ... # type: int
    Somali = ... # type: int
    Spanish = ... # type: int
    Sundanese = ... # type: int
    Swahili = ... # type: int
    Swedish = ... # type: int
    Tagalog = ... # type: int
    Tajik = ... # type: int
    Tamil = ... # type: int
    Tatar = ... # type: int
    Telugu = ... # type: int
    Thai = ... # type: int
    Tibetan = ... # type: int
    Tigrinya = ... # type: int
    Tsonga = ... # type: int
    Turkish = ... # type: int
    Turkmen = ... # type: int
    Twi = ... # type: int
    Uigur = ... # type: int
    Ukrainian = ... # type: int
    Urdu = ... # type: int
    Uzbek = ... # type: int
    Vietnamese = ... # type: int
    Volapuk = ... # type: int
    Welsh = ... # type: int
    Wolof = ... # type: int
    Xhosa = ... # type: int
    Yiddish = ... # type: int
    Yoruba = ... # type: int
    Zhuang = ... # type: int
    Zulu = ... # type: int
    Bosnian = ... # type: int
    Divehi = ... # type: int
    Manx = ... # type: int
    Cornish = ... # type: int
    LastLanguage = ... # type: int
    NorwegianBokmal = ... # type: int
    NorwegianNynorsk = ... # type: int
    Akan = ... # type: int
    Konkani = ... # type: int
    Ga = ... # type: int
    Igbo = ... # type: int
    Kamba = ... # type: int
    Syriac = ... # type: int
    Blin = ... # type: int
    Geez = ... # type: int
    Koro = ... # type: int
    Sidamo = ... # type: int
    Atsam = ... # type: int
    Tigre = ... # type: int
    Jju = ... # type: int
    Friulian = ... # type: int
    Venda = ... # type: int
    Ewe = ... # type: int
    Walamo = ... # type: int
    Hawaiian = ... # type: int
    Tyap = ... # type: int
    Chewa = ... # type: int
    Filipino = ... # type: int
    SwissGerman = ... # type: int
    SichuanYi = ... # type: int
    Kpelle = ... # type: int
    LowGerman = ... # type: int
    SouthNdebele = ... # type: int
    NorthernSotho = ... # type: int
    NorthernSami = ... # type: int
    Taroko = ... # type: int
    Gusii = ... # type: int
    Taita = ... # type: int
    Fulah = ... # type: int
    Kikuyu = ... # type: int
    Samburu = ... # type: int
    Sena = ... # type: int
    NorthNdebele = ... # type: int
    Rombo = ... # type: int
    Tachelhit = ... # type: int
    Kabyle = ... # type: int
    Nyankole = ... # type: int
    Bena = ... # type: int
    Vunjo = ... # type: int
    Bambara = ... # type: int
    Embu = ... # type: int
    Cherokee = ... # type: int
    Morisyen = ... # type: int
    Makonde = ... # type: int
    Langi = ... # type: int
    Ganda = ... # type: int
    Bemba = ... # type: int
    Kabuverdianu = ... # type: int
    Meru = ... # type: int
    Kalenjin = ... # type: int
    Nama = ... # type: int
    Machame = ... # type: int
    Colognian = ... # type: int
    Masai = ... # type: int
    Soga = ... # type: int
    Luyia = ... # type: int
    Asu = ... # type: int
    Teso = ... # type: int
    Saho = ... # type: int
    KoyraChiini = ... # type: int
    Rwa = ... # type: int
    Luo = ... # type: int
    Chiga = ... # type: int
    CentralMoroccoTamazight = ... # type: int
    KoyraboroSenni = ... # type: int
    Shambala = ... # type: int
    AnyLanguage = ... # type: int
    Rundi = ... # type: int
    Bodo = ... # type: int
    Aghem = ... # type: int
    Basaa = ... # type: int
    Zarma = ... # type: int
    Duala = ... # type: int
    JolaFonyi = ... # type: int
    Ewondo = ... # type: int
    Bafia = ... # type: int
    LubaKatanga = ... # type: int
    MakhuwaMeetto = ... # type: int
    Mundang = ... # type: int
    Kwasio = ... # type: int
    Nuer = ... # type: int
    Sakha = ... # type: int
    Sangu = ... # type: int
    CongoSwahili = ... # type: int
    Tasawaq = ... # type: int
    Vai = ... # type: int
    Walser = ... # type: int
    Yangben = ... # type: int
    Oromo = ... # type: int
    Dzongkha = ... # type: int
    Belarusian = ... # type: int
    Khmer = ... # type: int
    Fijian = ... # type: int
    WesternFrisian = ... # type: int
    Lao = ... # type: int
    Marshallese = ... # type: int
    Romansh = ... # type: int
    Sango = ... # type: int
    Ossetic = ... # type: int
    SouthernSotho = ... # type: int
    Tswana = ... # type: int
    Sinhala = ... # type: int
    Swati = ... # type: int
    Sardinian = ... # type: int
    Tongan = ... # type: int
    Tahitian = ... # type: int
    Nyanja = ... # type: int
    Avaric = ... # type: int
    Chamorro = ... # type: int
    Chechen = ... # type: int
    Church = ... # type: int
    Chuvash = ... # type: int
    Cree = ... # type: int
    Haitian = ... # type: int
    Herero = ... # type: int
    HiriMotu = ... # type: int
    Kanuri = ... # type: int
    Komi = ... # type: int
    Kongo = ... # type: int
    Kwanyama = ... # type: int
    Limburgish = ... # type: int
    Luxembourgish = ... # type: int
    Navaho = ... # type: int
    Ndonga = ... # type: int
    Ojibwa = ... # type: int
    Pali = ... # type: int
    Walloon = ... # type: int
    Avestan = ... # type: int
    Asturian = ... # type: int
    Ngomba = ... # type: int
    Kako = ... # type: int
    Meta = ... # type: int
    Ngiemboon = ... # type: int
    Uighur = ... # type: int
    Aragonese = ... # type: int
    Akkadian = ... # type: int
    AncientEgyptian = ... # type: int
    AncientGreek = ... # type: int
    Aramaic = ... # type: int
    Balinese = ... # type: int
    Bamun = ... # type: int
    BatakToba = ... # type: int
    Buginese = ... # type: int
    Buhid = ... # type: int
    Carian = ... # type: int
    Chakma = ... # type: int
    ClassicalMandaic = ... # type: int
    Coptic = ... # type: int
    Dogri = ... # type: int
    EasternCham = ... # type: int
    EasternKayah = ... # type: int
    Etruscan = ... # type: int
    Gothic = ... # type: int
    Hanunoo = ... # type: int
    Ingush = ... # type: int
    LargeFloweryMiao = ... # type: int
    Lepcha = ... # type: int
    Limbu = ... # type: int
    Lisu = ... # type: int
    Lu = ... # type: int
    Lycian = ... # type: int
    Lydian = ... # type: int
    Mandingo = ... # type: int
    Manipuri = ... # type: int
    Meroitic = ... # type: int
    NorthernThai = ... # type: int
    OldIrish = ... # type: int
    OldNorse = ... # type: int
    OldPersian = ... # type: int
    OldTurkish = ... # type: int
    Pahlavi = ... # type: int
    Parthian = ... # type: int
    Phoenician = ... # type: int
    PrakritLanguage = ... # type: int
    Rejang = ... # type: int
    Sabaean = ... # type: int
    Samaritan = ... # type: int
    Santali = ... # type: int
    Saurashtra = ... # type: int
    Sora = ... # type: int
    Sylheti = ... # type: int
    Tagbanwa = ... # type: int
    TaiDam = ... # type: int
    TaiNua = ... # type: int
    Ugaritic = ... # type: int
    Akoose = ... # type: int
    Lakota = ... # type: int
    StandardMoroccanTamazight = ... # type: int
    Mapuche = ... # type: int
    CentralKurdish = ... # type: int
    LowerSorbian = ... # type: int
    UpperSorbian = ... # type: int
    Kenyang = ... # type: int
    Mohawk = ... # type: int
    Nko = ... # type: int
    Prussian = ... # type: int
    Kiche = ... # type: int
    SouthernSami = ... # type: int
    LuleSami = ... # type: int
    InariSami = ... # type: int
    SkoltSami = ... # type: int
    Warlpiri = ... # type: int
    ManichaeanMiddlePersian = ... # type: int
    Mende = ... # type: int
    AncientNorthArabian = ... # type: int
    LinearA = ... # type: int
    HmongNjua = ... # type: int
    Ho = ... # type: int
    Lezghian = ... # type: int
    Bassa = ... # type: int
    Mono = ... # type: int
    TedimChin = ... # type: int
    Maithili = ... # type: int
    Ahom = ... # type: int
    AmericanSignLanguage = ... # type: int
    ArdhamagadhiPrakrit = ... # type: int
    Bhojpuri = ... # type: int
    HieroglyphicLuwian = ... # type: int
    LiteraryChinese = ... # type: int
    Mazanderani = ... # type: int
    Mru = ... # type: int
    Newari = ... # type: int
    NorthernLuri = ... # type: int
    Palauan = ... # type: int
    Papiamento = ... # type: int
    Saraiki = ... # type: int
    TokelauLanguage = ... # type: int
    TokPisin = ... # type: int
    TuvaluLanguage = ... # type: int
    UncodedLanguages = ... # type: int
    Cantonese = ... # type: int
    Osage = ... # type: int
    Tangut = ... # type: int

    NumberOptions: typing.Type[int]
    #class NumberOptions(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QLocale.NumberOptions, QLocale.NumberOption]) -> None: ...
        #@overload
        #def __init__(self, a0: QLocale.NumberOptions) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QLocale.NumberOptions: ...
        #def __int__(self) -> int: ...

    DataSizeFormats: typing.Type[int]
    #class DataSizeFormats(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QLocale.DataSizeFormats, QLocale.DataSizeFormat]) -> None: ...
        #@overload
        #def __init__(self, a0: QLocale.DataSizeFormats) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QLocale.DataSizeFormats: ...
        #def __int__(self) -> int: ...

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, name: str) -> None: ...
    @overload
    def __init__(self, language: int, country: int = ...) -> None: ...
    @overload
    def __init__(self, other: QLocale) -> None: ...
    @overload
    def __init__(self, language: int, script: int, country: int) -> None: ...

    def formattedDataSize(self, bytes: int, precision: int = ..., format: typing.Union[int, int] = ...) -> str: ...
    def swap(self, other: QLocale) -> None: ...
    def __hash__(self) -> int: ...
    def createSeparatedList(self, list: typing.Iterable[str]) -> str: ...
    def quoteString(self, str: str, style: int = ...) -> str: ...
    @staticmethod
    def matchingLocales(language: int, script: int, country: int) -> typing.List[QLocale]: ...
    @staticmethod
    def scriptToString(script: int) -> str: ...
    def uiLanguages(self) -> typing.List[str]: ...
    @overload
    def toCurrencyString(self, value: float, symbol: str = ...) -> str: ...
    @overload
    def toCurrencyString(self, value: float, symbol: str, precision: int) -> str: ...
    @overload
    def toCurrencyString(self, value: int, symbol: str = ...) -> str: ...
    def currencySymbol(self, format: int = ...) -> str: ...
    def toLower(self, str: str) -> str: ...
    def toUpper(self, str: str) -> str: ...
    def weekdays(self) -> typing.List[int]: ...
    def firstDayOfWeek(self) -> int: ...
    def nativeCountryName(self) -> str: ...
    def nativeLanguageName(self) -> str: ...
    def bcp47Name(self) -> str: ...
    def script(self) -> int: ...
    def textDirection(self) -> int: ...
    def pmText(self) -> str: ...
    def amText(self) -> str: ...
    def standaloneDayName(self, a0: int, format: int = ...) -> str: ...
    def standaloneMonthName(self, a0: int, format: int = ...) -> str: ...
    def positiveSign(self) -> str: ...
    def measurementSystem(self) -> int: ...
    def numberOptions(self) -> int: ...
    def setNumberOptions(self, options: typing.Union[int, int]) -> None: ...
    def dayName(self, a0: int, format: int = ...) -> str: ...
    def monthName(self, a0: int, format: int = ...) -> str: ...
    def exponential(self) -> str: ...
    def negativeSign(self) -> str: ...
    def zeroDigit(self) -> str: ...
    def percent(self) -> str: ...
    def groupSeparator(self) -> str: ...
    def decimalPoint(self) -> str: ...
    @overload
    def toDateTime(self, string: str, format: int = ...) -> QDateTime: ...
    @overload
    def toDateTime(self, string: str, format: str) -> QDateTime: ...
    @overload
    def toTime(self, string: str, format: int = ...) -> QTime: ...
    @overload
    def toTime(self, string: str, format: str) -> QTime: ...
    @overload
    def toDate(self, string: str, format: int = ...) -> QDate: ...
    @overload
    def toDate(self, string: str, format: str) -> QDate: ...
    def dateTimeFormat(self, format: int = ...) -> str: ...
    def timeFormat(self, format: int = ...) -> str: ...
    def dateFormat(self, format: int = ...) -> str: ...
    @staticmethod
    def system() -> QLocale: ...
    @staticmethod
    def c() -> QLocale: ...
    @staticmethod
    def setDefault(locale: QLocale) -> None: ...
    @staticmethod
    def countryToString(country: int) -> str: ...
    @staticmethod
    def languageToString(language: int) -> str: ...
    @overload
    def toString(self, i: float, format: str = ..., precision: int = ...) -> str: ...
    @overload
    def toString(self, dateTime: typing.Union[QDateTime, datetime.datetime], format: str) -> str: ...
    @overload
    def toString(self, dateTime: typing.Union[QDateTime, datetime.datetime], format: int = ...) -> str: ...
    @overload
    def toString(self, date: typing.Union[QDate, datetime.date], formatStr: str) -> str: ...
    @overload
    def toString(self, date: typing.Union[QDate, datetime.date], format: int = ...) -> str: ...
    @overload
    def toString(self, time: typing.Union[QTime, datetime.time], formatStr: str) -> str: ...
    @overload
    def toString(self, time: typing.Union[QTime, datetime.time], format: int = ...) -> str: ...
    @overload
    def toString(self, i: int) -> str: ...
    def toDouble(self, s: str) -> typing.Tuple[float, bool]: ...
    def toFloat(self, s: str) -> typing.Tuple[float, bool]: ...
    def toULongLong(self, s: str) -> typing.Tuple[int, bool]: ...
    def toLongLong(self, s: str) -> typing.Tuple[int, bool]: ...
    def toUInt(self, s: str) -> typing.Tuple[int, bool]: ...
    def toInt(self, s: str) -> typing.Tuple[int, bool]: ...
    def toUShort(self, s: str) -> typing.Tuple[int, bool]: ...
    def toShort(self, s: str) -> typing.Tuple[int, bool]: ...
    def name(self) -> str: ...
    def country(self) -> int: ...
    def language(self) -> int: ...


class QLockFile(sip.simplewrapper):

    LockError: typing.Type[int]
    #class LockError(int): ...
    NoError = ... # type: int
    LockFailedError = ... # type: int
    PermissionError = ... # type: int
    UnknownError = ... # type: int

    def __init__(self, fileName: str) -> None: ...

    def error(self) -> int: ...
    def removeStaleLockFile(self) -> bool: ...
    def getLockInfo(self) -> typing.Tuple[bool, int, str, str]: ...
    def isLocked(self) -> bool: ...
    def staleLockTime(self) -> int: ...
    def setStaleLockTime(self, a0: int) -> None: ...
    def unlock(self) -> None: ...
    def tryLock(self, timeout: int = ...) -> bool: ...
    def lock(self) -> bool: ...


class QMessageLogContext(sip.simplewrapper):

    category = ... # type: str
    file = ... # type: str
    function = ... # type: str
    line = ... # type: int


class QMessageLogger(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, file: str, line: int, function: str) -> None: ...
    @overload
    def __init__(self, file: str, line: int, function: str, category: str) -> None: ...

    def info(self, msg: str) -> None: ...
    def fatal(self, msg: str) -> None: ...
    def critical(self, msg: str) -> None: ...
    def warning(self, msg: str) -> None: ...
    def debug(self, msg: str) -> None: ...


class QLoggingCategory(sip.simplewrapper):

    @overload
    def __init__(self, category: str) -> None: ...
    @overload
    def __init__(self, category: str, severityLevel: int) -> None: ...

    @staticmethod
    def setFilterRules(rules: str) -> None: ...
    @staticmethod
    def defaultCategory() -> QLoggingCategory: ...
    def __call__(self) -> QLoggingCategory: ...
    def categoryName(self) -> str: ...
    def isCriticalEnabled(self) -> bool: ...
    def isWarningEnabled(self) -> bool: ...
    def isInfoEnabled(self) -> bool: ...
    def isDebugEnabled(self) -> bool: ...
    def setEnabled(self, type: int, enable: bool) -> None: ...
    def isEnabled(self, type: int) -> bool: ...


class QMargins(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, aleft: int, atop: int, aright: int, abottom: int) -> None: ...
    @overload
    def __init__(self, a0: QMargins) -> None: ...

    def __neg__(self) -> QMargins: ...
    def __pos__(self) -> QMargins: ...
    def setBottom(self, abottom: int) -> None: ...
    def setRight(self, aright: int) -> None: ...
    def setTop(self, atop: int) -> None: ...
    def setLeft(self, aleft: int) -> None: ...
    def bottom(self) -> int: ...
    def right(self) -> int: ...
    def top(self) -> int: ...
    def left(self) -> int: ...
    def isNull(self) -> bool: ...


class QMarginsF(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, aleft: float, atop: float, aright: float, abottom: float) -> None: ...
    @overload
    def __init__(self, margins: QMargins) -> None: ...
    @overload
    def __init__(self, a0: QMarginsF) -> None: ...

    def __neg__(self) -> QMarginsF: ...
    def __pos__(self) -> QMarginsF: ...
    def toMargins(self) -> QMargins: ...
    def setBottom(self, abottom: float) -> None: ...
    def setRight(self, aright: float) -> None: ...
    def setTop(self, atop: float) -> None: ...
    def setLeft(self, aleft: float) -> None: ...
    def bottom(self) -> float: ...
    def right(self) -> float: ...
    def top(self) -> float: ...
    def left(self) -> float: ...
    def isNull(self) -> bool: ...


class QMessageAuthenticationCode(sip.simplewrapper):

    def __init__(self, method: int, key: typing.Union[QByteArray, bytes, bytearray] = ...) -> None: ...

    @staticmethod
    def hash(message: typing.Union[QByteArray, bytes, bytearray], key: typing.Union[QByteArray, bytes, bytearray], method: int) -> QByteArray: ...
    def result(self) -> QByteArray: ...
    @overload
    def addData(self, data: str, length: int) -> None: ...
    @overload
    def addData(self, data: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    @overload
    def addData(self, device: QIODevice) -> bool: ...
    def setKey(self, key: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    def reset(self) -> None: ...


class QMetaMethod(sip.simplewrapper):

    MethodType: typing.Type[int]
    #class MethodType(int): ...
    Method = ... # type: int
    Signal = ... # type: int
    Slot = ... # type: int
    Constructor = ... # type: int

    Access: typing.Type[int]
    #class Access(int): ...
    Private = ... # type: int
    Protected = ... # type: int
    Public = ... # type: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QMetaMethod) -> None: ...

    def parameterType(self, index: int) -> int: ...
    def parameterCount(self) -> int: ...
    def returnType(self) -> int: ...
    def name(self) -> QByteArray: ...
    def methodSignature(self) -> QByteArray: ...
    def isValid(self) -> bool: ...
    def methodIndex(self) -> int: ...
    @overload
    def invoke(self, object: QObject, connectionType: int, returnValue: QGenericReturnArgument, value0: QGenericArgument = ..., value1: QGenericArgument = ..., value2: QGenericArgument = ..., value3: QGenericArgument = ..., value4: QGenericArgument = ..., value5: QGenericArgument = ..., value6: QGenericArgument = ..., value7: QGenericArgument = ..., value8: QGenericArgument = ..., value9: QGenericArgument = ...) -> typing.Any: ...
    @overload
    def invoke(self, object: QObject, returnValue: QGenericReturnArgument, value0: QGenericArgument = ..., value1: QGenericArgument = ..., value2: QGenericArgument = ..., value3: QGenericArgument = ..., value4: QGenericArgument = ..., value5: QGenericArgument = ..., value6: QGenericArgument = ..., value7: QGenericArgument = ..., value8: QGenericArgument = ..., value9: QGenericArgument = ...) -> typing.Any: ...
    @overload
    def invoke(self, object: QObject, connectionType: int, value0: QGenericArgument = ..., value1: QGenericArgument = ..., value2: QGenericArgument = ..., value3: QGenericArgument = ..., value4: QGenericArgument = ..., value5: QGenericArgument = ..., value6: QGenericArgument = ..., value7: QGenericArgument = ..., value8: QGenericArgument = ..., value9: QGenericArgument = ...) -> typing.Any: ...
    @overload
    def invoke(self, object: QObject, value0: QGenericArgument = ..., value1: QGenericArgument = ..., value2: QGenericArgument = ..., value3: QGenericArgument = ..., value4: QGenericArgument = ..., value5: QGenericArgument = ..., value6: QGenericArgument = ..., value7: QGenericArgument = ..., value8: QGenericArgument = ..., value9: QGenericArgument = ...) -> typing.Any: ...
    def methodType(self) -> int: ...
    def access(self) -> int: ...
    def tag(self) -> str: ...
    def parameterNames(self) -> typing.List[QByteArray]: ...
    def parameterTypes(self) -> typing.List[QByteArray]: ...
    def typeName(self) -> str: ...


class QMetaEnum(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QMetaEnum) -> None: ...

    def enumName(self) -> str: ...
    def isScoped(self) -> bool: ...
    def isValid(self) -> bool: ...
    def valueToKeys(self, value: int) -> QByteArray: ...
    def keysToValue(self, keys: str) -> typing.Tuple[int, bool]: ...
    def valueToKey(self, value: int) -> str: ...
    def keyToValue(self, key: str) -> typing.Tuple[int, bool]: ...
    def scope(self) -> str: ...
    def value(self, index: int) -> int: ...
    def key(self, index: int) -> str: ...
    def keyCount(self) -> int: ...
    def isFlag(self) -> bool: ...
    def name(self) -> str: ...


class QMetaProperty(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QMetaProperty) -> None: ...

    def isFinal(self) -> bool: ...
    def isConstant(self) -> bool: ...
    def propertyIndex(self) -> int: ...
    def notifySignalIndex(self) -> int: ...
    def notifySignal(self) -> QMetaMethod: ...
    def hasNotifySignal(self) -> bool: ...
    def userType(self) -> int: ...
    def isUser(self, object: typing.Optional[QObject] = ...) -> bool: ...
    def isResettable(self) -> bool: ...
    def isValid(self) -> bool: ...
    def hasStdCppSet(self) -> bool: ...
    def reset(self, obj: QObject) -> bool: ...
    def write(self, obj: QObject, value: typing.Any) -> bool: ...
    def read(self, obj: QObject) -> typing.Any: ...
    def enumerator(self) -> QMetaEnum: ...
    def isEnumType(self) -> bool: ...
    def isFlagType(self) -> bool: ...
    def isStored(self, object: typing.Optional[QObject] = ...) -> bool: ...
    def isScriptable(self, object: typing.Optional[QObject] = ...) -> bool: ...
    def isDesignable(self, object: typing.Optional[QObject] = ...) -> bool: ...
    def isWritable(self) -> bool: ...
    def isReadable(self) -> bool: ...
    def type(self) -> int: ...
    def typeName(self) -> str: ...
    def name(self) -> str: ...


class QMetaClassInfo(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QMetaClassInfo) -> None: ...

    def value(self) -> str: ...
    def name(self) -> str: ...


class QMetaType(sip.simplewrapper):

    TypeFlag: typing.Type[int]
    #class TypeFlag(int): ...
    NeedsConstruction = ... # type: int
    NeedsDestruction = ... # type: int
    MovableType = ... # type: int
    PointerToQObject = ... # type: int
    IsEnumeration = ... # type: int

    Type: typing.Type[int]
    #class Type(int): ...
    UnknownType = ... # type: int
    Void = ... # type: int
    Bool = ... # type: int
    Int = ... # type: int
    UInt = ... # type: int
    LongLong = ... # type: int
    ULongLong = ... # type: int
    Double = ... # type: int
    QChar = ... # type: int
    QVariantMap = ... # type: int
    QVariantList = ... # type: int
    QVariantHash = ... # type: int
    QString = ... # type: int
    QStringList = ... # type: int
    QByteArray = ... # type: int
    QBitArray = ... # type: int
    QDate = ... # type: int
    QTime = ... # type: int
    QDateTime = ... # type: int
    QUrl = ... # type: int
    QLocale = ... # type: int
    QRect = ... # type: int
    QRectF = ... # type: int
    QSize = ... # type: int
    QSizeF = ... # type: int
    QLine = ... # type: int
    QLineF = ... # type: int
    QPoint = ... # type: int
    QPointF = ... # type: int
    QRegExp = ... # type: int
    LastCoreType = ... # type: int
    FirstGuiType = ... # type: int
    QFont = ... # type: int
    QPixmap = ... # type: int
    QBrush = ... # type: int
    QColor = ... # type: int
    QPalette = ... # type: int
    QIcon = ... # type: int
    QImage = ... # type: int
    QPolygon = ... # type: int
    QRegion = ... # type: int
    QBitmap = ... # type: int
    QCursor = ... # type: int
    QSizePolicy = ... # type: int
    QKeySequence = ... # type: int
    QPen = ... # type: int
    QTextLength = ... # type: int
    QTextFormat = ... # type: int
    QMatrix = ... # type: int
    QTransform = ... # type: int
    VoidStar = ... # type: int
    Long = ... # type: int
    Short = ... # type: int
    Char = ... # type: int
    ULong = ... # type: int
    UShort = ... # type: int
    UChar = ... # type: int
    Float = ... # type: int
    QObjectStar = ... # type: int
    QMatrix4x4 = ... # type: int
    QVector2D = ... # type: int
    QVector3D = ... # type: int
    QVector4D = ... # type: int
    QQuaternion = ... # type: int
    QEasingCurve = ... # type: int
    QVariant = ... # type: int
    QUuid = ... # type: int
    QModelIndex = ... # type: int
    QPolygonF = ... # type: int
    SChar = ... # type: int
    QRegularExpression = ... # type: int
    QJsonValue = ... # type: int
    QJsonObject = ... # type: int
    QJsonArray = ... # type: int
    QJsonDocument = ... # type: int
    QByteArrayList = ... # type: int
    QPersistentModelIndex = ... # type: int
    QCborSimpleType = ... # type: int
    QCborValue = ... # type: int
    QCborArray = ... # type: int
    QCborMap = ... # type: int
    User = ... # type: int

    TypeFlags: typing.Type[int]
    #class TypeFlags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QMetaType.TypeFlags, QMetaType.TypeFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: QMetaType.TypeFlags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QMetaType.TypeFlags: ...
        #def __int__(self) -> int: ...

    def __init__(self, type: int) -> None: ...

    @staticmethod
    def metaObjectForType(type: int) -> QMetaObject: ...
    def isValid(self) -> bool: ...
    def flags(self) -> int: ...
    @staticmethod
    def typeFlags(type: int) -> int: ...
    #@overload
    #@staticmethod
    #def isRegistered(type: int) -> bool: ...
    @overload
    def isRegistered(self) -> bool: ...
    @staticmethod
    def typeName(type: int) -> str: ...
    @staticmethod
    def type(typeName: str) -> int: ...


class QMimeData(QObject):

    def __init__(self, **props) -> None: ...

    def retrieveData(self, mimetype: str, preferredType: int) -> typing.Any: ...
    def removeFormat(self, mimetype: str) -> None: ...
    def clear(self) -> None: ...
    def formats(self) -> typing.List[str]: ...
    def hasFormat(self, mimetype: str) -> bool: ...
    def setData(self, mimetype: str, data: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    def data(self, mimetype: str) -> QByteArray: ...
    def hasColor(self) -> bool: ...
    def setColorData(self, color: typing.Any) -> None: ...
    def colorData(self) -> typing.Any: ...
    def hasImage(self) -> bool: ...
    def setImageData(self, image: typing.Any) -> None: ...
    def imageData(self) -> typing.Any: ...
    def hasHtml(self) -> bool: ...
    def setHtml(self, html: str) -> None: ...
    def html(self) -> str: ...
    def hasText(self) -> bool: ...
    def setText(self, text: str) -> None: ...
    def text(self) -> str: ...
    def hasUrls(self) -> bool: ...
    def setUrls(self, urls: typing.Iterable[QUrl]) -> None: ...
    def urls(self) -> typing.List[QUrl]: ...


class QMimeDatabase(sip.simplewrapper):

    MatchMode: typing.Type[int]
    #class MatchMode(int): ...
    MatchDefault = ... # type: int
    MatchExtension = ... # type: int
    MatchContent = ... # type: int

    def __init__(self) -> None: ...

    def allMimeTypes(self) -> typing.List[QMimeType]: ...
    def suffixForFileName(self, fileName: str) -> str: ...
    @overload
    def mimeTypeForFileNameAndData(self, fileName: str, device: QIODevice) -> QMimeType: ...
    @overload
    def mimeTypeForFileNameAndData(self, fileName: str, data: typing.Union[QByteArray, bytes, bytearray]) -> QMimeType: ...
    def mimeTypeForUrl(self, url: QUrl) -> QMimeType: ...
    @overload
    def mimeTypeForData(self, data: typing.Union[QByteArray, bytes, bytearray]) -> QMimeType: ...
    @overload
    def mimeTypeForData(self, device: QIODevice) -> QMimeType: ...
    def mimeTypesForFileName(self, fileName: str) -> typing.List[QMimeType]: ...
    @overload
    def mimeTypeForFile(self, fileName: str, mode: int = ...) -> QMimeType: ...
    @overload
    def mimeTypeForFile(self, fileInfo: QFileInfo, mode: int = ...) -> QMimeType: ...
    def mimeTypeForName(self, nameOrAlias: str) -> QMimeType: ...


class QMimeType(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: QMimeType) -> None: ...

    def __hash__(self) -> int: ...
    def filterString(self) -> str: ...
    def inherits(self, mimeTypeName: str) -> bool: ...
    def preferredSuffix(self) -> str: ...
    def suffixes(self) -> typing.List[str]: ...
    def aliases(self) -> typing.List[str]: ...
    def allAncestors(self) -> typing.List[str]: ...
    def parentMimeTypes(self) -> typing.List[str]: ...
    def globPatterns(self) -> typing.List[str]: ...
    def iconName(self) -> str: ...
    def genericIconName(self) -> str: ...
    def comment(self) -> str: ...
    def name(self) -> str: ...
    def isDefault(self) -> bool: ...
    def isValid(self) -> bool: ...
    def swap(self, other: QMimeType) -> None: ...


class QMutexLocker(sip.simplewrapper):

    def __init__(self, m: QMutex) -> None: ...

    def __exit__(self, type: typing.Any, value: typing.Any, traceback: typing.Any) -> None: ...
    def __enter__(self) -> typing.Any: ...
    def mutex(self) -> QMutex: ...
    def relock(self) -> None: ...
    def unlock(self) -> None: ...


class QMutex(sip.simplewrapper):

    RecursionMode: typing.Type[int]
    #class RecursionMode(int): ...
    NonRecursive = ... # type: int
    Recursive = ... # type: int

    def __init__(self, mode: int = ...) -> None: ...

    def isRecursive(self) -> bool: ...
    def unlock(self) -> None: ...
    def tryLock(self, timeout: int = ...) -> bool: ...
    def lock(self) -> None: ...


class QSignalBlocker(sip.simplewrapper):

    def __init__(self, o: QObject) -> None: ...

    def __exit__(self, type: typing.Any, value: typing.Any, traceback: typing.Any) -> None: ...
    def __enter__(self) -> typing.Any: ...
    def unblock(self) -> None: ...
    def reblock(self) -> None: ...


class QObjectCleanupHandler(QObject):

    def __init__(self, **props) -> None: ...

    def clear(self) -> None: ...
    def isEmpty(self) -> bool: ...
    def remove(self, object: QObject) -> None: ...
    def add(self, object: QObject) -> QObject: ...


class QMetaObject(sip.simplewrapper):

    class Connection:

        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, other: QMetaObject.Connection) -> None: ...

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QMetaObject) -> None: ...

    def inherits(self, metaObject: QMetaObject) -> bool: ...
    def constructor(self, index: int) -> QMetaMethod: ...
    def indexOfConstructor(self, constructor: str) -> int: ...
    def constructorCount(self) -> int: ...
    @overload
    @staticmethod
    def invokeMethod(obj: QObject, member: str, type: int, ret: QGenericReturnArgument, value0: QGenericArgument = ..., value1: QGenericArgument = ..., value2: QGenericArgument = ..., value3: QGenericArgument = ..., value4: QGenericArgument = ..., value5: QGenericArgument = ..., value6: QGenericArgument = ..., value7: QGenericArgument = ..., value8: QGenericArgument = ..., value9: QGenericArgument = ...) -> typing.Any: ...
    @overload
    @staticmethod
    def invokeMethod(obj: QObject, member: str, ret: QGenericReturnArgument, value0: QGenericArgument = ..., value1: QGenericArgument = ..., value2: QGenericArgument = ..., value3: QGenericArgument = ..., value4: QGenericArgument = ..., value5: QGenericArgument = ..., value6: QGenericArgument = ..., value7: QGenericArgument = ..., value8: QGenericArgument = ..., value9: QGenericArgument = ...) -> typing.Any: ...
    @overload
    @staticmethod
    def invokeMethod(obj: QObject, member: str, type: int, value0: QGenericArgument = ..., value1: QGenericArgument = ..., value2: QGenericArgument = ..., value3: QGenericArgument = ..., value4: QGenericArgument = ..., value5: QGenericArgument = ..., value6: QGenericArgument = ..., value7: QGenericArgument = ..., value8: QGenericArgument = ..., value9: QGenericArgument = ...) -> typing.Any: ...
    @overload
    @staticmethod
    def invokeMethod(obj: QObject, member: str, value0: QGenericArgument = ..., value1: QGenericArgument = ..., value2: QGenericArgument = ..., value3: QGenericArgument = ..., value4: QGenericArgument = ..., value5: QGenericArgument = ..., value6: QGenericArgument = ..., value7: QGenericArgument = ..., value8: QGenericArgument = ..., value9: QGenericArgument = ...) -> typing.Any: ...
    @staticmethod
    def normalizedType(type: str) -> QByteArray: ...
    @staticmethod
    def normalizedSignature(method: str) -> QByteArray: ...
    @staticmethod
    def connectSlotsByName(o: QObject) -> None: ...
    @overload
    @staticmethod
    def checkConnectArgs(signal: str, method: str) -> bool: ...
    @overload
    @staticmethod
    def checkConnectArgs(signal: QMetaMethod, method: QMetaMethod) -> bool: ...
    def classInfo(self, index: int) -> QMetaClassInfo: ...
    def property(self, index: int) -> QMetaProperty: ...
    def enumerator(self, index: int) -> QMetaEnum: ...
    def method(self, index: int) -> QMetaMethod: ...
    def indexOfClassInfo(self, name: str) -> int: ...
    def indexOfProperty(self, name: str) -> int: ...
    def indexOfEnumerator(self, name: str) -> int: ...
    def indexOfSlot(self, slot: str) -> int: ...
    def indexOfSignal(self, signal: str) -> int: ...
    def indexOfMethod(self, method: str) -> int: ...
    def classInfoCount(self) -> int: ...
    def propertyCount(self) -> int: ...
    def enumeratorCount(self) -> int: ...
    def methodCount(self) -> int: ...
    def classInfoOffset(self) -> int: ...
    def propertyOffset(self) -> int: ...
    def enumeratorOffset(self) -> int: ...
    def methodOffset(self) -> int: ...
    def userProperty(self) -> QMetaProperty: ...
    def superClass(self) -> QMetaObject: ...
    def className(self) -> str: ...


class QGenericArgument(sip.simplewrapper): ...


class QGenericReturnArgument(sip.simplewrapper): ...


class QOperatingSystemVersion(sip.simplewrapper):

    OSType: typing.Type[int]
    #class OSType(int): ...
    Unknown = ... # type: int
    Windows = ... # type: int
    MacOS = ... # type: int
    IOS = ... # type: int
    TvOS = ... # type: int
    WatchOS = ... # type: int
    Android = ... # type: int

    AndroidJellyBean = ... # type: QOperatingSystemVersion
    AndroidJellyBean_MR1 = ... # type: QOperatingSystemVersion
    AndroidJellyBean_MR2 = ... # type: QOperatingSystemVersion
    AndroidKitKat = ... # type: QOperatingSystemVersion
    AndroidLollipop = ... # type: QOperatingSystemVersion
    AndroidLollipop_MR1 = ... # type: QOperatingSystemVersion
    AndroidMarshmallow = ... # type: QOperatingSystemVersion
    AndroidNougat = ... # type: QOperatingSystemVersion
    AndroidNougat_MR1 = ... # type: QOperatingSystemVersion
    AndroidOreo = ... # type: QOperatingSystemVersion
    MacOSHighSierra = ... # type: QOperatingSystemVersion
    MacOSMojave = ... # type: QOperatingSystemVersion
    MacOSSierra = ... # type: QOperatingSystemVersion
    OSXElCapitan = ... # type: QOperatingSystemVersion
    OSXMavericks = ... # type: QOperatingSystemVersion
    OSXYosemite = ... # type: QOperatingSystemVersion
    Windows10 = ... # type: QOperatingSystemVersion
    Windows7 = ... # type: QOperatingSystemVersion
    Windows8 = ... # type: QOperatingSystemVersion
    Windows8_1 = ... # type: QOperatingSystemVersion

    @overload
    def __init__(self, osType: int, vmajor: int, vminor: int = ..., vmicro: int = ...) -> None: ...
    @overload
    def __init__(self, a0: QOperatingSystemVersion) -> None: ...

    def name(self) -> str: ...
    def type(self) -> int: ...
    def segmentCount(self) -> int: ...
    def microVersion(self) -> int: ...
    def minorVersion(self) -> int: ...
    def majorVersion(self) -> int: ...
    @staticmethod
    def currentType() -> int: ...
    @staticmethod
    def current() -> QOperatingSystemVersion: ...


class QParallelAnimationGroup(QAnimationGroup):

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def updateDirection(self, direction: int) -> None: ...
    def updateState(self, newState: int, oldState: int) -> None: ...
    def updateCurrentTime(self, currentTime: int) -> None: ...
    def event(self, event: QEvent) -> bool: ...
    def duration(self) -> int: ...


class QPauseAnimation(QAbstractAnimation):

    @overload
    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, msecs: int, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def updateCurrentTime(self, a0: int) -> None: ...
    def event(self, e: QEvent) -> bool: ...
    def setDuration(self, msecs: int) -> None: ...
    def duration(self) -> int: ...


class QVariantAnimation(QAbstractAnimation):

    valueChanged: PYQT_SIGNAL

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def interpolated(self, from_: typing.Any, to: typing.Any, progress: float) -> typing.Any: ...
    def updateCurrentValue(self, value: typing.Any) -> None: ...
    def updateState(self, newState: int, oldState: int) -> None: ...
    def updateCurrentTime(self, a0: int) -> None: ...
    def event(self, event: QEvent) -> bool: ...
    #def valueChanged(self, value: typing.Any) -> None: ...
    def setEasingCurve(self, easing: typing.Union[QEasingCurve, int]) -> None: ...
    def easingCurve(self) -> QEasingCurve: ...
    def setDuration(self, msecs: int) -> None: ...
    def duration(self) -> int: ...
    def currentValue(self) -> typing.Any: ...
    def setKeyValues(self, values: typing.Iterable[typing.Tuple[float, typing.Any]]) -> None: ...
    def keyValues(self) -> typing.List[typing.Tuple[float, typing.Any]]: ...
    def setKeyValueAt(self, step: float, value: typing.Any) -> None: ...
    def keyValueAt(self, step: float) -> typing.Any: ...
    def setEndValue(self, value: typing.Any) -> None: ...
    def endValue(self) -> typing.Any: ...
    def setStartValue(self, value: typing.Any) -> None: ...
    def startValue(self) -> typing.Any: ...


class QPropertyAnimation(QVariantAnimation):

    @overload
    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, target: QObject, propertyName: typing.Union[QByteArray, bytes, bytearray], parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def updateState(self, newState: int, oldState: int) -> None: ...
    def updateCurrentValue(self, value: typing.Any) -> None: ...
    def event(self, event: QEvent) -> bool: ...
    def setPropertyName(self, propertyName: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    def propertyName(self) -> QByteArray: ...
    def setTargetObject(self, target: QObject) -> None: ...
    def targetObject(self) -> QObject: ...


class QPluginLoader(QObject):

    @overload
    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, fileName: str, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def loadHints(self) -> int: ...
    def setLoadHints(self, loadHints: typing.Union[int, int]) -> None: ...
    def errorString(self) -> str: ...
    def fileName(self) -> str: ...
    def setFileName(self, fileName: str) -> None: ...
    def isLoaded(self) -> bool: ...
    def unload(self) -> bool: ...
    def load(self) -> bool: ...
    @staticmethod
    def staticInstances() -> typing.List[QObject]: ...
    def instance(self) -> QObject: ...


class QPoint(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, xpos: int, ypos: int) -> None: ...
    @overload
    def __init__(self, a0: QPoint) -> None: ...

    def __neg__(self) -> QPoint: ...
    def __pos__(self) -> QPoint: ...
    @staticmethod
    def dotProduct(p1: QPoint, p2: QPoint) -> int: ...
    def setY(self, ypos: int) -> None: ...
    def setX(self, xpos: int) -> None: ...
    def y(self) -> int: ...
    def x(self) -> int: ...
    def __bool__(self) -> int: ...
    def isNull(self) -> bool: ...
    def __repr__(self) -> str: ...
    def manhattanLength(self) -> int: ...


class QPointF(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, xpos: float, ypos: float) -> None: ...
    @overload
    def __init__(self, p: QPoint) -> None: ...
    @overload
    def __init__(self, a0: QPointF) -> None: ...

    def __neg__(self) -> QPointF: ...
    def __pos__(self) -> QPointF: ...
    @staticmethod
    def dotProduct(p1: typing.Union[QPointF, QPoint], p2: typing.Union[QPointF, QPoint]) -> float: ...
    def manhattanLength(self) -> float: ...
    def toPoint(self) -> QPoint: ...
    def setY(self, ypos: float) -> None: ...
    def setX(self, xpos: float) -> None: ...
    def y(self) -> float: ...
    def x(self) -> float: ...
    def __bool__(self) -> int: ...
    def isNull(self) -> bool: ...
    def __repr__(self) -> str: ...


class _QProcessErrorMethod(PYQT_SIGNAL, typing.Callable[[], int]): ...


class QProcess(QIODevice):

    error: _QProcessErrorMethod
    errorOccurred: PYQT_SIGNAL
    finished: PYQT_SIGNAL
    readyReadStandardError: PYQT_SIGNAL
    readyReadStandardOutput: PYQT_SIGNAL
    started: PYQT_SIGNAL
    stateChanged: PYQT_SIGNAL

    InputChannelMode: typing.Type[int]
    #class InputChannelMode(int): ...
    ManagedInputChannel = ... # type: int
    ForwardedInputChannel = ... # type: int

    ProcessChannelMode: typing.Type[int]
    #class ProcessChannelMode(int): ...
    SeparateChannels = ... # type: int
    MergedChannels = ... # type: int
    ForwardedChannels = ... # type: int
    ForwardedOutputChannel = ... # type: int
    ForwardedErrorChannel = ... # type: int

    ProcessChannel: typing.Type[int]
    #class ProcessChannel(int): ...
    StandardOutput = ... # type: int
    StandardError = ... # type: int

    ProcessState: typing.Type[int]
    #class ProcessState(int): ...
    NotRunning = ... # type: int
    Starting = ... # type: int
    Running = ... # type: int

    ProcessError: typing.Type[int]
    #class ProcessError(int): ...
    FailedToStart = ... # type: int
    Crashed = ... # type: int
    Timedout = ... # type: int
    ReadError = ... # type: int
    WriteError = ... # type: int
    UnknownError = ... # type: int

    ExitStatus: typing.Type[int]
    #class ExitStatus(int): ...
    NormalExit = ... # type: int
    CrashExit = ... # type: int

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def processId(self) -> int: ...
    @staticmethod
    def nullDevice() -> str: ...
    def setInputChannelMode(self, mode: int) -> None: ...
    def inputChannelMode(self) -> int: ...
    def open(self, mode: typing.Union[int, int] = ...) -> bool: ...
    def setArguments(self, arguments: typing.Iterable[str]) -> None: ...
    def arguments(self) -> typing.List[str]: ...
    def setProgram(self, program: str) -> None: ...
    def program(self) -> str: ...
    def processEnvironment(self) -> QProcessEnvironment: ...
    def setProcessEnvironment(self, environment: QProcessEnvironment) -> None: ...
    def writeData(self, data: bytes) -> int: ...
    def readData(self, maxlen: int) -> bytes: ...
    def setupChildProcess(self) -> None: ...
    def setProcessState(self, state: int) -> None: ...
    #def errorOccurred(self, error: int) -> None: ...
    #def readyReadStandardError(self) -> None: ...
    #def readyReadStandardOutput(self) -> None: ...
    #def stateChanged(self, state: int) -> None: ...
    #def finished(self, exitCode: int, exitStatus: int) -> None: ...
    #def started(self) -> None: ...
    def kill(self) -> None: ...
    def terminate(self) -> None: ...
    def setStandardOutputProcess(self, destination: QProcess) -> None: ...
    def setStandardErrorFile(self, fileName: str, mode: typing.Union[int, int] = ...) -> None: ...
    def setStandardOutputFile(self, fileName: str, mode: typing.Union[int, int] = ...) -> None: ...
    def setStandardInputFile(self, fileName: str) -> None: ...
    def setProcessChannelMode(self, mode: int) -> None: ...
    def processChannelMode(self) -> int: ...
    @staticmethod
    def systemEnvironment() -> typing.List[str]: ...
    @overload
    @staticmethod
    def startDetached(program: str, arguments: typing.Iterable[str], workingDirectory: str) -> typing.Tuple[bool, int]: ...
    @overload
    @staticmethod
    def startDetached(program: str, arguments: typing.Iterable[str]) -> bool: ...
    @overload
    @staticmethod
    def startDetached(program: str) -> bool: ...
    #@overload
    #def startDetached(self) -> typing.Tuple[bool, int]: ...
    @overload
    @staticmethod
    def execute(program: str, arguments: typing.Iterable[str]) -> int: ...
    @overload
    @staticmethod
    def execute(program: str) -> int: ...
    def atEnd(self) -> bool: ...
    def close(self) -> None: ...
    def canReadLine(self) -> bool: ...
    def isSequential(self) -> bool: ...
    def bytesToWrite(self) -> int: ...
    def bytesAvailable(self) -> int: ...
    def exitStatus(self) -> int: ...
    def exitCode(self) -> int: ...
    def readAllStandardError(self) -> QByteArray: ...
    def readAllStandardOutput(self) -> QByteArray: ...
    def waitForFinished(self, msecs: int = ...) -> bool: ...
    def waitForBytesWritten(self, msecs: int = ...) -> bool: ...
    def waitForReadyRead(self, msecs: int = ...) -> bool: ...
    def waitForStarted(self, msecs: int = ...) -> bool: ...
    def pid(self) -> int: ...
    def state(self) -> int: ...
    #@overload
    #def error(self) -> int: ...
    #@overload
    #def error(self, error: int) -> None: ...
    def setWorkingDirectory(self, dir: str) -> None: ...
    def workingDirectory(self) -> str: ...
    def closeWriteChannel(self) -> None: ...
    def closeReadChannel(self, channel: int) -> None: ...
    def setReadChannel(self, channel: int) -> None: ...
    def readChannel(self) -> int: ...
    @overload
    def start(self, program: str, arguments: typing.Iterable[str], mode: typing.Union[int, int] = ...) -> None: ...
    @overload
    def start(self, command: str, mode: typing.Union[int, int] = ...) -> None: ...
    @overload
    def start(self, mode: typing.Union[int, int] = ...) -> None: ...


class QProcessEnvironment(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: QProcessEnvironment) -> None: ...

    def swap(self, other: QProcessEnvironment) -> None: ...
    def keys(self) -> typing.List[str]: ...
    @staticmethod
    def systemEnvironment() -> QProcessEnvironment: ...
    def toStringList(self) -> typing.List[str]: ...
    def value(self, name: str, defaultValue: str = ...) -> str: ...
    def remove(self, name: str) -> None: ...
    @overload
    def insert(self, name: str, value: str) -> None: ...
    @overload
    def insert(self, e: QProcessEnvironment) -> None: ...
    def contains(self, name: str) -> bool: ...
    def clear(self) -> None: ...
    def isEmpty(self) -> bool: ...


class QRandomGenerator(sip.simplewrapper):

    @overload
    def __init__(self, seed: int = ...) -> None: ...
    @overload
    def __init__(self, other: QRandomGenerator) -> None: ...

    @staticmethod
    def securelySeeded() -> QRandomGenerator: ...
    @staticmethod
    def global_() -> QRandomGenerator: ...
    @staticmethod
    def system() -> QRandomGenerator: ...
    @staticmethod
    def max() -> int: ...
    @staticmethod
    def min() -> int: ...
    def discard(self, z: int) -> None: ...
    def seed(self, seed: int = ...) -> None: ...
    def __call__(self) -> int: ...
    @overload
    def bounded(self, highest: float) -> float: ...
    @overload
    def bounded(self, highest: int) -> int: ...
    @overload
    def bounded(self, lowest: int, highest: int) -> int: ...
    def generateDouble(self) -> float: ...
    def generate64(self) -> int: ...
    def generate(self) -> int: ...


class QReadWriteLock(sip.simplewrapper):

    RecursionMode: typing.Type[int]
    #class RecursionMode(int): ...
    NonRecursive = ... # type: int
    Recursive = ... # type: int

    def __init__(self, recursionMode: int = ...) -> None: ...

    def unlock(self) -> None: ...
    @overload
    def tryLockForWrite(self) -> bool: ...
    @overload
    def tryLockForWrite(self, timeout: int) -> bool: ...
    def lockForWrite(self) -> None: ...
    @overload
    def tryLockForRead(self) -> bool: ...
    @overload
    def tryLockForRead(self, timeout: int) -> bool: ...
    def lockForRead(self) -> None: ...


class QReadLocker(sip.simplewrapper):

    def __init__(self, areadWriteLock: QReadWriteLock) -> None: ...

    def __exit__(self, type: typing.Any, value: typing.Any, traceback: typing.Any) -> None: ...
    def __enter__(self) -> typing.Any: ...
    def readWriteLock(self) -> QReadWriteLock: ...
    def relock(self) -> None: ...
    def unlock(self) -> None: ...


class QWriteLocker(sip.simplewrapper):

    def __init__(self, areadWriteLock: QReadWriteLock) -> None: ...

    def __exit__(self, type: typing.Any, value: typing.Any, traceback: typing.Any) -> None: ...
    def __enter__(self) -> typing.Any: ...
    def readWriteLock(self) -> QReadWriteLock: ...
    def relock(self) -> None: ...
    def unlock(self) -> None: ...


class QRect(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, aleft: int, atop: int, awidth: int, aheight: int) -> None: ...
    @overload
    def __init__(self, atopLeft: QPoint, abottomRight: QPoint) -> None: ...
    @overload
    def __init__(self, atopLeft: QPoint, asize: QSize) -> None: ...
    @overload
    def __init__(self, a0: QRect) -> None: ...

    def transposed(self) -> QRect: ...
    def marginsRemoved(self, margins: QMargins) -> QRect: ...
    def marginsAdded(self, margins: QMargins) -> QRect: ...
    def united(self, r: QRect) -> QRect: ...
    def intersected(self, other: QRect) -> QRect: ...
    def setSize(self, s: QSize) -> None: ...
    def setHeight(self, h: int) -> None: ...
    def setWidth(self, w: int) -> None: ...
    def adjust(self, dx1: int, dy1: int, dx2: int, dy2: int) -> None: ...
    def adjusted(self, xp1: int, yp1: int, xp2: int, yp2: int) -> QRect: ...
    def setCoords(self, xp1: int, yp1: int, xp2: int, yp2: int) -> None: ...
    def getCoords(self) -> typing.Tuple[int, int, int, int]: ...
    def setRect(self, ax: int, ay: int, aw: int, ah: int) -> None: ...
    def getRect(self) -> typing.Tuple[int, int, int, int]: ...
    def moveBottomLeft(self, p: QPoint) -> None: ...
    def moveTopRight(self, p: QPoint) -> None: ...
    def moveBottomRight(self, p: QPoint) -> None: ...
    def moveTopLeft(self, p: QPoint) -> None: ...
    def moveBottom(self, pos: int) -> None: ...
    def moveRight(self, pos: int) -> None: ...
    def moveTop(self, pos: int) -> None: ...
    def moveLeft(self, pos: int) -> None: ...
    @overload
    def moveTo(self, ax: int, ay: int) -> None: ...
    @overload
    def moveTo(self, p: QPoint) -> None: ...
    @overload
    def translated(self, dx: int, dy: int) -> QRect: ...
    @overload
    def translated(self, p: QPoint) -> QRect: ...
    @overload
    def translate(self, dx: int, dy: int) -> None: ...
    @overload
    def translate(self, p: QPoint) -> None: ...
    def size(self) -> QSize: ...
    def height(self) -> int: ...
    def width(self) -> int: ...
    def center(self) -> QPoint: ...
    def bottomLeft(self) -> QPoint: ...
    def topRight(self) -> QPoint: ...
    def bottomRight(self) -> QPoint: ...
    def topLeft(self) -> QPoint: ...
    def setY(self, ay: int) -> None: ...
    def setX(self, ax: int) -> None: ...
    def setBottomLeft(self, p: QPoint) -> None: ...
    def setTopRight(self, p: QPoint) -> None: ...
    def setBottomRight(self, p: QPoint) -> None: ...
    def setTopLeft(self, p: QPoint) -> None: ...
    def setBottom(self, pos: int) -> None: ...
    def setRight(self, pos: int) -> None: ...
    def setTop(self, pos: int) -> None: ...
    def setLeft(self, pos: int) -> None: ...
    def y(self) -> int: ...
    def x(self) -> int: ...
    def bottom(self) -> int: ...
    def right(self) -> int: ...
    def top(self) -> int: ...
    def left(self) -> int: ...
    def __bool__(self) -> int: ...
    def isValid(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isNull(self) -> bool: ...
    def __repr__(self) -> str: ...
    def intersects(self, r: QRect) -> bool: ...
    @overload
    def __contains__(self, p: QPoint) -> int: ...
    @overload
    def __contains__(self, r: QRect) -> int: ...
    @overload
    def contains(self, point: QPoint, proper: bool = ...) -> bool: ...
    @overload
    def contains(self, rectangle: QRect, proper: bool = ...) -> bool: ...
    @overload
    def contains(self, ax: int, ay: int, aproper: bool) -> bool: ...
    @overload
    def contains(self, ax: int, ay: int) -> bool: ...
    def moveCenter(self, p: QPoint) -> None: ...
    def normalized(self) -> QRect: ...


class QRectF(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, atopLeft: typing.Union[QPointF, QPoint], asize: QSizeF) -> None: ...
    @overload
    def __init__(self, atopLeft: typing.Union[QPointF, QPoint], abottomRight: typing.Union[QPointF, QPoint]) -> None: ...
    @overload
    def __init__(self, aleft: float, atop: float, awidth: float, aheight: float) -> None: ...
    @overload
    def __init__(self, r: QRect) -> None: ...
    @overload
    def __init__(self, a0: QRectF) -> None: ...

    def transposed(self) -> QRectF: ...
    def marginsRemoved(self, margins: QMarginsF) -> QRectF: ...
    def marginsAdded(self, margins: QMarginsF) -> QRectF: ...
    def toRect(self) -> QRect: ...
    def toAlignedRect(self) -> QRect: ...
    def united(self, r: QRectF) -> QRectF: ...
    def intersected(self, r: QRectF) -> QRectF: ...
    def setSize(self, s: QSizeF) -> None: ...
    def setHeight(self, ah: float) -> None: ...
    def setWidth(self, aw: float) -> None: ...
    def adjusted(self, xp1: float, yp1: float, xp2: float, yp2: float) -> QRectF: ...
    def adjust(self, xp1: float, yp1: float, xp2: float, yp2: float) -> None: ...
    def setCoords(self, xp1: float, yp1: float, xp2: float, yp2: float) -> None: ...
    def getCoords(self) -> typing.Tuple[float, float, float, float]: ...
    def setRect(self, ax: float, ay: float, aaw: float, aah: float) -> None: ...
    def getRect(self) -> typing.Tuple[float, float, float, float]: ...
    @overload
    def translated(self, dx: float, dy: float) -> QRectF: ...
    @overload
    def translated(self, p: typing.Union[QPointF, QPoint]) -> QRectF: ...
    @overload
    def moveTo(self, ax: float, ay: float) -> None: ...
    @overload
    def moveTo(self, p: typing.Union[QPointF, QPoint]) -> None: ...
    @overload
    def translate(self, dx: float, dy: float) -> None: ...
    @overload
    def translate(self, p: typing.Union[QPointF, QPoint]) -> None: ...
    def size(self) -> QSizeF: ...
    def height(self) -> float: ...
    def width(self) -> float: ...
    def moveCenter(self, p: typing.Union[QPointF, QPoint]) -> None: ...
    def moveBottomRight(self, p: typing.Union[QPointF, QPoint]) -> None: ...
    def moveBottomLeft(self, p: typing.Union[QPointF, QPoint]) -> None: ...
    def moveTopRight(self, p: typing.Union[QPointF, QPoint]) -> None: ...
    def moveTopLeft(self, p: typing.Union[QPointF, QPoint]) -> None: ...
    def moveBottom(self, pos: float) -> None: ...
    def moveRight(self, pos: float) -> None: ...
    def moveTop(self, pos: float) -> None: ...
    def moveLeft(self, pos: float) -> None: ...
    def center(self) -> QPointF: ...
    def setBottomRight(self, p: typing.Union[QPointF, QPoint]) -> None: ...
    def setBottomLeft(self, p: typing.Union[QPointF, QPoint]) -> None: ...
    def setTopRight(self, p: typing.Union[QPointF, QPoint]) -> None: ...
    def setTopLeft(self, p: typing.Union[QPointF, QPoint]) -> None: ...
    def setBottom(self, pos: float) -> None: ...
    def setTop(self, pos: float) -> None: ...
    def setRight(self, pos: float) -> None: ...
    def setLeft(self, pos: float) -> None: ...
    def y(self) -> float: ...
    def x(self) -> float: ...
    def __bool__(self) -> int: ...
    def isValid(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isNull(self) -> bool: ...
    def intersects(self, r: QRectF) -> bool: ...
    @overload
    def __contains__(self, p: typing.Union[QPointF, QPoint]) -> int: ...
    @overload
    def __contains__(self, r: QRectF) -> int: ...
    @overload
    def contains(self, p: typing.Union[QPointF, QPoint]) -> bool: ...
    @overload
    def contains(self, r: QRectF) -> bool: ...
    @overload
    def contains(self, ax: float, ay: float) -> bool: ...
    def bottomLeft(self) -> QPointF: ...
    def topRight(self) -> QPointF: ...
    def bottomRight(self) -> QPointF: ...
    def topLeft(self) -> QPointF: ...
    def setY(self, pos: float) -> None: ...
    def setX(self, pos: float) -> None: ...
    def bottom(self) -> float: ...
    def right(self) -> float: ...
    def top(self) -> float: ...
    def left(self) -> float: ...
    def normalized(self) -> QRectF: ...
    def __repr__(self) -> str: ...


class QRegExp(sip.simplewrapper):

    CaretMode: typing.Type[int]
    #class CaretMode(int): ...
    CaretAtZero = ... # type: int
    CaretAtOffset = ... # type: int
    CaretWontMatch = ... # type: int

    PatternSyntax: typing.Type[int]
    #class PatternSyntax(int): ...
    RegExp = ... # type: int
    RegExp2 = ... # type: int
    Wildcard = ... # type: int
    FixedString = ... # type: int
    WildcardUnix = ... # type: int
    W3CXmlSchema11 = ... # type: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pattern: str, cs: int = ..., syntax: int = ...) -> None: ...
    @overload
    def __init__(self, rx: QRegExp) -> None: ...

    def __hash__(self) -> int: ...
    def swap(self, other: QRegExp) -> None: ...
    def captureCount(self) -> int: ...
    @staticmethod
    def escape(str: str) -> str: ...
    def errorString(self) -> str: ...
    def pos(self, nth: int = ...) -> int: ...
    def cap(self, nth: int = ...) -> str: ...
    def capturedTexts(self) -> typing.List[str]: ...
    def matchedLength(self) -> int: ...
    def lastIndexIn(self, str: str, offset: int = ..., caretMode: int = ...) -> int: ...
    def indexIn(self, str: str, offset: int = ..., caretMode: int = ...) -> int: ...
    def exactMatch(self, str: str) -> bool: ...
    def setMinimal(self, minimal: bool) -> None: ...
    def isMinimal(self) -> bool: ...
    def setPatternSyntax(self, syntax: int) -> None: ...
    def patternSyntax(self) -> int: ...
    def setCaseSensitivity(self, cs: int) -> None: ...
    def caseSensitivity(self) -> int: ...
    def setPattern(self, pattern: str) -> None: ...
    def pattern(self) -> str: ...
    def isValid(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def __repr__(self) -> str: ...


class QRegularExpression(sip.simplewrapper):

    MatchOption: typing.Type[int]
    #class MatchOption(int): ...
    NoMatchOption = ... # type: int
    AnchoredMatchOption = ... # type: int
    DontCheckSubjectStringMatchOption = ... # type: int

    MatchType: typing.Type[int]
    #class MatchType(int): ...
    NormalMatch = ... # type: int
    PartialPreferCompleteMatch = ... # type: int
    PartialPreferFirstMatch = ... # type: int
    NoMatch = ... # type: int

    PatternOption: typing.Type[int]
    #class PatternOption(int): ...
    NoPatternOption = ... # type: int
    CaseInsensitiveOption = ... # type: int
    DotMatchesEverythingOption = ... # type: int
    MultilineOption = ... # type: int
    ExtendedPatternSyntaxOption = ... # type: int
    InvertedGreedinessOption = ... # type: int
    DontCaptureOption = ... # type: int
    UseUnicodePropertiesOption = ... # type: int
    OptimizeOnFirstUsageOption = ... # type: int
    DontAutomaticallyOptimizeOption = ... # type: int

    PatternOptions: typing.Type[int]
    #class PatternOptions(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QRegularExpression.PatternOptions, QRegularExpression.PatternOption]) -> None: ...
        #@overload
        #def __init__(self, a0: QRegularExpression.PatternOptions) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QRegularExpression.PatternOptions: ...
        #def __int__(self) -> int: ...

    MatchOptions: typing.Type[int]
    #class MatchOptions(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QRegularExpression.MatchOptions, QRegularExpression.MatchOption]) -> None: ...
        #@overload
        #def __init__(self, a0: QRegularExpression.MatchOptions) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QRegularExpression.MatchOptions: ...
        #def __int__(self) -> int: ...

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pattern: str, options: typing.Union[int, int] = ...) -> None: ...
    @overload
    def __init__(self, re: QRegularExpression) -> None: ...

    @staticmethod
    def anchoredPattern(expression: str) -> str: ...
    @staticmethod
    def wildcardToRegularExpression(str: str) -> str: ...
    def __hash__(self) -> int: ...
    def optimize(self) -> None: ...
    def namedCaptureGroups(self) -> typing.List[str]: ...
    @staticmethod
    def escape(str: str) -> str: ...
    def globalMatch(self, subject: str, offset: int = ..., matchType: int = ..., matchOptions: typing.Union[int, int] = ...) -> QRegularExpressionMatchIterator: ...
    def match(self, subject: str, offset: int = ..., matchType: int = ..., matchOptions: typing.Union[int, int] = ...) -> QRegularExpressionMatch: ...
    def captureCount(self) -> int: ...
    def errorString(self) -> str: ...
    def patternErrorOffset(self) -> int: ...
    def isValid(self) -> bool: ...
    def setPattern(self, pattern: str) -> None: ...
    def pattern(self) -> str: ...
    def swap(self, re: QRegularExpression) -> None: ...
    def __repr__(self) -> str: ...
    def setPatternOptions(self, options: typing.Union[int, int]) -> None: ...
    def patternOptions(self) -> int: ...


class QRegularExpressionMatch(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, match: QRegularExpressionMatch) -> None: ...

    @overload
    def capturedEnd(self, nth: int = ...) -> int: ...
    @overload
    def capturedEnd(self, name: str) -> int: ...
    @overload
    def capturedLength(self, nth: int = ...) -> int: ...
    @overload
    def capturedLength(self, name: str) -> int: ...
    @overload
    def capturedStart(self, nth: int = ...) -> int: ...
    @overload
    def capturedStart(self, name: str) -> int: ...
    def capturedTexts(self) -> typing.List[str]: ...
    @overload
    def captured(self, nth: int = ...) -> str: ...
    @overload
    def captured(self, name: str) -> str: ...
    def lastCapturedIndex(self) -> int: ...
    def isValid(self) -> bool: ...
    def hasPartialMatch(self) -> bool: ...
    def hasMatch(self) -> bool: ...
    def matchOptions(self) -> int: ...
    def matchType(self) -> int: ...
    def regularExpression(self) -> QRegularExpression: ...
    def swap(self, match: QRegularExpressionMatch) -> None: ...


class QRegularExpressionMatchIterator(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, iterator: QRegularExpressionMatchIterator) -> None: ...

    def matchOptions(self) -> int: ...
    def matchType(self) -> int: ...
    def regularExpression(self) -> QRegularExpression: ...
    def peekNext(self) -> QRegularExpressionMatch: ...
    def next(self) -> QRegularExpressionMatch: ...
    def hasNext(self) -> bool: ...
    def isValid(self) -> bool: ...
    def swap(self, iterator: QRegularExpressionMatchIterator) -> None: ...


class QResource(sip.simplewrapper):

    def __init__(self, fileName: str = ..., locale: QLocale = ...) -> None: ...

    def lastModified(self) -> QDateTime: ...
    def isFile(self) -> bool: ...
    def isDir(self) -> bool: ...
    def children(self) -> typing.List[str]: ...
    @staticmethod
    def unregisterResourceData(rccData: bytes, mapRoot: str = ...) -> bool: ...
    @staticmethod
    def unregisterResource(rccFileName: str, mapRoot: str = ...) -> bool: ...
    @staticmethod
    def registerResourceData(rccData: bytes, mapRoot: str = ...) -> bool: ...
    @staticmethod
    def registerResource(rccFileName: str, mapRoot: str = ...) -> bool: ...
    def size(self) -> int: ...
    def setLocale(self, locale: QLocale) -> None: ...
    def setFileName(self, file: str) -> None: ...
    def locale(self) -> QLocale: ...
    def isValid(self) -> bool: ...
    def isCompressed(self) -> bool: ...
    def fileName(self) -> str: ...
    def data(self) -> bytes: ...
    def absoluteFilePath(self) -> str: ...


class QRunnable(sip.wrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QRunnable) -> None: ...

    def setAutoDelete(self, _autoDelete: bool) -> None: ...
    def autoDelete(self) -> bool: ...
    def run(self) -> None: ...


class QSaveFile(QFileDevice):

    @overload
    def __init__(self, name: str, **props) -> None: ...
    @overload
    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, name: str, parent: QObject, **props) -> None: ...

    def writeData(self, data: bytes) -> int: ...
    def directWriteFallback(self) -> bool: ...
    def setDirectWriteFallback(self, enabled: bool) -> None: ...
    def cancelWriting(self) -> None: ...
    def commit(self) -> bool: ...
    def open(self, flags: typing.Union[int, int]) -> bool: ...
    def setFileName(self, name: str) -> None: ...
    def fileName(self) -> str: ...


class QSemaphore(sip.simplewrapper):

    def __init__(self, n: int = ...) -> None: ...

    def available(self) -> int: ...
    def release(self, n: int = ...) -> None: ...
    @overload
    def tryAcquire(self, n: int = ...) -> bool: ...
    @overload
    def tryAcquire(self, n: int, timeout: int) -> bool: ...
    def acquire(self, n: int = ...) -> None: ...


class QSemaphoreReleaser(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, sem: QSemaphore, n: int = ...) -> None: ...

    def cancel(self) -> QSemaphore: ...
    def semaphore(self) -> QSemaphore: ...
    def swap(self, other: QSemaphoreReleaser) -> None: ...


class QSequentialAnimationGroup(QAnimationGroup):

    currentAnimationChanged: PYQT_SIGNAL

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def updateDirection(self, direction: int) -> None: ...
    def updateState(self, newState: int, oldState: int) -> None: ...
    def updateCurrentTime(self, a0: int) -> None: ...
    def event(self, event: QEvent) -> bool: ...
    #def currentAnimationChanged(self, current: QAbstractAnimation) -> None: ...
    def duration(self) -> int: ...
    def currentAnimation(self) -> QAbstractAnimation: ...
    def insertPause(self, index: int, msecs: int) -> QPauseAnimation: ...
    def addPause(self, msecs: int) -> QPauseAnimation: ...


class QSettings(QObject):

    Scope: typing.Type[int]
    #class Scope(int): ...
    UserScope = ... # type: int
    SystemScope = ... # type: int

    Format: typing.Type[int]
    #class Format(int): ...
    NativeFormat = ... # type: int
    IniFormat = ... # type: int
    InvalidFormat = ... # type: int

    Status: typing.Type[int]
    #class Status(int): ...
    NoError = ... # type: int
    AccessError = ... # type: int
    FormatError = ... # type: int

    @overload
    def __init__(self, organization: str, application: str = ..., parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, scope: int, organization: str, application: str = ..., parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, format: int, scope: int, organization: str, application: str = ..., parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, fileName: str, format: int, parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def event(self, event: QEvent) -> bool: ...
    def setAtomicSyncRequired(self, enable: bool) -> None: ...
    def isAtomicSyncRequired(self) -> bool: ...
    def iniCodec(self) -> QTextCodec: ...
    @overload
    def setIniCodec(self, codec: QTextCodec) -> None: ...
    @overload
    def setIniCodec(self, codecName: str) -> None: ...
    @staticmethod
    def defaultFormat() -> int: ...
    @staticmethod
    def setDefaultFormat(format: int) -> None: ...
    def applicationName(self) -> str: ...
    def organizationName(self) -> str: ...
    def scope(self) -> int: ...
    def format(self) -> int: ...
    @staticmethod
    def setPath(format: int, scope: int, path: str) -> None: ...
    def fileName(self) -> str: ...
    def fallbacksEnabled(self) -> bool: ...
    def setFallbacksEnabled(self, b: bool) -> None: ...
    def contains(self, key: str) -> bool: ...
    def remove(self, key: str) -> None: ...
    def value(self, key: str, defaultValue: typing.Any = ..., type: type = ...) -> typing.Any: ...
    def setValue(self, key: str, value: typing.Any) -> None: ...
    def isWritable(self) -> bool: ...
    def childGroups(self) -> typing.List[str]: ...
    def childKeys(self) -> typing.List[str]: ...
    def allKeys(self) -> typing.List[str]: ...
    def setArrayIndex(self, i: int) -> None: ...
    def endArray(self) -> None: ...
    def beginWriteArray(self, prefix: str, size: int = ...) -> None: ...
    def beginReadArray(self, prefix: str) -> int: ...
    def group(self) -> str: ...
    def endGroup(self) -> None: ...
    def beginGroup(self, prefix: str) -> None: ...
    def status(self) -> int: ...
    def sync(self) -> None: ...
    def clear(self) -> None: ...


class QSharedMemory(QObject):

    SharedMemoryError: typing.Type[int]
    #class SharedMemoryError(int): ...
    NoError = ... # type: int
    PermissionDenied = ... # type: int
    InvalidSize = ... # type: int
    KeyError = ... # type: int
    AlreadyExists = ... # type: int
    NotFound = ... # type: int
    LockError = ... # type: int
    OutOfResources = ... # type: int
    UnknownError = ... # type: int

    AccessMode: typing.Type[int]
    #class AccessMode(int): ...
    ReadOnly = ... # type: int
    ReadWrite = ... # type: int

    @overload
    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, key: str, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def nativeKey(self) -> str: ...
    def setNativeKey(self, key: str) -> None: ...
    def errorString(self) -> str: ...
    def error(self) -> int: ...
    def unlock(self) -> bool: ...
    def lock(self) -> bool: ...
    def constData(self) -> sip.voidptr: ...
    def data(self) -> sip.voidptr: ...
    def detach(self) -> bool: ...
    def isAttached(self) -> bool: ...
    def attach(self, mode: int = ...) -> bool: ...
    def size(self) -> int: ...
    def create(self, size: int, mode: int = ...) -> bool: ...
    def key(self) -> str: ...
    def setKey(self, key: str) -> None: ...


class QSignalMapper(QObject):

    mapped: PYQT_SIGNAL

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    @overload
    def map(self) -> None: ...
    @overload
    def map(self, sender: QObject) -> None: ...
    #@overload
    #def mapped(self, a0: int) -> None: ...
    #@overload
    #def mapped(self, a0: str) -> None: ...
    #@overload
    #def mapped(self, a0: QWidget) -> None: ...
    #@overload
    #def mapped(self, a0: QObject) -> None: ...
    @overload
    def mapping(self, id: int) -> QObject: ...
    @overload
    def mapping(self, text: str) -> QObject: ...
    @overload
    def mapping(self, widget: QWidget) -> QObject: ...
    @overload
    def mapping(self, object: QObject) -> QObject: ...
    def removeMappings(self, sender: QObject) -> None: ...
    @overload
    def setMapping(self, sender: QObject, id: int) -> None: ...
    @overload
    def setMapping(self, sender: QObject, text: str) -> None: ...
    @overload
    def setMapping(self, sender: QObject, widget: QWidget) -> None: ...
    @overload
    def setMapping(self, sender: QObject, object: QObject) -> None: ...


class QSignalTransition(QAbstractTransition):

    senderObjectChanged: PYQT_SIGNAL
    signalChanged: PYQT_SIGNAL

    @overload
    def __init__(self, sourceState: typing.Optional[QState] = ..., **props) -> None: ...
    @overload
    def __init__(self, signal: pyqtBoundSignal, sourceState: typing.Optional[QState] = ..., **props) -> None: ...

    #def signalChanged(self) -> None: ...
    #def senderObjectChanged(self) -> None: ...
    def event(self, e: QEvent) -> bool: ...
    def onTransition(self, event: QEvent) -> None: ...
    def eventTest(self, event: QEvent) -> bool: ...
    def setSignal(self, signal: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    def signal(self) -> QByteArray: ...
    def setSenderObject(self, sender: QObject) -> None: ...
    def senderObject(self) -> QObject: ...


class QSize(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, w: int, h: int) -> None: ...
    @overload
    def __init__(self, a0: QSize) -> None: ...

    def transposed(self) -> QSize: ...
    @overload
    def scaled(self, s: QSize, mode: int) -> QSize: ...
    @overload
    def scaled(self, w: int, h: int, mode: int) -> QSize: ...
    def boundedTo(self, otherSize: QSize) -> QSize: ...
    def expandedTo(self, otherSize: QSize) -> QSize: ...
    def setHeight(self, h: int) -> None: ...
    def setWidth(self, w: int) -> None: ...
    def height(self) -> int: ...
    def width(self) -> int: ...
    def __bool__(self) -> int: ...
    def isValid(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isNull(self) -> bool: ...
    def __repr__(self) -> str: ...
    @overload
    def scale(self, s: QSize, mode: int) -> None: ...
    @overload
    def scale(self, w: int, h: int, mode: int) -> None: ...
    def transpose(self) -> None: ...

    def __add__(self, other: QSize) -> QSize: ...
    def __sub__(self, other: QSize) -> QSize: ...
    def __mul__(self, other: typing.Union[int, float]) -> QSize: ...
    def __truediv__(self, other: typing.Union[int, float]) -> QSize: ...


class QSizeF(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, sz: QSize) -> None: ...
    @overload
    def __init__(self, w: float, h: float) -> None: ...
    @overload
    def __init__(self, a0: QSizeF) -> None: ...

    def transposed(self) -> QSizeF: ...
    @overload
    def scaled(self, s: QSizeF, mode: int) -> QSizeF: ...
    @overload
    def scaled(self, w: float, h: float, mode: int) -> QSizeF: ...
    def toSize(self) -> QSize: ...
    def boundedTo(self, otherSize: QSizeF) -> QSizeF: ...
    def expandedTo(self, otherSize: QSizeF) -> QSizeF: ...
    def setHeight(self, h: float) -> None: ...
    def setWidth(self, w: float) -> None: ...
    def height(self) -> float: ...
    def width(self) -> float: ...
    def __bool__(self) -> int: ...
    def isValid(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def isNull(self) -> bool: ...
    def __repr__(self) -> str: ...
    @overload
    def scale(self, s: QSizeF, mode: int) -> None: ...
    @overload
    def scale(self, w: float, h: float, mode: int) -> None: ...
    def transpose(self) -> None: ...

    def __add__(self, other: QSizeF) -> QSizeF: ...
    def __sub__(self, other: QSizeF) -> QSizeF: ...
    def __mul__(self, other: typing.Union[int, float]) -> QSizeF: ...
    def __truediv__(self, other: typing.Union[int, float]) -> QSizeF: ...


class QSocketNotifier(QObject):

    activated: PYQT_SIGNAL

    Type: typing.Type[int]
    #class Type(int): ...
    Read = ... # type: int
    Write = ... # type: int
    Exception = ... # type: int

    def __init__(self, socket: int, a1: int, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def event(self, a0: QEvent) -> bool: ...
    #def activated(self, socket: int) -> None: ...
    def setEnabled(self, a0: bool) -> None: ...
    def isEnabled(self) -> bool: ...
    def type(self) -> int: ...
    def socket(self) -> int: ...


class QSortFilterProxyModel(QAbstractProxyModel):

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def invalidateFilter(self) -> None: ...
    def setRecursiveFilteringEnabled(self, recursive: bool) -> None: ...
    def isRecursiveFilteringEnabled(self) -> bool: ...
    def sibling(self, row: int, column: int, idx: QModelIndex) -> QModelIndex: ...
    def setSortLocaleAware(self, on: bool) -> None: ...
    def isSortLocaleAware(self) -> bool: ...
    def supportedDropActions(self) -> int: ...
    def mimeTypes(self) -> typing.List[str]: ...
    def setFilterRole(self, role: int) -> None: ...
    def filterRole(self) -> int: ...
    def sortOrder(self) -> int: ...
    def sortColumn(self) -> int: ...
    def setSortRole(self, role: int) -> None: ...
    def sortRole(self) -> int: ...
    def setDynamicSortFilter(self, enable: bool) -> None: ...
    def dynamicSortFilter(self) -> bool: ...
    def setSortCaseSensitivity(self, cs: int) -> None: ...
    def sortCaseSensitivity(self) -> int: ...
    def sort(self, column: int, order: int = ...) -> None: ...
    def match(self, start: QModelIndex, role: int, value: typing.Any, hits: int = ..., flags: typing.Union[int, int] = ...) -> typing.List[QModelIndex]: ...
    def span(self, index: QModelIndex) -> QSize: ...
    def buddy(self, index: QModelIndex) -> QModelIndex: ...
    def flags(self, index: QModelIndex) -> int: ...
    def canFetchMore(self, parent: QModelIndex) -> bool: ...
    def fetchMore(self, parent: QModelIndex) -> None: ...
    def removeColumns(self, column: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def removeRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def insertColumns(self, column: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def insertRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def dropMimeData(self, data: QMimeData, action: int, row: int, column: int, parent: QModelIndex) -> bool: ...
    def mimeData(self, indexes: typing.Iterable[QModelIndex]) -> QMimeData: ...
    def setHeaderData(self, section: int, orientation: int, value: typing.Any, role: int = ...) -> bool: ...
    def headerData(self, section: int, orientation: int, role: int = ...) -> typing.Any: ...
    def setData(self, index: QModelIndex, value: typing.Any, role: int = ...) -> bool: ...
    def data(self, index: QModelIndex, role: int = ...) -> typing.Any: ...
    def hasChildren(self, parent: QModelIndex = ...) -> bool: ...
    def columnCount(self, parent: QModelIndex = ...) -> int: ...
    def rowCount(self, parent: QModelIndex = ...) -> int: ...
    @overload
    def parent(self, child: QModelIndex) -> QModelIndex: ...
    @overload
    def parent(self) -> QObject: ...
    def index(self, row: int, column: int, parent: QModelIndex = ...) -> QModelIndex: ...
    def lessThan(self, left: QModelIndex, right: QModelIndex) -> bool: ...
    def filterAcceptsColumn(self, source_column: int, source_parent: QModelIndex) -> bool: ...
    def filterAcceptsRow(self, source_row: int, source_parent: QModelIndex) -> bool: ...
    def setFilterWildcard(self, pattern: str) -> None: ...
    @overload
    def setFilterRegularExpression(self, regularExpression: QRegularExpression) -> None: ...
    @overload
    def setFilterRegularExpression(self, pattern: str) -> None: ...
    @overload
    def setFilterRegExp(self, regExp: QRegExp) -> None: ...
    @overload
    def setFilterRegExp(self, pattern: str) -> None: ...
    def setFilterFixedString(self, pattern: str) -> None: ...
    def invalidate(self) -> None: ...
    def setFilterCaseSensitivity(self, cs: int) -> None: ...
    def filterCaseSensitivity(self) -> int: ...
    def setFilterKeyColumn(self, column: int) -> None: ...
    def filterKeyColumn(self) -> int: ...
    def filterRegularExpression(self) -> QRegularExpression: ...
    def filterRegExp(self) -> QRegExp: ...
    def mapSelectionFromSource(self, sourceSelection: QItemSelection) -> QItemSelection: ...
    def mapSelectionToSource(self, proxySelection: QItemSelection) -> QItemSelection: ...
    def mapFromSource(self, sourceIndex: QModelIndex) -> QModelIndex: ...
    def mapToSource(self, proxyIndex: QModelIndex) -> QModelIndex: ...
    def setSourceModel(self, sourceModel: QAbstractItemModel) -> None: ...


class QStandardPaths(sip.simplewrapper):

    LocateOption: typing.Type[int]
    #class LocateOption(int): ...
    LocateFile = ... # type: int
    LocateDirectory = ... # type: int

    StandardLocation: typing.Type[int]
    #class StandardLocation(int): ...
    DesktopLocation = ... # type: int
    DocumentsLocation = ... # type: int
    FontsLocation = ... # type: int
    ApplicationsLocation = ... # type: int
    MusicLocation = ... # type: int
    MoviesLocation = ... # type: int
    PicturesLocation = ... # type: int
    TempLocation = ... # type: int
    HomeLocation = ... # type: int
    DataLocation = ... # type: int
    CacheLocation = ... # type: int
    GenericDataLocation = ... # type: int
    RuntimeLocation = ... # type: int
    ConfigLocation = ... # type: int
    DownloadLocation = ... # type: int
    GenericCacheLocation = ... # type: int
    GenericConfigLocation = ... # type: int
    AppDataLocation = ... # type: int
    AppLocalDataLocation = ... # type: int
    AppConfigLocation = ... # type: int

    LocateOptions: typing.Type[int]
    #class LocateOptions(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QStandardPaths.LocateOptions, QStandardPaths.LocateOption]) -> None: ...
        #@overload
        #def __init__(self, a0: QStandardPaths.LocateOptions) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QStandardPaths.LocateOptions: ...
        #def __int__(self) -> int: ...

    def __init__(self, a0: QStandardPaths) -> None: ...

    @staticmethod
    def setTestModeEnabled(testMode: bool) -> None: ...
    @staticmethod
    def enableTestMode(testMode: bool) -> None: ...
    @staticmethod
    def findExecutable(executableName: str, paths: typing.Iterable[str] = ...) -> str: ...
    @staticmethod
    def displayName(type: int) -> str: ...
    @staticmethod
    def locateAll(type: int, fileName: str, options: int = ...) -> typing.List[str]: ...
    @staticmethod
    def locate(type: int, fileName: str, options: int = ...) -> str: ...
    @staticmethod
    def standardLocations(type: int) -> typing.List[str]: ...
    @staticmethod
    def writableLocation(type: int) -> str: ...


class QState(QAbstractState):

    childModeChanged: PYQT_SIGNAL
    errorStateChanged: PYQT_SIGNAL
    finished: PYQT_SIGNAL
    initialStateChanged: PYQT_SIGNAL
    propertiesAssigned: PYQT_SIGNAL

    RestorePolicy: typing.Type[int]
    #class RestorePolicy(int): ...
    DontRestoreProperties = ... # type: int
    RestoreProperties = ... # type: int

    ChildMode: typing.Type[int]
    #class ChildMode(int): ...
    ExclusiveStates = ... # type: int
    ParallelStates = ... # type: int

    @overload
    def __init__(self, parent: typing.Optional[QState] = ..., **props) -> None: ...
    @overload
    def __init__(self, childMode: int, parent: typing.Optional[QState] = ..., **props) -> None: ...

    #def errorStateChanged(self) -> None: ...
    #def initialStateChanged(self) -> None: ...
    #def childModeChanged(self) -> None: ...
    def event(self, e: QEvent) -> bool: ...
    def onExit(self, event: QEvent) -> None: ...
    def onEntry(self, event: QEvent) -> None: ...
    #def propertiesAssigned(self) -> None: ...
    #def finished(self) -> None: ...
    def assignProperty(self, object: QObject, name: str, value: typing.Any) -> None: ...
    def setChildMode(self, mode: int) -> None: ...
    def childMode(self) -> int: ...
    def setInitialState(self, state: QAbstractState) -> None: ...
    def initialState(self) -> QAbstractState: ...
    def transitions(self) -> typing.List[QAbstractTransition]: ...
    def removeTransition(self, transition: QAbstractTransition) -> None: ...
    @overload
    def addTransition(self, transition: QAbstractTransition) -> None: ...
    @overload
    def addTransition(self, signal: pyqtBoundSignal, target: QAbstractState) -> QSignalTransition: ...
    @overload
    def addTransition(self, target: QAbstractState) -> QAbstractTransition: ...
    def setErrorState(self, state: QAbstractState) -> None: ...
    def errorState(self) -> QAbstractState: ...


class QStateMachine(QState):

    runningChanged: PYQT_SIGNAL
    started: PYQT_SIGNAL
    stopped: PYQT_SIGNAL

    Error: typing.Type[int]
    #class Error(int): ...
    NoError = ... # type: int
    NoInitialStateError = ... # type: int
    NoDefaultStateInHistoryStateError = ... # type: int
    NoCommonAncestorForTransitionError = ... # type: int

    EventPriority: typing.Type[int]
    #class EventPriority(int): ...
    NormalPriority = ... # type: int
    HighPriority = ... # type: int

    class SignalEvent(QEvent):

        def arguments(self) -> typing.List[typing.Any]: ...
        def signalIndex(self) -> int: ...
        def sender(self) -> QObject: ...

    class WrappedEvent(QEvent):

        def event(self) -> QEvent: ...
        def object(self) -> QObject: ...

    @overload
    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, childMode: int, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def event(self, e: QEvent) -> bool: ...
    def onExit(self, event: QEvent) -> None: ...
    def onEntry(self, event: QEvent) -> None: ...
    #def runningChanged(self, running: bool) -> None: ...
    #def stopped(self) -> None: ...
    #def started(self) -> None: ...
    def setRunning(self, running: bool) -> None: ...
    def stop(self) -> None: ...
    def start(self) -> None: ...
    def eventFilter(self, watched: QObject, event: QEvent) -> bool: ...
    def configuration(self) -> typing.Set[QAbstractState]: ...
    def cancelDelayedEvent(self, id: int) -> bool: ...
    def postDelayedEvent(self, event: QEvent, delay: int) -> int: ...
    def postEvent(self, event: QEvent, priority: int = ...) -> None: ...
    def setGlobalRestorePolicy(self, restorePolicy: int) -> None: ...
    def globalRestorePolicy(self) -> int: ...
    def removeDefaultAnimation(self, animation: QAbstractAnimation) -> None: ...
    def defaultAnimations(self) -> typing.List[QAbstractAnimation]: ...
    def addDefaultAnimation(self, animation: QAbstractAnimation) -> None: ...
    def setAnimated(self, enabled: bool) -> None: ...
    def isAnimated(self) -> bool: ...
    def isRunning(self) -> bool: ...
    def clearError(self) -> None: ...
    def errorString(self) -> str: ...
    def error(self) -> int: ...
    def removeState(self, state: QAbstractState) -> None: ...
    def addState(self, state: QAbstractState) -> None: ...


class QStorageInfo(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, path: str) -> None: ...
    @overload
    def __init__(self, dir: QDir) -> None: ...
    @overload
    def __init__(self, other: QStorageInfo) -> None: ...

    def subvolume(self) -> QByteArray: ...
    def blockSize(self) -> int: ...
    def isRoot(self) -> bool: ...
    @staticmethod
    def root() -> QStorageInfo: ...
    @staticmethod
    def mountedVolumes() -> typing.List[QStorageInfo]: ...
    def refresh(self) -> None: ...
    def isValid(self) -> bool: ...
    def isReady(self) -> bool: ...
    def isReadOnly(self) -> bool: ...
    def bytesAvailable(self) -> int: ...
    def bytesFree(self) -> int: ...
    def bytesTotal(self) -> int: ...
    def displayName(self) -> str: ...
    def name(self) -> str: ...
    def fileSystemType(self) -> QByteArray: ...
    def device(self) -> QByteArray: ...
    def rootPath(self) -> str: ...
    def setPath(self, path: str) -> None: ...
    def swap(self, other: QStorageInfo) -> None: ...


class QStringListModel(QAbstractListModel):

    @overload
    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...
    @overload
    def __init__(self, strings: typing.Iterable[str], parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def sibling(self, row: int, column: int, idx: QModelIndex) -> QModelIndex: ...
    def supportedDropActions(self) -> int: ...
    def sort(self, column: int, order: int = ...) -> None: ...
    def setStringList(self, strings: typing.Iterable[str]) -> None: ...
    def stringList(self) -> typing.List[str]: ...
    def removeRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def insertRows(self, row: int, count: int, parent: QModelIndex = ...) -> bool: ...
    def flags(self, index: QModelIndex) -> int: ...
    def setData(self, index: QModelIndex, value: typing.Any, role: int = ...) -> bool: ...
    def data(self, index: QModelIndex, role: int) -> typing.Any: ...
    def rowCount(self, parent: QModelIndex = ...) -> int: ...


class QSystemSemaphore(sip.simplewrapper):

    SystemSemaphoreError: typing.Type[int]
    #class SystemSemaphoreError(int): ...
    NoError = ... # type: int
    PermissionDenied = ... # type: int
    KeyError = ... # type: int
    AlreadyExists = ... # type: int
    NotFound = ... # type: int
    OutOfResources = ... # type: int
    UnknownError = ... # type: int

    AccessMode: typing.Type[int]
    #class AccessMode(int): ...
    Open = ... # type: int
    Create = ... # type: int

    def __init__(self, key: str, initialValue: int = ..., mode: int = ...) -> None: ...

    def errorString(self) -> str: ...
    def error(self) -> int: ...
    def release(self, n: int = ...) -> bool: ...
    def acquire(self) -> bool: ...
    def key(self) -> str: ...
    def setKey(self, key: str, initialValue: int = ..., mode: int = ...) -> None: ...


class QTemporaryDir(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, templateName: str) -> None: ...

    def filePath(self, fileName: str) -> str: ...
    def errorString(self) -> str: ...
    def path(self) -> str: ...
    def remove(self) -> bool: ...
    def setAutoRemove(self, b: bool) -> None: ...
    def autoRemove(self) -> bool: ...
    def isValid(self) -> bool: ...


class QTemporaryFile(QFile):

    @overload
    def __init__(self, **props) -> None: ...
    @overload
    def __init__(self, templateName: str, **props) -> None: ...
    @overload
    def __init__(self, parent: QObject, **props) -> None: ...
    @overload
    def __init__(self, templateName: str, parent: QObject, **props) -> None: ...

    def rename(self, newName: str) -> bool: ...
    @overload
    @staticmethod
    def createNativeFile(fileName: str) -> QTemporaryFile: ...
    @overload
    @staticmethod
    def createNativeFile(file: QFile) -> QTemporaryFile: ...
    def setFileTemplate(self, name: str) -> None: ...
    def fileTemplate(self) -> str: ...
    def fileName(self) -> str: ...
    @overload
    def open(self) -> bool: ...
    @overload
    def open(self, flags: typing.Union[int, int]) -> bool: ...
    def setAutoRemove(self, b: bool) -> None: ...
    def autoRemove(self) -> bool: ...


class QTextBoundaryFinder(sip.simplewrapper):

    BoundaryType: typing.Type[int]
    #class BoundaryType(int): ...
    Grapheme = ... # type: int
    Word = ... # type: int
    Line = ... # type: int
    Sentence = ... # type: int

    BoundaryReason: typing.Type[int]
    #class BoundaryReason(int): ...
    NotAtBoundary = ... # type: int
    SoftHyphen = ... # type: int
    BreakOpportunity = ... # type: int
    StartOfItem = ... # type: int
    EndOfItem = ... # type: int
    MandatoryBreak = ... # type: int

    BoundaryReasons: typing.Type[int]
    #class BoundaryReasons(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QTextBoundaryFinder.BoundaryReasons, QTextBoundaryFinder.BoundaryReason]) -> None: ...
        #@overload
        #def __init__(self, a0: QTextBoundaryFinder.BoundaryReasons) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QTextBoundaryFinder.BoundaryReasons: ...
        #def __int__(self) -> int: ...

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, other: QTextBoundaryFinder) -> None: ...
    @overload
    def __init__(self, type: int, string: str) -> None: ...

    def boundaryReasons(self) -> int: ...
    def isAtBoundary(self) -> bool: ...
    def toPreviousBoundary(self) -> int: ...
    def toNextBoundary(self) -> int: ...
    def setPosition(self, position: int) -> None: ...
    def position(self) -> int: ...
    def toEnd(self) -> None: ...
    def toStart(self) -> None: ...
    def string(self) -> str: ...
    def type(self) -> int: ...
    def isValid(self) -> bool: ...


class QTextCodec(sip.wrapper):

    ConversionFlag: typing.Type[int]
    #class ConversionFlag(int): ...
    DefaultConversion = ... # type: int
    ConvertInvalidToNull = ... # type: int
    IgnoreHeader = ... # type: int

    ConversionFlags: typing.Type[int]
    #class ConversionFlags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QTextCodec.ConversionFlags, QTextCodec.ConversionFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: QTextCodec.ConversionFlags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QTextCodec.ConversionFlags: ...
        #def __int__(self) -> int: ...

    class ConverterState:

        def __init__(self, flags: typing.Union[int, int] = ...) -> None: ...

    def __init__(self) -> None: ...

    def convertToUnicode(self, in_: bytes, state: QTextCodec.ConverterState) -> str: ...
    def mibEnum(self) -> int: ...
    def aliases(self) -> typing.List[QByteArray]: ...
    def name(self) -> QByteArray: ...
    def fromUnicode(self, uc: str) -> QByteArray: ...
    @overload
    def toUnicode(self, a0: typing.Union[QByteArray, bytes, bytearray]) -> str: ...
    @overload
    def toUnicode(self, chars: str) -> str: ...
    @overload
    def toUnicode(self, in_: bytes, state: typing.Optional[QTextCodec.ConverterState] = ...) -> str: ...
    def canEncode(self, a0: str) -> bool: ...
    def makeEncoder(self, flags: typing.Union[int, int] = ...) -> QTextEncoder: ...
    def makeDecoder(self, flags: typing.Union[int, int] = ...) -> QTextDecoder: ...
    @staticmethod
    def setCodecForLocale(c: QTextCodec) -> None: ...
    @staticmethod
    def codecForLocale() -> QTextCodec: ...
    @staticmethod
    def availableMibs() -> typing.List[int]: ...
    @staticmethod
    def availableCodecs() -> typing.List[QByteArray]: ...
    @overload
    @staticmethod
    def codecForUtfText(ba: typing.Union[QByteArray, bytes, bytearray]) -> QTextCodec: ...
    @overload
    @staticmethod
    def codecForUtfText(ba: typing.Union[QByteArray, bytes, bytearray], defaultCodec: QTextCodec) -> QTextCodec: ...
    @overload
    @staticmethod
    def codecForHtml(ba: typing.Union[QByteArray, bytes, bytearray]) -> QTextCodec: ...
    @overload
    @staticmethod
    def codecForHtml(ba: typing.Union[QByteArray, bytes, bytearray], defaultCodec: QTextCodec) -> QTextCodec: ...
    @staticmethod
    def codecForMib(mib: int) -> QTextCodec: ...
    @overload
    @staticmethod
    def codecForName(name: typing.Union[QByteArray, bytes, bytearray]) -> QTextCodec: ...
    @overload
    @staticmethod
    def codecForName(name: str) -> QTextCodec: ...


class QTextEncoder(sip.wrapper):

    @overload
    def __init__(self, codec: QTextCodec) -> None: ...
    @overload
    def __init__(self, codec: QTextCodec, flags: typing.Union[int, int]) -> None: ...

    def fromUnicode(self, str: str) -> QByteArray: ...


class QTextDecoder(sip.wrapper):

    @overload
    def __init__(self, codec: QTextCodec) -> None: ...
    @overload
    def __init__(self, codec: QTextCodec, flags: typing.Union[int, int]) -> None: ...

    @overload
    def toUnicode(self, chars: bytes) -> str: ...
    @overload
    def toUnicode(self, ba: typing.Union[QByteArray, bytes, bytearray]) -> str: ...


class QTextStream(sip.simplewrapper):

    Status: typing.Type[int]
    #class Status(int): ...
    Ok = ... # type: int
    ReadPastEnd = ... # type: int
    ReadCorruptData = ... # type: int
    WriteFailed = ... # type: int

    NumberFlag: typing.Type[int]
    #class NumberFlag(int): ...
    ShowBase = ... # type: int
    ForcePoint = ... # type: int
    ForceSign = ... # type: int
    UppercaseBase = ... # type: int
    UppercaseDigits = ... # type: int

    FieldAlignment: typing.Type[int]
    #class FieldAlignment(int): ...
    AlignLeft = ... # type: int
    AlignRight = ... # type: int
    AlignCenter = ... # type: int
    AlignAccountingStyle = ... # type: int

    RealNumberNotation: typing.Type[int]
    #class RealNumberNotation(int): ...
    SmartNotation = ... # type: int
    FixedNotation = ... # type: int
    ScientificNotation = ... # type: int

    NumberFlags: typing.Type[int]
    #class NumberFlags(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QTextStream.NumberFlags, QTextStream.NumberFlag]) -> None: ...
        #@overload
        #def __init__(self, a0: QTextStream.NumberFlags) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QTextStream.NumberFlags: ...
        #def __int__(self) -> int: ...

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, device: QIODevice) -> None: ...
    @overload
    def __init__(self, array: QByteArray, mode: typing.Union[int, int] = ...) -> None: ...

    def locale(self) -> QLocale: ...
    def setLocale(self, locale: QLocale) -> None: ...
    def pos(self) -> int: ...
    def resetStatus(self) -> None: ...
    def setStatus(self, status: int) -> None: ...
    def status(self) -> int: ...
    def realNumberPrecision(self) -> int: ...
    def setRealNumberPrecision(self, precision: int) -> None: ...
    def realNumberNotation(self) -> int: ...
    def setRealNumberNotation(self, notation: int) -> None: ...
    def integerBase(self) -> int: ...
    def setIntegerBase(self, base: int) -> None: ...
    def numberFlags(self) -> int: ...
    def setNumberFlags(self, flags: typing.Union[int, int]) -> None: ...
    def fieldWidth(self) -> int: ...
    def setFieldWidth(self, width: int) -> None: ...
    def padChar(self) -> str: ...
    def setPadChar(self, ch: str) -> None: ...
    def fieldAlignment(self) -> int: ...
    def setFieldAlignment(self, alignment: int) -> None: ...
    def readAll(self) -> str: ...
    def readLine(self, maxLength: int = ...) -> str: ...
    def read(self, maxlen: int) -> str: ...
    def skipWhiteSpace(self) -> None: ...
    def seek(self, pos: int) -> bool: ...
    def flush(self) -> None: ...
    def reset(self) -> None: ...
    def atEnd(self) -> bool: ...
    def device(self) -> QIODevice: ...
    def setDevice(self, device: QIODevice) -> None: ...
    def generateByteOrderMark(self) -> bool: ...
    def setGenerateByteOrderMark(self, generate: bool) -> None: ...
    def autoDetectUnicode(self) -> bool: ...
    def setAutoDetectUnicode(self, enabled: bool) -> None: ...
    def codec(self) -> QTextCodec: ...
    @overload
    def setCodec(self, codec: QTextCodec) -> None: ...
    @overload
    def setCodec(self, codecName: str) -> None: ...


class QTextStreamManipulator(sip.simplewrapper): ...


class QThread(QObject):

    finished: PYQT_SIGNAL
    started: PYQT_SIGNAL

    Priority: typing.Type[int]
    #class Priority(int): ...
    IdlePriority = ... # type: int
    LowestPriority = ... # type: int
    LowPriority = ... # type: int
    NormalPriority = ... # type: int
    HighPriority = ... # type: int
    HighestPriority = ... # type: int
    TimeCriticalPriority = ... # type: int
    InheritPriority = ... # type: int

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def loopLevel(self) -> int: ...
    def isInterruptionRequested(self) -> bool: ...
    def requestInterruption(self) -> None: ...
    def setEventDispatcher(self, eventDispatcher: QAbstractEventDispatcher) -> None: ...
    def eventDispatcher(self) -> QAbstractEventDispatcher: ...
    @staticmethod
    def usleep(a0: int) -> None: ...
    @staticmethod
    def msleep(a0: int) -> None: ...
    @staticmethod
    def sleep(a0: int) -> None: ...
    def event(self, event: QEvent) -> bool: ...
    @staticmethod
    def setTerminationEnabled(enabled: bool = ...) -> None: ...
    def exec(self) -> int: ...
    def exec_(self) -> int: ...
    def run(self) -> None: ...
    #def finished(self) -> None: ...
    #def started(self) -> None: ...
    def wait(self, msecs: int = ...) -> bool: ...
    def quit(self) -> None: ...
    def terminate(self) -> None: ...
    def start(self, priority: int = ...) -> None: ...
    def exit(self, returnCode: int = ...) -> None: ...
    def stackSize(self) -> int: ...
    def setStackSize(self, stackSize: int) -> None: ...
    def priority(self) -> int: ...
    def setPriority(self, priority: int) -> None: ...
    def isRunning(self) -> bool: ...
    def isFinished(self) -> bool: ...
    @staticmethod
    def yieldCurrentThread() -> None: ...
    @staticmethod
    def idealThreadCount() -> int: ...
    @staticmethod
    def currentThreadId() -> sip.voidptr: ...
    @staticmethod
    def currentThread() -> QThread: ...


class QThreadPool(QObject):

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def stackSize(self) -> int: ...
    def setStackSize(self, stackSize: int) -> None: ...
    def cancel(self, runnable: QRunnable) -> None: ...
    def clear(self) -> None: ...
    def waitForDone(self, msecs: int = ...) -> bool: ...
    def releaseThread(self) -> None: ...
    def reserveThread(self) -> None: ...
    def activeThreadCount(self) -> int: ...
    def setMaxThreadCount(self, maxThreadCount: int) -> None: ...
    def maxThreadCount(self) -> int: ...
    def setExpiryTimeout(self, expiryTimeout: int) -> None: ...
    def expiryTimeout(self) -> int: ...
    def tryTake(self, runnable: QRunnable) -> bool: ...
    def tryStart(self, runnable: QRunnable) -> bool: ...
    def start(self, runnable: QRunnable, priority: int = ...) -> None: ...
    @staticmethod
    def globalInstance() -> QThreadPool: ...


class QTimeLine(QObject):

    finished: PYQT_SIGNAL
    frameChanged: PYQT_SIGNAL
    stateChanged: PYQT_SIGNAL
    valueChanged: PYQT_SIGNAL

    State: typing.Type[int]
    #class State(int): ...
    NotRunning = ... # type: int
    Paused = ... # type: int
    Running = ... # type: int

    Direction: typing.Type[int]
    #class Direction(int): ...
    Forward = ... # type: int
    Backward = ... # type: int

    CurveShape: typing.Type[int]
    #class CurveShape(int): ...
    EaseInCurve = ... # type: int
    EaseOutCurve = ... # type: int
    EaseInOutCurve = ... # type: int
    LinearCurve = ... # type: int
    SineCurve = ... # type: int
    CosineCurve = ... # type: int

    def __init__(self, duration: int = ..., parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def setEasingCurve(self, curve: typing.Union[QEasingCurve, int]) -> None: ...
    def easingCurve(self) -> QEasingCurve: ...
    def timerEvent(self, event: QTimerEvent) -> None: ...
    #def valueChanged(self, x: float) -> None: ...
    #def stateChanged(self, newState: int) -> None: ...
    #def frameChanged(self, a0: int) -> None: ...
    #def finished(self) -> None: ...
    def toggleDirection(self) -> None: ...
    def stop(self) -> None: ...
    def start(self) -> None: ...
    def setPaused(self, paused: bool) -> None: ...
    def setCurrentTime(self, msec: int) -> None: ...
    def resume(self) -> None: ...
    def valueForTime(self, msec: int) -> float: ...
    def frameForTime(self, msec: int) -> int: ...
    def currentValue(self) -> float: ...
    def currentFrame(self) -> int: ...
    def currentTime(self) -> int: ...
    def setCurveShape(self, shape: int) -> None: ...
    def curveShape(self) -> int: ...
    def setUpdateInterval(self, interval: int) -> None: ...
    def updateInterval(self) -> int: ...
    def setFrameRange(self, startFrame: int, endFrame: int) -> None: ...
    def setEndFrame(self, frame: int) -> None: ...
    def endFrame(self) -> int: ...
    def setStartFrame(self, frame: int) -> None: ...
    def startFrame(self) -> int: ...
    def setDuration(self, duration: int) -> None: ...
    def duration(self) -> int: ...
    def setDirection(self, direction: int) -> None: ...
    def direction(self) -> int: ...
    def setLoopCount(self, count: int) -> None: ...
    def loopCount(self) -> int: ...
    def state(self) -> int: ...


class QTimer(QObject):

    timeout: PYQT_SIGNAL

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def remainingTime(self) -> int: ...
    def timerType(self) -> int: ...
    def setTimerType(self, atype: int) -> None: ...
    def timerEvent(self, a0: QTimerEvent) -> None: ...
    #def timeout(self) -> None: ...
    def stop(self) -> None: ...
    @overload
    def start(self, msec: int) -> None: ...
    @overload
    def start(self) -> None: ...
    @overload
    @staticmethod
    def singleShot(msec: int, slot: PYQT_SLOT) -> None: ...
    @overload
    @staticmethod
    def singleShot(msec: int, timerType: int, slot: PYQT_SLOT) -> None: ...
    def setSingleShot(self, asingleShot: bool) -> None: ...
    def isSingleShot(self) -> bool: ...
    def interval(self) -> int: ...
    def setInterval(self, msec: int) -> None: ...
    def timerId(self) -> int: ...
    def isActive(self) -> bool: ...


class QTimeZone(sip.simplewrapper):

    NameType: typing.Type[int]
    #class NameType(int): ...
    DefaultName = ... # type: int
    LongName = ... # type: int
    ShortName = ... # type: int
    OffsetName = ... # type: int

    TimeType: typing.Type[int]
    #class TimeType(int): ...
    StandardTime = ... # type: int
    DaylightTime = ... # type: int
    GenericTime = ... # type: int

    class OffsetData:

        abbreviation = ... # type: str
        atUtc = ... # type: typing.Union[QDateTime, datetime.datetime]
        daylightTimeOffset = ... # type: int
        offsetFromUtc = ... # type: int
        standardTimeOffset = ... # type: int

        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, a0: QTimeZone.OffsetData) -> None: ...

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, ianaId: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    @overload
    def __init__(self, offsetSeconds: int) -> None: ...
    @overload
    def __init__(self, zoneId: typing.Union[QByteArray, bytes, bytearray], offsetSeconds: int, name: str, abbreviation: str, country: int = ..., comment: str = ...) -> None: ...
    @overload
    def __init__(self, other: QTimeZone) -> None: ...

    @staticmethod
    def utc() -> QTimeZone: ...
    @staticmethod
    def systemTimeZone() -> QTimeZone: ...
    @overload
    @staticmethod
    def windowsIdToIanaIds(windowsId: typing.Union[QByteArray, bytes, bytearray]) -> typing.List[QByteArray]: ...
    @overload
    @staticmethod
    def windowsIdToIanaIds(windowsId: typing.Union[QByteArray, bytes, bytearray], country: int) -> typing.List[QByteArray]: ...
    @overload
    @staticmethod
    def windowsIdToDefaultIanaId(windowsId: typing.Union[QByteArray, bytes, bytearray]) -> QByteArray: ...
    @overload
    @staticmethod
    def windowsIdToDefaultIanaId(windowsId: typing.Union[QByteArray, bytes, bytearray], country: int) -> QByteArray: ...
    @staticmethod
    def ianaIdToWindowsId(ianaId: typing.Union[QByteArray, bytes, bytearray]) -> QByteArray: ...
    @overload
    @staticmethod
    def availableTimeZoneIds() -> typing.List[QByteArray]: ...
    @overload
    @staticmethod
    def availableTimeZoneIds(country: int) -> typing.List[QByteArray]: ...
    @overload
    @staticmethod
    def availableTimeZoneIds(offsetSeconds: int) -> typing.List[QByteArray]: ...
    @staticmethod
    def isTimeZoneIdAvailable(ianaId: typing.Union[QByteArray, bytes, bytearray]) -> bool: ...
    @staticmethod
    def systemTimeZoneId() -> QByteArray: ...
    def transitions(self, fromDateTime: typing.Union[QDateTime, datetime.datetime], toDateTime: typing.Union[QDateTime, datetime.datetime]) -> typing.List[QTimeZone.OffsetData]: ...
    def previousTransition(self, beforeDateTime: typing.Union[QDateTime, datetime.datetime]) -> QTimeZone.OffsetData: ...
    def nextTransition(self, afterDateTime: typing.Union[QDateTime, datetime.datetime]) -> QTimeZone.OffsetData: ...
    def hasTransitions(self) -> bool: ...
    def offsetData(self, forDateTime: typing.Union[QDateTime, datetime.datetime]) -> QTimeZone.OffsetData: ...
    def isDaylightTime(self, atDateTime: typing.Union[QDateTime, datetime.datetime]) -> bool: ...
    def hasDaylightTime(self) -> bool: ...
    def daylightTimeOffset(self, atDateTime: typing.Union[QDateTime, datetime.datetime]) -> int: ...
    def standardTimeOffset(self, atDateTime: typing.Union[QDateTime, datetime.datetime]) -> int: ...
    def offsetFromUtc(self, atDateTime: typing.Union[QDateTime, datetime.datetime]) -> int: ...
    def abbreviation(self, atDateTime: typing.Union[QDateTime, datetime.datetime]) -> str: ...
    @overload
    def displayName(self, atDateTime: typing.Union[QDateTime, datetime.datetime], nameType: int = ..., locale: QLocale = ...) -> str: ...
    @overload
    def displayName(self, timeType: int, nameType: int = ..., locale: QLocale = ...) -> str: ...
    def comment(self) -> str: ...
    def country(self) -> int: ...
    def id(self) -> QByteArray: ...
    def isValid(self) -> bool: ...
    def swap(self, other: QTimeZone) -> None: ...


class QTranslator(QObject):

    def __init__(self, parent: typing.Optional[QObject] = ..., **props) -> None: ...

    def loadFromData(self, data: bytes, directory: str = ...) -> bool: ...
    @overload
    def load(self, fileName: str, directory: str = ..., searchDelimiters: str = ..., suffix: str = ...) -> bool: ...
    @overload
    def load(self, locale: QLocale, fileName: str, prefix: str = ..., directory: str = ..., suffix: str = ...) -> bool: ...
    def isEmpty(self) -> bool: ...
    def translate(self, context: str, sourceText: str, disambiguation: typing.Optional[str] = ..., n: int = ...) -> str: ...


class QUrl(sip.simplewrapper):

    UserInputResolutionOption: typing.Type[int]
    #class UserInputResolutionOption(int): ...
    DefaultResolution = ... # type: int
    AssumeLocalFile = ... # type: int

    ComponentFormattingOption: typing.Type[int]
    #class ComponentFormattingOption(int): ...
    PrettyDecoded = ... # type: int
    EncodeSpaces = ... # type: int
    EncodeUnicode = ... # type: int
    EncodeDelimiters = ... # type: int
    EncodeReserved = ... # type: int
    DecodeReserved = ... # type: int
    FullyEncoded = ... # type: int
    FullyDecoded = ... # type: int

    UrlFormattingOption: typing.Type[int]
    #class UrlFormattingOption(int): ...
    None_ = ... # type: int
    RemoveScheme = ... # type: int
    RemovePassword = ... # type: int
    RemoveUserInfo = ... # type: int
    RemovePort = ... # type: int
    RemoveAuthority = ... # type: int
    RemovePath = ... # type: int
    RemoveQuery = ... # type: int
    RemoveFragment = ... # type: int
    PreferLocalFile = ... # type: int
    StripTrailingSlash = ... # type: int
    RemoveFilename = ... # type: int
    NormalizePathSegments = ... # type: int

    ParsingMode: typing.Type[int]
    #class ParsingMode(int): ...
    TolerantMode = ... # type: int
    StrictMode = ... # type: int
    DecodedMode = ... # type: int

    class FormattingOptions:

        def __init__(self, a0: QUrl.FormattingOptions) -> None: ...


    ComponentFormattingOptions: typing.Type[int]
    #class ComponentFormattingOptions(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QUrl.ComponentFormattingOptions, QUrl.ComponentFormattingOption]) -> None: ...
        #@overload
        #def __init__(self, a0: QUrl.ComponentFormattingOptions) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QUrl.ComponentFormattingOptions: ...
        #def __int__(self) -> int: ...

    UserInputResolutionOptions: typing.Type[int]
    #class UserInputResolutionOptions(sip.simplewrapper):

        #@overload
        #def __init__(self) -> None: ...
        #@overload
        #def __init__(self, f: typing.Union[QUrl.UserInputResolutionOptions, QUrl.UserInputResolutionOption]) -> None: ...
        #@overload
        #def __init__(self, a0: QUrl.UserInputResolutionOptions) -> None: ...

        #def __hash__(self) -> int: ...
        #def __bool__(self) -> int: ...
        #def __invert__(self) -> QUrl.UserInputResolutionOptions: ...
        #def __int__(self) -> int: ...

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, url: str, mode: int = ...) -> None: ...
    @overload
    def __init__(self, copy: QUrl) -> None: ...

    def matches(self, url: QUrl, options: QUrl.FormattingOptions) -> bool: ...
    def fileName(self, options: typing.Union[int, int] = ...) -> str: ...
    def adjusted(self, options: QUrl.FormattingOptions) -> QUrl: ...
    @staticmethod
    def fromStringList(uris: typing.Iterable[str], mode: int = ...) -> typing.List[QUrl]: ...
    @staticmethod
    def toStringList(uris: typing.Iterable[QUrl], options: QUrl.FormattingOptions = ...) -> typing.List[str]: ...
    def query(self, options: typing.Union[int, int] = ...) -> str: ...
    @overload
    def setQuery(self, query: str, mode: int = ...) -> None: ...
    @overload
    def setQuery(self, query: QUrlQuery) -> None: ...
    def toDisplayString(self, options: QUrl.FormattingOptions = ...) -> str: ...
    def isLocalFile(self) -> bool: ...
    def topLevelDomain(self, options: typing.Union[int, int] = ...) -> str: ...
    def swap(self, other: QUrl) -> None: ...
    @overload
    @staticmethod
    def fromUserInput(userInput: str) -> QUrl: ...
    @overload
    @staticmethod
    def fromUserInput(userInput: str, workingDirectory: str, options: typing.Union[int, int] = ...) -> QUrl: ...
    @staticmethod
    def setIdnWhitelist(a0: typing.Iterable[str]) -> None: ...
    @staticmethod
    def idnWhitelist() -> typing.List[str]: ...
    @staticmethod
    def toAce(a0: str) -> QByteArray: ...
    @staticmethod
    def fromAce(a0: typing.Union[QByteArray, bytes, bytearray]) -> str: ...
    def errorString(self) -> str: ...
    def hasFragment(self) -> bool: ...
    def hasQuery(self) -> bool: ...
    @staticmethod
    def toPercentEncoding(input: str, exclude: typing.Union[QByteArray, bytes, bytearray] = ..., include: typing.Union[QByteArray, bytes, bytearray] = ...) -> QByteArray: ...
    @staticmethod
    def fromPercentEncoding(a0: typing.Union[QByteArray, bytes, bytearray]) -> str: ...
    def isDetached(self) -> bool: ...
    def detach(self) -> None: ...
    @staticmethod
    def fromEncoded(u: typing.Union[QByteArray, bytes, bytearray], mode: int = ...) -> QUrl: ...
    def toEncoded(self, options: QUrl.FormattingOptions = ...) -> QByteArray: ...
    def toString(self, options: QUrl.FormattingOptions = ...) -> str: ...
    def toLocalFile(self) -> str: ...
    @staticmethod
    def fromLocalFile(localfile: str) -> QUrl: ...
    def isParentOf(self, url: QUrl) -> bool: ...
    def isRelative(self) -> bool: ...
    def resolved(self, relative: QUrl) -> QUrl: ...
    def fragment(self, options: typing.Union[int, int] = ...) -> str: ...
    def setFragment(self, fragment: str, mode: int = ...) -> None: ...
    def path(self, options: typing.Union[int, int] = ...) -> str: ...
    def setPath(self, path: str, mode: int = ...) -> None: ...
    def port(self, defaultPort: int = ...) -> int: ...
    def setPort(self, port: int) -> None: ...
    def host(self, a0: typing.Union[int, int] = ...) -> str: ...
    def setHost(self, host: str, mode: int = ...) -> None: ...
    def password(self, options: typing.Union[int, int] = ...) -> str: ...
    def setPassword(self, password: str, mode: int = ...) -> None: ...
    def userName(self, options: typing.Union[int, int] = ...) -> str: ...
    def setUserName(self, userName: str, mode: int = ...) -> None: ...
    def userInfo(self, options: typing.Union[int, int] = ...) -> str: ...
    def setUserInfo(self, userInfo: str, mode: int = ...) -> None: ...
    def authority(self, options: typing.Union[int, int] = ...) -> str: ...
    def setAuthority(self, authority: str, mode: int = ...) -> None: ...
    def scheme(self) -> str: ...
    def setScheme(self, scheme: str) -> None: ...
    def clear(self) -> None: ...
    def isEmpty(self) -> bool: ...
    def isValid(self) -> bool: ...
    def setUrl(self, url: str, mode: int = ...) -> None: ...
    def url(self, options: QUrl.FormattingOptions = ...) -> str: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...


class QUrlQuery(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, url: QUrl) -> None: ...
    @overload
    def __init__(self, queryString: str) -> None: ...
    @overload
    def __init__(self, other: QUrlQuery) -> None: ...

    def __hash__(self) -> int: ...
    @staticmethod
    def defaultQueryPairDelimiter() -> str: ...
    @staticmethod
    def defaultQueryValueDelimiter() -> str: ...
    def removeAllQueryItems(self, key: str) -> None: ...
    def allQueryItemValues(self, key: str, options: typing.Union[int, int] = ...) -> typing.List[str]: ...
    def queryItemValue(self, key: str, options: typing.Union[int, int] = ...) -> str: ...
    def removeQueryItem(self, key: str) -> None: ...
    def addQueryItem(self, key: str, value: str) -> None: ...
    def hasQueryItem(self, key: str) -> bool: ...
    def queryItems(self, options: typing.Union[int, int] = ...) -> typing.List[typing.Tuple[str, str]]: ...
    def setQueryItems(self, query: typing.Iterable[typing.Tuple[str, str]]) -> None: ...
    def queryPairDelimiter(self) -> str: ...
    def queryValueDelimiter(self) -> str: ...
    def setQueryDelimiters(self, valueDelimiter: str, pairDelimiter: str) -> None: ...
    def toString(self, options: typing.Union[int, int] = ...) -> str: ...
    def setQuery(self, queryString: str) -> None: ...
    def query(self, options: typing.Union[int, int] = ...) -> str: ...
    def clear(self) -> None: ...
    def isDetached(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def swap(self, other: QUrlQuery) -> None: ...


class QUuid(sip.simplewrapper):

    StringFormat: typing.Type[int]
    #class StringFormat(int): ...
    WithBraces = ... # type: int
    WithoutBraces = ... # type: int
    Id128 = ... # type: int

    Version: typing.Type[int]
    #class Version(int): ...
    VerUnknown = ... # type: int
    Time = ... # type: int
    EmbeddedPOSIX = ... # type: int
    Md5 = ... # type: int
    Name = ... # type: int
    Random = ... # type: int
    Sha1 = ... # type: int

    Variant: typing.Type[int]
    #class Variant(int): ...
    VarUnknown = ... # type: int
    NCS = ... # type: int
    DCE = ... # type: int
    Microsoft = ... # type: int
    Reserved = ... # type: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, l: int, w1: int, w2: int, b1: int, b2: int, b3: int, b4: int, b5: int, b6: int, b7: int, b8: int) -> None: ...
    @overload
    def __init__(self, a0: str) -> None: ...
    @overload
    def __init__(self, a0: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    @overload
    def __init__(self, a0: QUuid) -> None: ...

    @staticmethod
    def fromRfc4122(a0: typing.Union[QByteArray, bytes, bytearray]) -> QUuid: ...
    def toRfc4122(self) -> QByteArray: ...
    @overload
    def toByteArray(self) -> QByteArray: ...
    @overload
    def toByteArray(self, mode: int) -> QByteArray: ...
    def version(self) -> int: ...
    def variant(self) -> int: ...
    @overload
    @staticmethod
    def createUuidV5(ns: QUuid, baseData: typing.Union[QByteArray, bytes, bytearray]) -> QUuid: ...
    @overload
    @staticmethod
    def createUuidV5(ns: QUuid, baseData: str) -> QUuid: ...
    @overload
    @staticmethod
    def createUuidV3(ns: QUuid, baseData: typing.Union[QByteArray, bytes, bytearray]) -> QUuid: ...
    @overload
    @staticmethod
    def createUuidV3(ns: QUuid, baseData: str) -> QUuid: ...
    @staticmethod
    def createUuid() -> QUuid: ...
    def isNull(self) -> bool: ...
    @overload
    def toString(self) -> str: ...
    @overload
    def toString(self, mode: int) -> str: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...


class QVariant(sip.simplewrapper):

    Type: typing.Type[int]
    #class Type(int): ...
    Invalid = ... # type: int
    Bool = ... # type: int
    Int = ... # type: int
    UInt = ... # type: int
    LongLong = ... # type: int
    ULongLong = ... # type: int
    Double = ... # type: int
    Char = ... # type: int
    Map = ... # type: int
    List = ... # type: int
    String = ... # type: int
    StringList = ... # type: int
    ByteArray = ... # type: int
    BitArray = ... # type: int
    Date = ... # type: int
    Time = ... # type: int
    DateTime = ... # type: int
    Url = ... # type: int
    Locale = ... # type: int
    Rect = ... # type: int
    RectF = ... # type: int
    Size = ... # type: int
    SizeF = ... # type: int
    Line = ... # type: int
    LineF = ... # type: int
    Point = ... # type: int
    PointF = ... # type: int
    RegExp = ... # type: int
    Font = ... # type: int
    Pixmap = ... # type: int
    Brush = ... # type: int
    Color = ... # type: int
    Palette = ... # type: int
    Icon = ... # type: int
    Image = ... # type: int
    Polygon = ... # type: int
    Region = ... # type: int
    Bitmap = ... # type: int
    Cursor = ... # type: int
    SizePolicy = ... # type: int
    KeySequence = ... # type: int
    Pen = ... # type: int
    TextLength = ... # type: int
    TextFormat = ... # type: int
    Matrix = ... # type: int
    Transform = ... # type: int
    Hash = ... # type: int
    Matrix4x4 = ... # type: int
    Vector2D = ... # type: int
    Vector3D = ... # type: int
    Vector4D = ... # type: int
    Quaternion = ... # type: int
    EasingCurve = ... # type: int
    Uuid = ... # type: int
    ModelIndex = ... # type: int
    PolygonF = ... # type: int
    RegularExpression = ... # type: int
    PersistentModelIndex = ... # type: int
    UserType = ... # type: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, type: int) -> None: ...
    @overload
    def __init__(self, obj: typing.Any) -> None: ...
    @overload
    def __init__(self, a0: QVariant) -> None: ...

    def swap(self, other: QVariant) -> None: ...
    @staticmethod
    def nameToType(name: str) -> int: ...
    @staticmethod
    def typeToName(typeId: int) -> str: ...
    def save(self, ds: QDataStream) -> None: ...
    def load(self, ds: QDataStream) -> None: ...
    def clear(self) -> None: ...
    def isNull(self) -> bool: ...
    def isValid(self) -> bool: ...
    def convert(self, targetTypeId: int) -> bool: ...
    def canConvert(self, targetTypeId: int) -> bool: ...
    def typeName(self) -> str: ...
    def userType(self) -> int: ...
    def type(self) -> int: ...
    def value(self) -> typing.Any: ...


class QVersionNumber(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, seg: typing.Iterable[int]) -> None: ...
    @overload
    def __init__(self, maj: int) -> None: ...
    @overload
    def __init__(self, maj: int, min: int) -> None: ...
    @overload
    def __init__(self, maj: int, min: int, mic: int) -> None: ...
    @overload
    def __init__(self, a0: QVersionNumber) -> None: ...

    def __hash__(self) -> int: ...
    @staticmethod
    def fromString(string: str) -> typing.Tuple[QVersionNumber, int]: ...
    def toString(self) -> str: ...
    @staticmethod
    def commonPrefix(v1: QVersionNumber, v2: QVersionNumber) -> QVersionNumber: ...
    @staticmethod
    def compare(v1: QVersionNumber, v2: QVersionNumber) -> int: ...
    def isPrefixOf(self, other: QVersionNumber) -> bool: ...
    def segmentCount(self) -> int: ...
    def segmentAt(self, index: int) -> int: ...
    def segments(self) -> typing.List[int]: ...
    def normalized(self) -> QVersionNumber: ...
    def microVersion(self) -> int: ...
    def minorVersion(self) -> int: ...
    def majorVersion(self) -> int: ...
    def isNormalized(self) -> bool: ...
    def isNull(self) -> bool: ...


class QWaitCondition(sip.simplewrapper):

    def __init__(self) -> None: ...

    def wakeAll(self) -> None: ...
    def wakeOne(self) -> None: ...
    @overload
    def wait(self, mutex: QMutex, msecs: int = ...) -> bool: ...
    @overload
    def wait(self, readWriteLock: QReadWriteLock, msecs: int = ...) -> bool: ...
    @overload
    def wait(self, lockedMutex: QMutex, deadline: QDeadlineTimer) -> bool: ...
    @overload
    def wait(self, lockedReadWriteLock: QReadWriteLock, deadline: QDeadlineTimer) -> bool: ...


class QXmlStreamAttribute(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, qualifiedName: str, value: str) -> None: ...
    @overload
    def __init__(self, namespaceUri: str, name: str, value: str) -> None: ...
    @overload
    def __init__(self, a0: QXmlStreamAttribute) -> None: ...

    def isDefault(self) -> bool: ...
    def value(self) -> str: ...
    def prefix(self) -> str: ...
    def qualifiedName(self) -> str: ...
    def name(self) -> str: ...
    def namespaceUri(self) -> str: ...


class QXmlStreamAttributes(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QXmlStreamAttributes) -> None: ...

    def __contains__(self, value: QXmlStreamAttribute) -> int: ...
    @overload
    def __delitem__(self, i: int) -> None: ...
    @overload
    def __delitem__(self, slice: slice) -> None: ...
    @overload
    def __setitem__(self, i: int, value: QXmlStreamAttribute) -> None: ...
    @overload
    def __setitem__(self, slice: slice, list: QXmlStreamAttributes) -> None: ...
    @overload
    def __getitem__(self, i: int) -> QXmlStreamAttribute: ...
    @overload
    def __getitem__(self, slice: slice) -> QXmlStreamAttributes: ...
    def size(self) -> int: ...
    def replace(self, i: int, value: QXmlStreamAttribute) -> None: ...
    @overload
    def remove(self, i: int) -> None: ...
    @overload
    def remove(self, i: int, count: int) -> None: ...
    def prepend(self, value: QXmlStreamAttribute) -> None: ...
    def lastIndexOf(self, value: QXmlStreamAttribute, from_: int = ...) -> int: ...
    def last(self) -> QXmlStreamAttribute: ...
    def isEmpty(self) -> bool: ...
    def insert(self, i: int, value: QXmlStreamAttribute) -> None: ...
    def indexOf(self, value: QXmlStreamAttribute, from_: int = ...) -> int: ...
    def first(self) -> QXmlStreamAttribute: ...
    def fill(self, value: QXmlStreamAttribute, size: int = ...) -> None: ...
    def data(self) -> sip.voidptr: ...
    def __len__(self) -> int: ...
    @overload
    def count(self, value: QXmlStreamAttribute) -> int: ...
    @overload
    def count(self) -> int: ...
    def contains(self, value: QXmlStreamAttribute) -> bool: ...
    def clear(self) -> None: ...
    def at(self, i: int) -> QXmlStreamAttribute: ...
    @overload
    def hasAttribute(self, qualifiedName: str) -> bool: ...
    @overload
    def hasAttribute(self, namespaceUri: str, name: str) -> bool: ...
    @overload
    def append(self, namespaceUri: str, name: str, value: str) -> None: ...
    @overload
    def append(self, qualifiedName: str, value: str) -> None: ...
    @overload
    def append(self, attribute: QXmlStreamAttribute) -> None: ...
    @overload
    def value(self, namespaceUri: str, name: str) -> str: ...
    @overload
    def value(self, qualifiedName: str) -> str: ...


class QXmlStreamNamespaceDeclaration(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QXmlStreamNamespaceDeclaration) -> None: ...
    @overload
    def __init__(self, prefix: str, namespaceUri: str) -> None: ...

    def namespaceUri(self) -> str: ...
    def prefix(self) -> str: ...


class QXmlStreamNotationDeclaration(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QXmlStreamNotationDeclaration) -> None: ...

    def publicId(self) -> str: ...
    def systemId(self) -> str: ...
    def name(self) -> str: ...


class QXmlStreamEntityDeclaration(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QXmlStreamEntityDeclaration) -> None: ...

    def value(self) -> str: ...
    def publicId(self) -> str: ...
    def systemId(self) -> str: ...
    def notationName(self) -> str: ...
    def name(self) -> str: ...


class QXmlStreamEntityResolver(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QXmlStreamEntityResolver) -> None: ...

    def resolveUndeclaredEntity(self, name: str) -> str: ...


class QXmlStreamReader(sip.simplewrapper):

    Error: typing.Type[int]
    #class Error(int): ...
    NoError = ... # type: int
    UnexpectedElementError = ... # type: int
    CustomError = ... # type: int
    NotWellFormedError = ... # type: int
    PrematureEndOfDocumentError = ... # type: int

    ReadElementTextBehaviour: typing.Type[int]
    #class ReadElementTextBehaviour(int): ...
    ErrorOnUnexpectedElement = ... # type: int
    IncludeChildElements = ... # type: int
    SkipChildElements = ... # type: int

    TokenType: typing.Type[int]
    #class TokenType(int): ...
    NoToken = ... # type: int
    Invalid = ... # type: int
    StartDocument = ... # type: int
    EndDocument = ... # type: int
    StartElement = ... # type: int
    EndElement = ... # type: int
    Characters = ... # type: int
    Comment = ... # type: int
    DTD = ... # type: int
    EntityReference = ... # type: int
    ProcessingInstruction = ... # type: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, device: QIODevice) -> None: ...
    @overload
    def __init__(self, data: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    @overload
    def __init__(self, data: str) -> None: ...

    def skipCurrentElement(self) -> None: ...
    def readNextStartElement(self) -> bool: ...
    def entityResolver(self) -> QXmlStreamEntityResolver: ...
    def setEntityResolver(self, resolver: QXmlStreamEntityResolver) -> None: ...
    def hasError(self) -> bool: ...
    def error(self) -> int: ...
    def errorString(self) -> str: ...
    def raiseError(self, message: str = ...) -> None: ...
    def dtdSystemId(self) -> str: ...
    def dtdPublicId(self) -> str: ...
    def dtdName(self) -> str: ...
    def entityDeclarations(self) -> typing.List[QXmlStreamEntityDeclaration]: ...
    def notationDeclarations(self) -> typing.List[QXmlStreamNotationDeclaration]: ...
    def addExtraNamespaceDeclarations(self, extraNamespaceDeclaractions: typing.Iterable[QXmlStreamNamespaceDeclaration]) -> None: ...
    def addExtraNamespaceDeclaration(self, extraNamespaceDeclaraction: QXmlStreamNamespaceDeclaration) -> None: ...
    def namespaceDeclarations(self) -> typing.List[QXmlStreamNamespaceDeclaration]: ...
    def text(self) -> str: ...
    def processingInstructionData(self) -> str: ...
    def processingInstructionTarget(self) -> str: ...
    def prefix(self) -> str: ...
    def qualifiedName(self) -> str: ...
    def namespaceUri(self) -> str: ...
    def name(self) -> str: ...
    def readElementText(self, behaviour: int = ...) -> str: ...
    def attributes(self) -> QXmlStreamAttributes: ...
    def characterOffset(self) -> int: ...
    def columnNumber(self) -> int: ...
    def lineNumber(self) -> int: ...
    def documentEncoding(self) -> str: ...
    def documentVersion(self) -> str: ...
    def isStandaloneDocument(self) -> bool: ...
    def isProcessingInstruction(self) -> bool: ...
    def isEntityReference(self) -> bool: ...
    def isDTD(self) -> bool: ...
    def isComment(self) -> bool: ...
    def isCDATA(self) -> bool: ...
    def isWhitespace(self) -> bool: ...
    def isCharacters(self) -> bool: ...
    def isEndElement(self) -> bool: ...
    def isStartElement(self) -> bool: ...
    def isEndDocument(self) -> bool: ...
    def isStartDocument(self) -> bool: ...
    def namespaceProcessing(self) -> bool: ...
    def setNamespaceProcessing(self, a0: bool) -> None: ...
    def tokenString(self) -> str: ...
    def tokenType(self) -> int: ...
    def readNext(self) -> int: ...
    def atEnd(self) -> bool: ...
    def clear(self) -> None: ...
    @overload
    def addData(self, data: typing.Union[QByteArray, bytes, bytearray]) -> None: ...
    @overload
    def addData(self, data: str) -> None: ...
    def device(self) -> QIODevice: ...
    def setDevice(self, device: QIODevice) -> None: ...


class QXmlStreamWriter(sip.simplewrapper):

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, device: QIODevice) -> None: ...
    @overload
    def __init__(self, array: typing.Union[QByteArray, bytes, bytearray]) -> None: ...

    def hasError(self) -> bool: ...
    def writeCurrentToken(self, reader: QXmlStreamReader) -> None: ...
    @overload
    def writeStartElement(self, qualifiedName: str) -> None: ...
    @overload
    def writeStartElement(self, namespaceUri: str, name: str) -> None: ...
    @overload
    def writeStartDocument(self) -> None: ...
    @overload
    def writeStartDocument(self, version: str) -> None: ...
    @overload
    def writeStartDocument(self, version: str, standalone: bool) -> None: ...
    def writeProcessingInstruction(self, target: str, data: str = ...) -> None: ...
    def writeDefaultNamespace(self, namespaceUri: str) -> None: ...
    def writeNamespace(self, namespaceUri: str, prefix: str = ...) -> None: ...
    def writeEntityReference(self, name: str) -> None: ...
    def writeEndElement(self) -> None: ...
    def writeEndDocument(self) -> None: ...
    @overload
    def writeTextElement(self, qualifiedName: str, text: str) -> None: ...
    @overload
    def writeTextElement(self, namespaceUri: str, name: str, text: str) -> None: ...
    @overload
    def writeEmptyElement(self, qualifiedName: str) -> None: ...
    @overload
    def writeEmptyElement(self, namespaceUri: str, name: str) -> None: ...
    def writeDTD(self, dtd: str) -> None: ...
    def writeComment(self, text: str) -> None: ...
    def writeCharacters(self, text: str) -> None: ...
    def writeCDATA(self, text: str) -> None: ...
    def writeAttributes(self, attributes: QXmlStreamAttributes) -> None: ...
    @overload
    def writeAttribute(self, qualifiedName: str, value: str) -> None: ...
    @overload
    def writeAttribute(self, namespaceUri: str, name: str, value: str) -> None: ...
    @overload
    def writeAttribute(self, attribute: QXmlStreamAttribute) -> None: ...
    def autoFormattingIndent(self) -> int: ...
    def setAutoFormattingIndent(self, spaces: int) -> None: ...
    def autoFormatting(self) -> bool: ...
    def setAutoFormatting(self, a0: bool) -> None: ...
    def codec(self) -> QTextCodec: ...
    @overload
    def setCodec(self, codec: QTextCodec) -> None: ...
    @overload
    def setCodec(self, codecName: str) -> None: ...
    def device(self) -> QIODevice: ...
    def setDevice(self, device: QIODevice) -> None: ...


class QSysInfo(sip.simplewrapper):

    Endian: typing.Type[int]
    #class Endian(int): ...
    BigEndian = ... # type: int
    LittleEndian = ... # type: int
    ByteOrder = ... # type: int

    Sizes: typing.Type[int]
    #class Sizes(int): ...
    WordSize = ... # type: int

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, a0: QSysInfo) -> None: ...

    @staticmethod
    def machineHostName() -> str: ...
    @staticmethod
    def productVersion() -> str: ...
    @staticmethod
    def productType() -> str: ...
    @staticmethod
    def prettyProductName() -> str: ...
    @staticmethod
    def kernelVersion() -> str: ...
    @staticmethod
    def kernelType() -> str: ...
    @staticmethod
    def currentCpuArchitecture() -> str: ...
    @staticmethod
    def buildCpuArchitecture() -> str: ...
    @staticmethod
    def buildAbi() -> str: ...


PYQT_VERSION = ... # type: int
PYQT_VERSION_STR = ... # type: str
QT_VERSION = ... # type: int
QT_VERSION_STR = ... # type: str


def qSetRealNumberPrecision(precision: int) -> QTextStreamManipulator: ...
def qSetPadChar(ch: str) -> QTextStreamManipulator: ...
def qSetFieldWidth(width: int) -> QTextStreamManipulator: ...
def ws(s: QTextStream) -> QTextStream: ...
def bom(s: QTextStream) -> QTextStream: ...
def reset(s: QTextStream) -> QTextStream: ...
def flush(s: QTextStream) -> QTextStream: ...
def endl(s: QTextStream) -> QTextStream: ...
def center(s: QTextStream) -> QTextStream: ...
def right(s: QTextStream) -> QTextStream: ...
def left(s: QTextStream) -> QTextStream: ...
def scientific(s: QTextStream) -> QTextStream: ...
def fixed(s: QTextStream) -> QTextStream: ...
def lowercasedigits(s: QTextStream) -> QTextStream: ...
def lowercasebase(s: QTextStream) -> QTextStream: ...
def uppercasedigits(s: QTextStream) -> QTextStream: ...
def uppercasebase(s: QTextStream) -> QTextStream: ...
def noforcepoint(s: QTextStream) -> QTextStream: ...
def noforcesign(s: QTextStream) -> QTextStream: ...
def noshowbase(s: QTextStream) -> QTextStream: ...
def forcepoint(s: QTextStream) -> QTextStream: ...
def forcesign(s: QTextStream) -> QTextStream: ...
def showbase(s: QTextStream) -> QTextStream: ...
def hex_(s: QTextStream) -> QTextStream: ...
def dec(s: QTextStream) -> QTextStream: ...
def oct_(s: QTextStream) -> QTextStream: ...
def bin_(s: QTextStream) -> QTextStream: ...
def Q_RETURN_ARG(type: typing.Any) -> QGenericReturnArgument: ...
def Q_ARG(type: typing.Any, data: typing.Any) -> QGenericArgument: ...
def pyqtSlot(*types, name: typing.Optional[str] = ..., result: typing.Optional[str] = ...) -> typing.Callable[..., typing.Optional[str]]: ...
def QT_TRANSLATE_NOOP(a0: str, a1: str) -> str: ...
def QT_TR_NOOP_UTF8(a0: str) -> str: ...
def QT_TR_NOOP(a0: str) -> str: ...
def Q_FLAGS(*a0) -> None: ...
def Q_FLAG(a0: typing.Union[type, enum.Enum]) -> None: ...
def Q_ENUMS(*a0) -> None: ...
def Q_ENUM(a0: typing.Union[type, enum.Enum]) -> None: ...
def Q_CLASSINFO(name: str, value: str) -> None: ...
def qFloatDistance(a: float, b: float) -> int: ...
def qQNaN() -> float: ...
def qSNaN() -> float: ...
def qInf() -> float: ...
def qIsNaN(d: float) -> bool: ...
def qIsFinite(d: float) -> bool: ...
def qIsInf(d: float) -> bool: ...
def qFormatLogMessage(type: int, context: QMessageLogContext, buf: str) -> str: ...
def qSetMessagePattern(messagePattern: str) -> None: ...
def qInstallMessageHandler(a0: typing.Optional[typing.Callable[[int, QMessageLogContext, str], None]]) -> typing.Optional[typing.Callable[[int, QMessageLogContext, str], None]]: ...
def qWarning(msg: str) -> None: ...
def qInfo(msg: str) -> None: ...
def qFatal(msg: str) -> None: ...
@overload
def qErrnoWarning(code: int, msg: str) -> None: ...
@overload
def qErrnoWarning(msg: str) -> None: ...
def qDebug(msg: str) -> None: ...
def qCritical(msg: str) -> None: ...
def pyqtRestoreInputHook() -> None: ...
def pyqtRemoveInputHook() -> None: ...
def qAddPreRoutine(routine: typing.Callable[[], None]) -> None: ...
def qRemovePostRoutine(a0: typing.Callable[..., None]) -> None: ...
def qAddPostRoutine(a0: typing.Callable[..., None]) -> None: ...
@overload
def qChecksum(s: bytes) -> int: ...
@overload
def qChecksum(s: bytes, standard: int) -> int: ...
def qUncompress(data: typing.Union[QByteArray, bytes, bytearray]) -> QByteArray: ...
def qCompress(data: typing.Union[QByteArray, bytes, bytearray], compressionLevel: int = ...) -> QByteArray: ...
@overload
def qEnvironmentVariable(varName: str) -> str: ...
@overload
def qEnvironmentVariable(varName: str, defaultValue: str) -> str: ...
def pyqtPickleProtocol() -> typing.Optional[int]: ...
def pyqtSetPickleProtocol(a0: typing.Optional[int]) -> None: ...
def qrand() -> int: ...
def qsrand(seed: int) -> None: ...
def qIsNull(d: float) -> bool: ...
def qFuzzyCompare(p1: float, p2: float) -> bool: ...
def qUnregisterResourceData(a0: int, a1: bytes, a2: bytes, a3: bytes) -> bool: ...
def qRegisterResourceData(a0: int, a1: bytes, a2: bytes, a3: bytes) -> bool: ...
def qSharedBuild() -> bool: ...
def qVersion() -> str: ...
def qRound64(d: float) -> int: ...
def qRound(d: float) -> int: ...
def qAbs(t: float) -> float: ...
